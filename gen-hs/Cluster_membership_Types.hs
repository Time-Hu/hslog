{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Cluster_membership_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Common_Types as Common_Types
import qualified Nodes_Types as Nodes_Types


data ClusterMembershipFailureReason = UNKNOWN|NO_MATCH_IN_CONFIG|NOT_DEAD|NOT_DISABLED|ALREADY_EXISTS|INVALID_REQUEST_NODES_CONFIG  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ClusterMembershipFailureReason where
  fromEnum t = case t of
    UNKNOWN -> 0
    NO_MATCH_IN_CONFIG -> 1
    NOT_DEAD -> 2
    NOT_DISABLED -> 3
    ALREADY_EXISTS -> 4
    INVALID_REQUEST_NODES_CONFIG -> 5
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> NO_MATCH_IN_CONFIG
    2 -> NOT_DEAD
    3 -> NOT_DISABLED
    4 -> ALREADY_EXISTS
    5 -> INVALID_REQUEST_NODES_CONFIG
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> NO_MATCH_IN_CONFIG
    NO_MATCH_IN_CONFIG -> NOT_DEAD
    NOT_DEAD -> NOT_DISABLED
    NOT_DISABLED -> ALREADY_EXISTS
    ALREADY_EXISTS -> INVALID_REQUEST_NODES_CONFIG
    INVALID_REQUEST_NODES_CONFIG -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    NO_MATCH_IN_CONFIG -> UNKNOWN
    NOT_DEAD -> NO_MATCH_IN_CONFIG
    NOT_DISABLED -> NOT_DEAD
    ALREADY_EXISTS -> NOT_DISABLED
    INVALID_REQUEST_NODES_CONFIG -> ALREADY_EXISTS
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ClusterMembershipFailureReason where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ClusterMembershipFailureReason where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ClusterMembershipFailureReason where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
-- | Definition of the ClusterMembershipFailedNode struct
data ClusterMembershipFailedNode = ClusterMembershipFailedNode
  { clusterMembershipFailedNode_node_id :: Common_Types.NodeID
    -- ^ node_id field of the ClusterMembershipFailedNode struct
  , clusterMembershipFailedNode_reason :: Cluster_membership_Types.ClusterMembershipFailureReason
    -- ^ reason field of the ClusterMembershipFailedNode struct
  , clusterMembershipFailedNode_message :: LT.Text
    -- ^ message field of the ClusterMembershipFailedNode struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ClusterMembershipFailedNode where
  encode = encode_ClusterMembershipFailedNode
  decode = decode_ClusterMembershipFailedNode
instance Hashable.Hashable ClusterMembershipFailedNode where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` clusterMembershipFailedNode_node_id record   `Hashable.hashWithSalt` clusterMembershipFailedNode_reason record   `Hashable.hashWithSalt` clusterMembershipFailedNode_message record  
instance DeepSeq.NFData ClusterMembershipFailedNode where
  rnf _record0 =
    DeepSeq.rnf (clusterMembershipFailedNode_node_id _record0) `seq`
    DeepSeq.rnf (clusterMembershipFailedNode_reason _record0) `seq`
    DeepSeq.rnf (clusterMembershipFailedNode_message _record0) `seq`
    ()
instance Arbitrary.Arbitrary ClusterMembershipFailedNode where 
  arbitrary = Monad.liftM ClusterMembershipFailedNode (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ClusterMembershipFailedNode = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ClusterMembershipFailedNode{clusterMembershipFailedNode_node_id = clusterMembershipFailedNode_node_id obj} then Nothing else Just $ default_ClusterMembershipFailedNode{clusterMembershipFailedNode_node_id = clusterMembershipFailedNode_node_id obj}
    , if obj == default_ClusterMembershipFailedNode{clusterMembershipFailedNode_reason = clusterMembershipFailedNode_reason obj} then Nothing else Just $ default_ClusterMembershipFailedNode{clusterMembershipFailedNode_reason = clusterMembershipFailedNode_reason obj}
    , if obj == default_ClusterMembershipFailedNode{clusterMembershipFailedNode_message = clusterMembershipFailedNode_message obj} then Nothing else Just $ default_ClusterMembershipFailedNode{clusterMembershipFailedNode_message = clusterMembershipFailedNode_message obj}
    ]
-- | Translate a 'ClusterMembershipFailedNode' to a 'Types.ThriftVal'
from_ClusterMembershipFailedNode :: ClusterMembershipFailedNode -> Types.ThriftVal
from_ClusterMembershipFailedNode record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("node_id",Common_Types.from_NodeID _v3))) $ clusterMembershipFailedNode_node_id record
  , (\_v3 -> Just (2, ("reason",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ clusterMembershipFailedNode_reason record
  , (\_v3 -> Just (3, ("message",Types.TString $ Encoding.encodeUtf8 _v3))) $ clusterMembershipFailedNode_message record
  ]
-- | Write a 'ClusterMembershipFailedNode' with the given 'Thrift.Protocol'
write_ClusterMembershipFailedNode :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMembershipFailedNode -> IO ()
write_ClusterMembershipFailedNode oprot record = Thrift.writeVal oprot $ from_ClusterMembershipFailedNode record
-- | Serialize a 'ClusterMembershipFailedNode' in pure code
encode_ClusterMembershipFailedNode :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMembershipFailedNode -> BS.ByteString
encode_ClusterMembershipFailedNode oprot record = Thrift.serializeVal oprot $ from_ClusterMembershipFailedNode record
-- | Translate a 'Types.ThriftVal' to a 'ClusterMembershipFailedNode'
to_ClusterMembershipFailedNode :: Types.ThriftVal -> ClusterMembershipFailedNode
to_ClusterMembershipFailedNode (Types.TStruct fields) = ClusterMembershipFailedNode{
  clusterMembershipFailedNode_node_id = maybe (clusterMembershipFailedNode_node_id default_ClusterMembershipFailedNode) (\(_,_val5) -> (case _val5 of {Types.TStruct _val6 -> (Common_Types.to_NodeID (Types.TStruct _val6)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  clusterMembershipFailedNode_reason = maybe (clusterMembershipFailedNode_reason default_ClusterMembershipFailedNode) (\(_,_val5) -> (case _val5 of {Types.TI32 _val7 -> toEnum $ fromIntegral _val7; _ -> error "wrong type"})) (Map.lookup (2) fields),
  clusterMembershipFailedNode_message = maybe (clusterMembershipFailedNode_message default_ClusterMembershipFailedNode) (\(_,_val5) -> (case _val5 of {Types.TString _val8 -> Encoding.decodeUtf8 _val8; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_ClusterMembershipFailedNode _ = error "not a struct"
-- | Read a 'ClusterMembershipFailedNode' struct with the given 'Thrift.Protocol'
read_ClusterMembershipFailedNode :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ClusterMembershipFailedNode
read_ClusterMembershipFailedNode iprot = to_ClusterMembershipFailedNode <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ClusterMembershipFailedNode)
-- | Deserialize a 'ClusterMembershipFailedNode' in pure code
decode_ClusterMembershipFailedNode :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ClusterMembershipFailedNode
decode_ClusterMembershipFailedNode iprot bs = to_ClusterMembershipFailedNode $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ClusterMembershipFailedNode) bs
-- | 'TypeMap' for the 'ClusterMembershipFailedNode' struct
typemap_ClusterMembershipFailedNode :: Types.TypeMap
typemap_ClusterMembershipFailedNode = Map.fromList [("node_id",(1,(Types.T_STRUCT Common_Types.typemap_NodeID))),("reason",(2,Types.T_I32)),("message",(3,Types.T_STRING))]
-- | Default values for the 'ClusterMembershipFailedNode' struct
default_ClusterMembershipFailedNode :: ClusterMembershipFailedNode
default_ClusterMembershipFailedNode = ClusterMembershipFailedNode{
  clusterMembershipFailedNode_node_id = Common_Types.default_NodeID,
  clusterMembershipFailedNode_reason = (toEnum 0),
  clusterMembershipFailedNode_message = ""}
-- | Definition of the ClusterMembershipOperationFailed struct
data ClusterMembershipOperationFailed = ClusterMembershipOperationFailed
  { clusterMembershipOperationFailed_failed_nodes :: (Vector.Vector Cluster_membership_Types.ClusterMembershipFailedNode)
    -- ^ failed_nodes field of the ClusterMembershipOperationFailed struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Exception.Exception ClusterMembershipOperationFailed
instance Serializable.ThriftSerializable ClusterMembershipOperationFailed where
  encode = encode_ClusterMembershipOperationFailed
  decode = decode_ClusterMembershipOperationFailed
instance Hashable.Hashable ClusterMembershipOperationFailed where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` clusterMembershipOperationFailed_failed_nodes record  
instance DeepSeq.NFData ClusterMembershipOperationFailed where
  rnf _record9 =
    DeepSeq.rnf (clusterMembershipOperationFailed_failed_nodes _record9) `seq`
    ()
instance Arbitrary.Arbitrary ClusterMembershipOperationFailed where 
  arbitrary = Monad.liftM ClusterMembershipOperationFailed (Arbitrary.arbitrary)
  shrink obj | obj == default_ClusterMembershipOperationFailed = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ClusterMembershipOperationFailed{clusterMembershipOperationFailed_failed_nodes = clusterMembershipOperationFailed_failed_nodes obj} then Nothing else Just $ default_ClusterMembershipOperationFailed{clusterMembershipOperationFailed_failed_nodes = clusterMembershipOperationFailed_failed_nodes obj}
    ]
-- | Translate a 'ClusterMembershipOperationFailed' to a 'Types.ThriftVal'
from_ClusterMembershipOperationFailed :: ClusterMembershipOperationFailed -> Types.ThriftVal
from_ClusterMembershipOperationFailed record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v12 -> Just (1, ("failed_nodes",Types.TList (Types.T_STRUCT Cluster_membership_Types.typemap_ClusterMembershipFailedNode) $ map (\_v14 -> Cluster_membership_Types.from_ClusterMembershipFailedNode _v14) $ Vector.toList _v12))) $ clusterMembershipOperationFailed_failed_nodes record
  ]
-- | Write a 'ClusterMembershipOperationFailed' with the given 'Thrift.Protocol'
write_ClusterMembershipOperationFailed :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMembershipOperationFailed -> IO ()
write_ClusterMembershipOperationFailed oprot record = Thrift.writeVal oprot $ from_ClusterMembershipOperationFailed record
-- | Serialize a 'ClusterMembershipOperationFailed' in pure code
encode_ClusterMembershipOperationFailed :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMembershipOperationFailed -> BS.ByteString
encode_ClusterMembershipOperationFailed oprot record = Thrift.serializeVal oprot $ from_ClusterMembershipOperationFailed record
-- | Translate a 'Types.ThriftVal' to a 'ClusterMembershipOperationFailed'
to_ClusterMembershipOperationFailed :: Types.ThriftVal -> ClusterMembershipOperationFailed
to_ClusterMembershipOperationFailed (Types.TStruct fields) = ClusterMembershipOperationFailed{
  clusterMembershipOperationFailed_failed_nodes = maybe (clusterMembershipOperationFailed_failed_nodes default_ClusterMembershipOperationFailed) (\(_,_val16) -> (case _val16 of {Types.TList _ _val17 -> (Vector.fromList $ map (\_v18 -> (case _v18 of {Types.TStruct _val19 -> (Cluster_membership_Types.to_ClusterMembershipFailedNode (Types.TStruct _val19)); _ -> error "wrong type"})) _val17); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_ClusterMembershipOperationFailed _ = error "not a struct"
-- | Read a 'ClusterMembershipOperationFailed' struct with the given 'Thrift.Protocol'
read_ClusterMembershipOperationFailed :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ClusterMembershipOperationFailed
read_ClusterMembershipOperationFailed iprot = to_ClusterMembershipOperationFailed <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ClusterMembershipOperationFailed)
-- | Deserialize a 'ClusterMembershipOperationFailed' in pure code
decode_ClusterMembershipOperationFailed :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ClusterMembershipOperationFailed
decode_ClusterMembershipOperationFailed iprot bs = to_ClusterMembershipOperationFailed $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ClusterMembershipOperationFailed) bs
-- | 'TypeMap' for the 'ClusterMembershipOperationFailed' struct
typemap_ClusterMembershipOperationFailed :: Types.TypeMap
typemap_ClusterMembershipOperationFailed = Map.fromList [("failed_nodes",(1,(Types.T_LIST (Types.T_STRUCT Cluster_membership_Types.typemap_ClusterMembershipFailedNode))))]
-- | Default values for the 'ClusterMembershipOperationFailed' struct
default_ClusterMembershipOperationFailed :: ClusterMembershipOperationFailed
default_ClusterMembershipOperationFailed = ClusterMembershipOperationFailed{
  clusterMembershipOperationFailed_failed_nodes = Vector.empty}
-- | Definition of the AddSingleNodeRequest struct
data AddSingleNodeRequest = AddSingleNodeRequest
  { addSingleNodeRequest_new_config :: Nodes_Types.NodeConfig
    -- ^ new_config field of the AddSingleNodeRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable AddSingleNodeRequest where
  encode = encode_AddSingleNodeRequest
  decode = decode_AddSingleNodeRequest
instance Hashable.Hashable AddSingleNodeRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` addSingleNodeRequest_new_config record  
instance DeepSeq.NFData AddSingleNodeRequest where
  rnf _record20 =
    DeepSeq.rnf (addSingleNodeRequest_new_config _record20) `seq`
    ()
instance Arbitrary.Arbitrary AddSingleNodeRequest where 
  arbitrary = Monad.liftM AddSingleNodeRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_AddSingleNodeRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_AddSingleNodeRequest{addSingleNodeRequest_new_config = addSingleNodeRequest_new_config obj} then Nothing else Just $ default_AddSingleNodeRequest{addSingleNodeRequest_new_config = addSingleNodeRequest_new_config obj}
    ]
-- | Translate a 'AddSingleNodeRequest' to a 'Types.ThriftVal'
from_AddSingleNodeRequest :: AddSingleNodeRequest -> Types.ThriftVal
from_AddSingleNodeRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v23 -> Just (1, ("new_config",Nodes_Types.from_NodeConfig _v23))) $ addSingleNodeRequest_new_config record
  ]
-- | Write a 'AddSingleNodeRequest' with the given 'Thrift.Protocol'
write_AddSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddSingleNodeRequest -> IO ()
write_AddSingleNodeRequest oprot record = Thrift.writeVal oprot $ from_AddSingleNodeRequest record
-- | Serialize a 'AddSingleNodeRequest' in pure code
encode_AddSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddSingleNodeRequest -> BS.ByteString
encode_AddSingleNodeRequest oprot record = Thrift.serializeVal oprot $ from_AddSingleNodeRequest record
-- | Translate a 'Types.ThriftVal' to a 'AddSingleNodeRequest'
to_AddSingleNodeRequest :: Types.ThriftVal -> AddSingleNodeRequest
to_AddSingleNodeRequest (Types.TStruct fields) = AddSingleNodeRequest{
  addSingleNodeRequest_new_config = maybe (addSingleNodeRequest_new_config default_AddSingleNodeRequest) (\(_,_val25) -> (case _val25 of {Types.TStruct _val26 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val26)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddSingleNodeRequest _ = error "not a struct"
-- | Read a 'AddSingleNodeRequest' struct with the given 'Thrift.Protocol'
read_AddSingleNodeRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO AddSingleNodeRequest
read_AddSingleNodeRequest iprot = to_AddSingleNodeRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_AddSingleNodeRequest)
-- | Deserialize a 'AddSingleNodeRequest' in pure code
decode_AddSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> AddSingleNodeRequest
decode_AddSingleNodeRequest iprot bs = to_AddSingleNodeRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_AddSingleNodeRequest) bs
-- | 'TypeMap' for the 'AddSingleNodeRequest' struct
typemap_AddSingleNodeRequest :: Types.TypeMap
typemap_AddSingleNodeRequest = Map.fromList [("new_config",(1,(Types.T_STRUCT Nodes_Types.typemap_NodeConfig)))]
-- | Default values for the 'AddSingleNodeRequest' struct
default_AddSingleNodeRequest :: AddSingleNodeRequest
default_AddSingleNodeRequest = AddSingleNodeRequest{
  addSingleNodeRequest_new_config = Nodes_Types.default_NodeConfig}
-- | Definition of the AddNodesRequest struct
data AddNodesRequest = AddNodesRequest
  { addNodesRequest_new_node_requests :: (Vector.Vector Cluster_membership_Types.AddSingleNodeRequest)
    -- ^ new_node_requests field of the AddNodesRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable AddNodesRequest where
  encode = encode_AddNodesRequest
  decode = decode_AddNodesRequest
instance Hashable.Hashable AddNodesRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` addNodesRequest_new_node_requests record  
instance DeepSeq.NFData AddNodesRequest where
  rnf _record27 =
    DeepSeq.rnf (addNodesRequest_new_node_requests _record27) `seq`
    ()
instance Arbitrary.Arbitrary AddNodesRequest where 
  arbitrary = Monad.liftM AddNodesRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_AddNodesRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_AddNodesRequest{addNodesRequest_new_node_requests = addNodesRequest_new_node_requests obj} then Nothing else Just $ default_AddNodesRequest{addNodesRequest_new_node_requests = addNodesRequest_new_node_requests obj}
    ]
-- | Translate a 'AddNodesRequest' to a 'Types.ThriftVal'
from_AddNodesRequest :: AddNodesRequest -> Types.ThriftVal
from_AddNodesRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v30 -> Just (1, ("new_node_requests",Types.TList (Types.T_STRUCT Cluster_membership_Types.typemap_AddSingleNodeRequest) $ map (\_v32 -> Cluster_membership_Types.from_AddSingleNodeRequest _v32) $ Vector.toList _v30))) $ addNodesRequest_new_node_requests record
  ]
-- | Write a 'AddNodesRequest' with the given 'Thrift.Protocol'
write_AddNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodesRequest -> IO ()
write_AddNodesRequest oprot record = Thrift.writeVal oprot $ from_AddNodesRequest record
-- | Serialize a 'AddNodesRequest' in pure code
encode_AddNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodesRequest -> BS.ByteString
encode_AddNodesRequest oprot record = Thrift.serializeVal oprot $ from_AddNodesRequest record
-- | Translate a 'Types.ThriftVal' to a 'AddNodesRequest'
to_AddNodesRequest :: Types.ThriftVal -> AddNodesRequest
to_AddNodesRequest (Types.TStruct fields) = AddNodesRequest{
  addNodesRequest_new_node_requests = maybe (addNodesRequest_new_node_requests default_AddNodesRequest) (\(_,_val34) -> (case _val34 of {Types.TList _ _val35 -> (Vector.fromList $ map (\_v36 -> (case _v36 of {Types.TStruct _val37 -> (Cluster_membership_Types.to_AddSingleNodeRequest (Types.TStruct _val37)); _ -> error "wrong type"})) _val35); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddNodesRequest _ = error "not a struct"
-- | Read a 'AddNodesRequest' struct with the given 'Thrift.Protocol'
read_AddNodesRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO AddNodesRequest
read_AddNodesRequest iprot = to_AddNodesRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_AddNodesRequest)
-- | Deserialize a 'AddNodesRequest' in pure code
decode_AddNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> AddNodesRequest
decode_AddNodesRequest iprot bs = to_AddNodesRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_AddNodesRequest) bs
-- | 'TypeMap' for the 'AddNodesRequest' struct
typemap_AddNodesRequest :: Types.TypeMap
typemap_AddNodesRequest = Map.fromList [("new_node_requests",(1,(Types.T_LIST (Types.T_STRUCT Cluster_membership_Types.typemap_AddSingleNodeRequest))))]
-- | Default values for the 'AddNodesRequest' struct
default_AddNodesRequest :: AddNodesRequest
default_AddNodesRequest = AddNodesRequest{
  addNodesRequest_new_node_requests = Vector.empty}
-- | Definition of the AddNodesResponse struct
data AddNodesResponse = AddNodesResponse
  { addNodesResponse_added_nodes :: (Vector.Vector Nodes_Types.NodeConfig)
    -- ^ added_nodes field of the AddNodesResponse struct
  , addNodesResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the AddNodesResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable AddNodesResponse where
  encode = encode_AddNodesResponse
  decode = decode_AddNodesResponse
instance Hashable.Hashable AddNodesResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` addNodesResponse_added_nodes record   `Hashable.hashWithSalt` addNodesResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData AddNodesResponse where
  rnf _record38 =
    DeepSeq.rnf (addNodesResponse_added_nodes _record38) `seq`
    DeepSeq.rnf (addNodesResponse_new_nodes_configuration_version _record38) `seq`
    ()
instance Arbitrary.Arbitrary AddNodesResponse where 
  arbitrary = Monad.liftM AddNodesResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_AddNodesResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_AddNodesResponse{addNodesResponse_added_nodes = addNodesResponse_added_nodes obj} then Nothing else Just $ default_AddNodesResponse{addNodesResponse_added_nodes = addNodesResponse_added_nodes obj}
    , if obj == default_AddNodesResponse{addNodesResponse_new_nodes_configuration_version = addNodesResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_AddNodesResponse{addNodesResponse_new_nodes_configuration_version = addNodesResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'AddNodesResponse' to a 'Types.ThriftVal'
from_AddNodesResponse :: AddNodesResponse -> Types.ThriftVal
from_AddNodesResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v41 -> Just (1, ("added_nodes",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodeConfig) $ map (\_v43 -> Nodes_Types.from_NodeConfig _v43) $ Vector.toList _v41))) $ addNodesResponse_added_nodes record
  , (\_v41 -> Just (2, ("new_nodes_configuration_version",Types.TI64 _v41))) $ addNodesResponse_new_nodes_configuration_version record
  ]
-- | Write a 'AddNodesResponse' with the given 'Thrift.Protocol'
write_AddNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodesResponse -> IO ()
write_AddNodesResponse oprot record = Thrift.writeVal oprot $ from_AddNodesResponse record
-- | Serialize a 'AddNodesResponse' in pure code
encode_AddNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodesResponse -> BS.ByteString
encode_AddNodesResponse oprot record = Thrift.serializeVal oprot $ from_AddNodesResponse record
-- | Translate a 'Types.ThriftVal' to a 'AddNodesResponse'
to_AddNodesResponse :: Types.ThriftVal -> AddNodesResponse
to_AddNodesResponse (Types.TStruct fields) = AddNodesResponse{
  addNodesResponse_added_nodes = maybe (addNodesResponse_added_nodes default_AddNodesResponse) (\(_,_val45) -> (case _val45 of {Types.TList _ _val46 -> (Vector.fromList $ map (\_v47 -> (case _v47 of {Types.TStruct _val48 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val48)); _ -> error "wrong type"})) _val46); _ -> error "wrong type"})) (Map.lookup (1) fields),
  addNodesResponse_new_nodes_configuration_version = maybe (addNodesResponse_new_nodes_configuration_version default_AddNodesResponse) (\(_,_val45) -> (case _val45 of {Types.TI64 _val49 -> _val49; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_AddNodesResponse _ = error "not a struct"
-- | Read a 'AddNodesResponse' struct with the given 'Thrift.Protocol'
read_AddNodesResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO AddNodesResponse
read_AddNodesResponse iprot = to_AddNodesResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_AddNodesResponse)
-- | Deserialize a 'AddNodesResponse' in pure code
decode_AddNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> AddNodesResponse
decode_AddNodesResponse iprot bs = to_AddNodesResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_AddNodesResponse) bs
-- | 'TypeMap' for the 'AddNodesResponse' struct
typemap_AddNodesResponse :: Types.TypeMap
typemap_AddNodesResponse = Map.fromList [("added_nodes",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodeConfig)))),("new_nodes_configuration_version",(2,Types.T_I64))]
-- | Default values for the 'AddNodesResponse' struct
default_AddNodesResponse :: AddNodesResponse
default_AddNodesResponse = AddNodesResponse{
  addNodesResponse_added_nodes = Vector.empty,
  addNodesResponse_new_nodes_configuration_version = 0}
-- | Definition of the UpdateSingleNodeRequest struct
data UpdateSingleNodeRequest = UpdateSingleNodeRequest
  { updateSingleNodeRequest_node_to_be_updated :: Common_Types.NodeID
    -- ^ node_to_be_updated field of the UpdateSingleNodeRequest struct
  , updateSingleNodeRequest_new_config :: Nodes_Types.NodeConfig
    -- ^ new_config field of the UpdateSingleNodeRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable UpdateSingleNodeRequest where
  encode = encode_UpdateSingleNodeRequest
  decode = decode_UpdateSingleNodeRequest
instance Hashable.Hashable UpdateSingleNodeRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` updateSingleNodeRequest_node_to_be_updated record   `Hashable.hashWithSalt` updateSingleNodeRequest_new_config record  
instance DeepSeq.NFData UpdateSingleNodeRequest where
  rnf _record50 =
    DeepSeq.rnf (updateSingleNodeRequest_node_to_be_updated _record50) `seq`
    DeepSeq.rnf (updateSingleNodeRequest_new_config _record50) `seq`
    ()
instance Arbitrary.Arbitrary UpdateSingleNodeRequest where 
  arbitrary = Monad.liftM UpdateSingleNodeRequest (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_UpdateSingleNodeRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_UpdateSingleNodeRequest{updateSingleNodeRequest_node_to_be_updated = updateSingleNodeRequest_node_to_be_updated obj} then Nothing else Just $ default_UpdateSingleNodeRequest{updateSingleNodeRequest_node_to_be_updated = updateSingleNodeRequest_node_to_be_updated obj}
    , if obj == default_UpdateSingleNodeRequest{updateSingleNodeRequest_new_config = updateSingleNodeRequest_new_config obj} then Nothing else Just $ default_UpdateSingleNodeRequest{updateSingleNodeRequest_new_config = updateSingleNodeRequest_new_config obj}
    ]
-- | Translate a 'UpdateSingleNodeRequest' to a 'Types.ThriftVal'
from_UpdateSingleNodeRequest :: UpdateSingleNodeRequest -> Types.ThriftVal
from_UpdateSingleNodeRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v53 -> Just (1, ("node_to_be_updated",Common_Types.from_NodeID _v53))) $ updateSingleNodeRequest_node_to_be_updated record
  , (\_v53 -> Just (2, ("new_config",Nodes_Types.from_NodeConfig _v53))) $ updateSingleNodeRequest_new_config record
  ]
-- | Write a 'UpdateSingleNodeRequest' with the given 'Thrift.Protocol'
write_UpdateSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateSingleNodeRequest -> IO ()
write_UpdateSingleNodeRequest oprot record = Thrift.writeVal oprot $ from_UpdateSingleNodeRequest record
-- | Serialize a 'UpdateSingleNodeRequest' in pure code
encode_UpdateSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateSingleNodeRequest -> BS.ByteString
encode_UpdateSingleNodeRequest oprot record = Thrift.serializeVal oprot $ from_UpdateSingleNodeRequest record
-- | Translate a 'Types.ThriftVal' to a 'UpdateSingleNodeRequest'
to_UpdateSingleNodeRequest :: Types.ThriftVal -> UpdateSingleNodeRequest
to_UpdateSingleNodeRequest (Types.TStruct fields) = UpdateSingleNodeRequest{
  updateSingleNodeRequest_node_to_be_updated = maybe (updateSingleNodeRequest_node_to_be_updated default_UpdateSingleNodeRequest) (\(_,_val55) -> (case _val55 of {Types.TStruct _val56 -> (Common_Types.to_NodeID (Types.TStruct _val56)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  updateSingleNodeRequest_new_config = maybe (updateSingleNodeRequest_new_config default_UpdateSingleNodeRequest) (\(_,_val55) -> (case _val55 of {Types.TStruct _val57 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val57)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSingleNodeRequest _ = error "not a struct"
-- | Read a 'UpdateSingleNodeRequest' struct with the given 'Thrift.Protocol'
read_UpdateSingleNodeRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO UpdateSingleNodeRequest
read_UpdateSingleNodeRequest iprot = to_UpdateSingleNodeRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_UpdateSingleNodeRequest)
-- | Deserialize a 'UpdateSingleNodeRequest' in pure code
decode_UpdateSingleNodeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> UpdateSingleNodeRequest
decode_UpdateSingleNodeRequest iprot bs = to_UpdateSingleNodeRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_UpdateSingleNodeRequest) bs
-- | 'TypeMap' for the 'UpdateSingleNodeRequest' struct
typemap_UpdateSingleNodeRequest :: Types.TypeMap
typemap_UpdateSingleNodeRequest = Map.fromList [("node_to_be_updated",(1,(Types.T_STRUCT Common_Types.typemap_NodeID))),("new_config",(2,(Types.T_STRUCT Nodes_Types.typemap_NodeConfig)))]
-- | Default values for the 'UpdateSingleNodeRequest' struct
default_UpdateSingleNodeRequest :: UpdateSingleNodeRequest
default_UpdateSingleNodeRequest = UpdateSingleNodeRequest{
  updateSingleNodeRequest_node_to_be_updated = Common_Types.default_NodeID,
  updateSingleNodeRequest_new_config = Nodes_Types.default_NodeConfig}
-- | Definition of the UpdateNodesRequest struct
data UpdateNodesRequest = UpdateNodesRequest
  { updateNodesRequest_node_requests :: (Vector.Vector Cluster_membership_Types.UpdateSingleNodeRequest)
    -- ^ node_requests field of the UpdateNodesRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable UpdateNodesRequest where
  encode = encode_UpdateNodesRequest
  decode = decode_UpdateNodesRequest
instance Hashable.Hashable UpdateNodesRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` updateNodesRequest_node_requests record  
instance DeepSeq.NFData UpdateNodesRequest where
  rnf _record58 =
    DeepSeq.rnf (updateNodesRequest_node_requests _record58) `seq`
    ()
instance Arbitrary.Arbitrary UpdateNodesRequest where 
  arbitrary = Monad.liftM UpdateNodesRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_UpdateNodesRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_UpdateNodesRequest{updateNodesRequest_node_requests = updateNodesRequest_node_requests obj} then Nothing else Just $ default_UpdateNodesRequest{updateNodesRequest_node_requests = updateNodesRequest_node_requests obj}
    ]
-- | Translate a 'UpdateNodesRequest' to a 'Types.ThriftVal'
from_UpdateNodesRequest :: UpdateNodesRequest -> Types.ThriftVal
from_UpdateNodesRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v61 -> Just (1, ("node_requests",Types.TList (Types.T_STRUCT Cluster_membership_Types.typemap_UpdateSingleNodeRequest) $ map (\_v63 -> Cluster_membership_Types.from_UpdateSingleNodeRequest _v63) $ Vector.toList _v61))) $ updateNodesRequest_node_requests record
  ]
-- | Write a 'UpdateNodesRequest' with the given 'Thrift.Protocol'
write_UpdateNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodesRequest -> IO ()
write_UpdateNodesRequest oprot record = Thrift.writeVal oprot $ from_UpdateNodesRequest record
-- | Serialize a 'UpdateNodesRequest' in pure code
encode_UpdateNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodesRequest -> BS.ByteString
encode_UpdateNodesRequest oprot record = Thrift.serializeVal oprot $ from_UpdateNodesRequest record
-- | Translate a 'Types.ThriftVal' to a 'UpdateNodesRequest'
to_UpdateNodesRequest :: Types.ThriftVal -> UpdateNodesRequest
to_UpdateNodesRequest (Types.TStruct fields) = UpdateNodesRequest{
  updateNodesRequest_node_requests = maybe (updateNodesRequest_node_requests default_UpdateNodesRequest) (\(_,_val65) -> (case _val65 of {Types.TList _ _val66 -> (Vector.fromList $ map (\_v67 -> (case _v67 of {Types.TStruct _val68 -> (Cluster_membership_Types.to_UpdateSingleNodeRequest (Types.TStruct _val68)); _ -> error "wrong type"})) _val66); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNodesRequest _ = error "not a struct"
-- | Read a 'UpdateNodesRequest' struct with the given 'Thrift.Protocol'
read_UpdateNodesRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO UpdateNodesRequest
read_UpdateNodesRequest iprot = to_UpdateNodesRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_UpdateNodesRequest)
-- | Deserialize a 'UpdateNodesRequest' in pure code
decode_UpdateNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> UpdateNodesRequest
decode_UpdateNodesRequest iprot bs = to_UpdateNodesRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_UpdateNodesRequest) bs
-- | 'TypeMap' for the 'UpdateNodesRequest' struct
typemap_UpdateNodesRequest :: Types.TypeMap
typemap_UpdateNodesRequest = Map.fromList [("node_requests",(1,(Types.T_LIST (Types.T_STRUCT Cluster_membership_Types.typemap_UpdateSingleNodeRequest))))]
-- | Default values for the 'UpdateNodesRequest' struct
default_UpdateNodesRequest :: UpdateNodesRequest
default_UpdateNodesRequest = UpdateNodesRequest{
  updateNodesRequest_node_requests = Vector.empty}
-- | Definition of the UpdateNodesResponse struct
data UpdateNodesResponse = UpdateNodesResponse
  { updateNodesResponse_updated_nodes :: (Vector.Vector Nodes_Types.NodeConfig)
    -- ^ updated_nodes field of the UpdateNodesResponse struct
  , updateNodesResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the UpdateNodesResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable UpdateNodesResponse where
  encode = encode_UpdateNodesResponse
  decode = decode_UpdateNodesResponse
instance Hashable.Hashable UpdateNodesResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` updateNodesResponse_updated_nodes record   `Hashable.hashWithSalt` updateNodesResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData UpdateNodesResponse where
  rnf _record69 =
    DeepSeq.rnf (updateNodesResponse_updated_nodes _record69) `seq`
    DeepSeq.rnf (updateNodesResponse_new_nodes_configuration_version _record69) `seq`
    ()
instance Arbitrary.Arbitrary UpdateNodesResponse where 
  arbitrary = Monad.liftM UpdateNodesResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_UpdateNodesResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_UpdateNodesResponse{updateNodesResponse_updated_nodes = updateNodesResponse_updated_nodes obj} then Nothing else Just $ default_UpdateNodesResponse{updateNodesResponse_updated_nodes = updateNodesResponse_updated_nodes obj}
    , if obj == default_UpdateNodesResponse{updateNodesResponse_new_nodes_configuration_version = updateNodesResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_UpdateNodesResponse{updateNodesResponse_new_nodes_configuration_version = updateNodesResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'UpdateNodesResponse' to a 'Types.ThriftVal'
from_UpdateNodesResponse :: UpdateNodesResponse -> Types.ThriftVal
from_UpdateNodesResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v72 -> Just (1, ("updated_nodes",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodeConfig) $ map (\_v74 -> Nodes_Types.from_NodeConfig _v74) $ Vector.toList _v72))) $ updateNodesResponse_updated_nodes record
  , (\_v72 -> Just (2, ("new_nodes_configuration_version",Types.TI64 _v72))) $ updateNodesResponse_new_nodes_configuration_version record
  ]
-- | Write a 'UpdateNodesResponse' with the given 'Thrift.Protocol'
write_UpdateNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodesResponse -> IO ()
write_UpdateNodesResponse oprot record = Thrift.writeVal oprot $ from_UpdateNodesResponse record
-- | Serialize a 'UpdateNodesResponse' in pure code
encode_UpdateNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodesResponse -> BS.ByteString
encode_UpdateNodesResponse oprot record = Thrift.serializeVal oprot $ from_UpdateNodesResponse record
-- | Translate a 'Types.ThriftVal' to a 'UpdateNodesResponse'
to_UpdateNodesResponse :: Types.ThriftVal -> UpdateNodesResponse
to_UpdateNodesResponse (Types.TStruct fields) = UpdateNodesResponse{
  updateNodesResponse_updated_nodes = maybe (updateNodesResponse_updated_nodes default_UpdateNodesResponse) (\(_,_val76) -> (case _val76 of {Types.TList _ _val77 -> (Vector.fromList $ map (\_v78 -> (case _v78 of {Types.TStruct _val79 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val79)); _ -> error "wrong type"})) _val77); _ -> error "wrong type"})) (Map.lookup (1) fields),
  updateNodesResponse_new_nodes_configuration_version = maybe (updateNodesResponse_new_nodes_configuration_version default_UpdateNodesResponse) (\(_,_val76) -> (case _val76 of {Types.TI64 _val80 -> _val80; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNodesResponse _ = error "not a struct"
-- | Read a 'UpdateNodesResponse' struct with the given 'Thrift.Protocol'
read_UpdateNodesResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO UpdateNodesResponse
read_UpdateNodesResponse iprot = to_UpdateNodesResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_UpdateNodesResponse)
-- | Deserialize a 'UpdateNodesResponse' in pure code
decode_UpdateNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> UpdateNodesResponse
decode_UpdateNodesResponse iprot bs = to_UpdateNodesResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_UpdateNodesResponse) bs
-- | 'TypeMap' for the 'UpdateNodesResponse' struct
typemap_UpdateNodesResponse :: Types.TypeMap
typemap_UpdateNodesResponse = Map.fromList [("updated_nodes",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodeConfig)))),("new_nodes_configuration_version",(2,Types.T_I64))]
-- | Default values for the 'UpdateNodesResponse' struct
default_UpdateNodesResponse :: UpdateNodesResponse
default_UpdateNodesResponse = UpdateNodesResponse{
  updateNodesResponse_updated_nodes = Vector.empty,
  updateNodesResponse_new_nodes_configuration_version = 0}
-- | Definition of the RemoveNodesRequest struct
data RemoveNodesRequest = RemoveNodesRequest
  { removeNodesRequest_node_filters :: (Vector.Vector Nodes_Types.NodesFilter)
    -- ^ node_filters field of the RemoveNodesRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveNodesRequest where
  encode = encode_RemoveNodesRequest
  decode = decode_RemoveNodesRequest
instance Hashable.Hashable RemoveNodesRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeNodesRequest_node_filters record  
instance DeepSeq.NFData RemoveNodesRequest where
  rnf _record81 =
    DeepSeq.rnf (removeNodesRequest_node_filters _record81) `seq`
    ()
instance Arbitrary.Arbitrary RemoveNodesRequest where 
  arbitrary = Monad.liftM RemoveNodesRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveNodesRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveNodesRequest{removeNodesRequest_node_filters = removeNodesRequest_node_filters obj} then Nothing else Just $ default_RemoveNodesRequest{removeNodesRequest_node_filters = removeNodesRequest_node_filters obj}
    ]
-- | Translate a 'RemoveNodesRequest' to a 'Types.ThriftVal'
from_RemoveNodesRequest :: RemoveNodesRequest -> Types.ThriftVal
from_RemoveNodesRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v84 -> Just (1, ("node_filters",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodesFilter) $ map (\_v86 -> Nodes_Types.from_NodesFilter _v86) $ Vector.toList _v84))) $ removeNodesRequest_node_filters record
  ]
-- | Write a 'RemoveNodesRequest' with the given 'Thrift.Protocol'
write_RemoveNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodesRequest -> IO ()
write_RemoveNodesRequest oprot record = Thrift.writeVal oprot $ from_RemoveNodesRequest record
-- | Serialize a 'RemoveNodesRequest' in pure code
encode_RemoveNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodesRequest -> BS.ByteString
encode_RemoveNodesRequest oprot record = Thrift.serializeVal oprot $ from_RemoveNodesRequest record
-- | Translate a 'Types.ThriftVal' to a 'RemoveNodesRequest'
to_RemoveNodesRequest :: Types.ThriftVal -> RemoveNodesRequest
to_RemoveNodesRequest (Types.TStruct fields) = RemoveNodesRequest{
  removeNodesRequest_node_filters = maybe (removeNodesRequest_node_filters default_RemoveNodesRequest) (\(_,_val88) -> (case _val88 of {Types.TList _ _val89 -> (Vector.fromList $ map (\_v90 -> (case _v90 of {Types.TStruct _val91 -> (Nodes_Types.to_NodesFilter (Types.TStruct _val91)); _ -> error "wrong type"})) _val89); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveNodesRequest _ = error "not a struct"
-- | Read a 'RemoveNodesRequest' struct with the given 'Thrift.Protocol'
read_RemoveNodesRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveNodesRequest
read_RemoveNodesRequest iprot = to_RemoveNodesRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveNodesRequest)
-- | Deserialize a 'RemoveNodesRequest' in pure code
decode_RemoveNodesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveNodesRequest
decode_RemoveNodesRequest iprot bs = to_RemoveNodesRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveNodesRequest) bs
-- | 'TypeMap' for the 'RemoveNodesRequest' struct
typemap_RemoveNodesRequest :: Types.TypeMap
typemap_RemoveNodesRequest = Map.fromList [("node_filters",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodesFilter))))]
-- | Default values for the 'RemoveNodesRequest' struct
default_RemoveNodesRequest :: RemoveNodesRequest
default_RemoveNodesRequest = RemoveNodesRequest{
  removeNodesRequest_node_filters = Vector.empty}
-- | Definition of the RemoveNodesResponse struct
data RemoveNodesResponse = RemoveNodesResponse
  { removeNodesResponse_removed_nodes :: (Vector.Vector Common_Types.NodeID)
    -- ^ removed_nodes field of the RemoveNodesResponse struct
  , removeNodesResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the RemoveNodesResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveNodesResponse where
  encode = encode_RemoveNodesResponse
  decode = decode_RemoveNodesResponse
instance Hashable.Hashable RemoveNodesResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeNodesResponse_removed_nodes record   `Hashable.hashWithSalt` removeNodesResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData RemoveNodesResponse where
  rnf _record92 =
    DeepSeq.rnf (removeNodesResponse_removed_nodes _record92) `seq`
    DeepSeq.rnf (removeNodesResponse_new_nodes_configuration_version _record92) `seq`
    ()
instance Arbitrary.Arbitrary RemoveNodesResponse where 
  arbitrary = Monad.liftM RemoveNodesResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveNodesResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveNodesResponse{removeNodesResponse_removed_nodes = removeNodesResponse_removed_nodes obj} then Nothing else Just $ default_RemoveNodesResponse{removeNodesResponse_removed_nodes = removeNodesResponse_removed_nodes obj}
    , if obj == default_RemoveNodesResponse{removeNodesResponse_new_nodes_configuration_version = removeNodesResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_RemoveNodesResponse{removeNodesResponse_new_nodes_configuration_version = removeNodesResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'RemoveNodesResponse' to a 'Types.ThriftVal'
from_RemoveNodesResponse :: RemoveNodesResponse -> Types.ThriftVal
from_RemoveNodesResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v95 -> Just (1, ("removed_nodes",Types.TList (Types.T_STRUCT Common_Types.typemap_NodeID) $ map (\_v97 -> Common_Types.from_NodeID _v97) $ Vector.toList _v95))) $ removeNodesResponse_removed_nodes record
  , (\_v95 -> Just (2, ("new_nodes_configuration_version",Types.TI64 _v95))) $ removeNodesResponse_new_nodes_configuration_version record
  ]
-- | Write a 'RemoveNodesResponse' with the given 'Thrift.Protocol'
write_RemoveNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodesResponse -> IO ()
write_RemoveNodesResponse oprot record = Thrift.writeVal oprot $ from_RemoveNodesResponse record
-- | Serialize a 'RemoveNodesResponse' in pure code
encode_RemoveNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodesResponse -> BS.ByteString
encode_RemoveNodesResponse oprot record = Thrift.serializeVal oprot $ from_RemoveNodesResponse record
-- | Translate a 'Types.ThriftVal' to a 'RemoveNodesResponse'
to_RemoveNodesResponse :: Types.ThriftVal -> RemoveNodesResponse
to_RemoveNodesResponse (Types.TStruct fields) = RemoveNodesResponse{
  removeNodesResponse_removed_nodes = maybe (removeNodesResponse_removed_nodes default_RemoveNodesResponse) (\(_,_val99) -> (case _val99 of {Types.TList _ _val100 -> (Vector.fromList $ map (\_v101 -> (case _v101 of {Types.TStruct _val102 -> (Common_Types.to_NodeID (Types.TStruct _val102)); _ -> error "wrong type"})) _val100); _ -> error "wrong type"})) (Map.lookup (1) fields),
  removeNodesResponse_new_nodes_configuration_version = maybe (removeNodesResponse_new_nodes_configuration_version default_RemoveNodesResponse) (\(_,_val99) -> (case _val99 of {Types.TI64 _val103 -> _val103; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveNodesResponse _ = error "not a struct"
-- | Read a 'RemoveNodesResponse' struct with the given 'Thrift.Protocol'
read_RemoveNodesResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveNodesResponse
read_RemoveNodesResponse iprot = to_RemoveNodesResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveNodesResponse)
-- | Deserialize a 'RemoveNodesResponse' in pure code
decode_RemoveNodesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveNodesResponse
decode_RemoveNodesResponse iprot bs = to_RemoveNodesResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveNodesResponse) bs
-- | 'TypeMap' for the 'RemoveNodesResponse' struct
typemap_RemoveNodesResponse :: Types.TypeMap
typemap_RemoveNodesResponse = Map.fromList [("removed_nodes",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_NodeID)))),("new_nodes_configuration_version",(2,Types.T_I64))]
-- | Default values for the 'RemoveNodesResponse' struct
default_RemoveNodesResponse :: RemoveNodesResponse
default_RemoveNodesResponse = RemoveNodesResponse{
  removeNodesResponse_removed_nodes = Vector.empty,
  removeNodesResponse_new_nodes_configuration_version = 0}
-- | Definition of the MarkShardsAsProvisionedRequest struct
data MarkShardsAsProvisionedRequest = MarkShardsAsProvisionedRequest
  { markShardsAsProvisionedRequest_shards :: (Vector.Vector Common_Types.ShardID)
    -- ^ shards field of the MarkShardsAsProvisionedRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkShardsAsProvisionedRequest where
  encode = encode_MarkShardsAsProvisionedRequest
  decode = decode_MarkShardsAsProvisionedRequest
instance Hashable.Hashable MarkShardsAsProvisionedRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markShardsAsProvisionedRequest_shards record  
instance DeepSeq.NFData MarkShardsAsProvisionedRequest where
  rnf _record104 =
    DeepSeq.rnf (markShardsAsProvisionedRequest_shards _record104) `seq`
    ()
instance Arbitrary.Arbitrary MarkShardsAsProvisionedRequest where 
  arbitrary = Monad.liftM MarkShardsAsProvisionedRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_MarkShardsAsProvisionedRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkShardsAsProvisionedRequest{markShardsAsProvisionedRequest_shards = markShardsAsProvisionedRequest_shards obj} then Nothing else Just $ default_MarkShardsAsProvisionedRequest{markShardsAsProvisionedRequest_shards = markShardsAsProvisionedRequest_shards obj}
    ]
-- | Translate a 'MarkShardsAsProvisionedRequest' to a 'Types.ThriftVal'
from_MarkShardsAsProvisionedRequest :: MarkShardsAsProvisionedRequest -> Types.ThriftVal
from_MarkShardsAsProvisionedRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v107 -> Just (1, ("shards",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v109 -> Common_Types.from_ShardID _v109) $ Vector.toList _v107))) $ markShardsAsProvisionedRequest_shards record
  ]
-- | Write a 'MarkShardsAsProvisionedRequest' with the given 'Thrift.Protocol'
write_MarkShardsAsProvisionedRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisionedRequest -> IO ()
write_MarkShardsAsProvisionedRequest oprot record = Thrift.writeVal oprot $ from_MarkShardsAsProvisionedRequest record
-- | Serialize a 'MarkShardsAsProvisionedRequest' in pure code
encode_MarkShardsAsProvisionedRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisionedRequest -> BS.ByteString
encode_MarkShardsAsProvisionedRequest oprot record = Thrift.serializeVal oprot $ from_MarkShardsAsProvisionedRequest record
-- | Translate a 'Types.ThriftVal' to a 'MarkShardsAsProvisionedRequest'
to_MarkShardsAsProvisionedRequest :: Types.ThriftVal -> MarkShardsAsProvisionedRequest
to_MarkShardsAsProvisionedRequest (Types.TStruct fields) = MarkShardsAsProvisionedRequest{
  markShardsAsProvisionedRequest_shards = maybe (markShardsAsProvisionedRequest_shards default_MarkShardsAsProvisionedRequest) (\(_,_val111) -> (case _val111 of {Types.TList _ _val112 -> (Vector.fromList $ map (\_v113 -> (case _v113 of {Types.TStruct _val114 -> (Common_Types.to_ShardID (Types.TStruct _val114)); _ -> error "wrong type"})) _val112); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkShardsAsProvisionedRequest _ = error "not a struct"
-- | Read a 'MarkShardsAsProvisionedRequest' struct with the given 'Thrift.Protocol'
read_MarkShardsAsProvisionedRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkShardsAsProvisionedRequest
read_MarkShardsAsProvisionedRequest iprot = to_MarkShardsAsProvisionedRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisionedRequest)
-- | Deserialize a 'MarkShardsAsProvisionedRequest' in pure code
decode_MarkShardsAsProvisionedRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkShardsAsProvisionedRequest
decode_MarkShardsAsProvisionedRequest iprot bs = to_MarkShardsAsProvisionedRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisionedRequest) bs
-- | 'TypeMap' for the 'MarkShardsAsProvisionedRequest' struct
typemap_MarkShardsAsProvisionedRequest :: Types.TypeMap
typemap_MarkShardsAsProvisionedRequest = Map.fromList [("shards",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID))))]
-- | Default values for the 'MarkShardsAsProvisionedRequest' struct
default_MarkShardsAsProvisionedRequest :: MarkShardsAsProvisionedRequest
default_MarkShardsAsProvisionedRequest = MarkShardsAsProvisionedRequest{
  markShardsAsProvisionedRequest_shards = Vector.empty}
-- | Definition of the MarkShardsAsProvisionedResponse struct
data MarkShardsAsProvisionedResponse = MarkShardsAsProvisionedResponse
  { markShardsAsProvisionedResponse_updated_shards :: (Vector.Vector Common_Types.ShardID)
    -- ^ updated_shards field of the MarkShardsAsProvisionedResponse struct
  , markShardsAsProvisionedResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the MarkShardsAsProvisionedResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkShardsAsProvisionedResponse where
  encode = encode_MarkShardsAsProvisionedResponse
  decode = decode_MarkShardsAsProvisionedResponse
instance Hashable.Hashable MarkShardsAsProvisionedResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markShardsAsProvisionedResponse_updated_shards record   `Hashable.hashWithSalt` markShardsAsProvisionedResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData MarkShardsAsProvisionedResponse where
  rnf _record115 =
    DeepSeq.rnf (markShardsAsProvisionedResponse_updated_shards _record115) `seq`
    DeepSeq.rnf (markShardsAsProvisionedResponse_new_nodes_configuration_version _record115) `seq`
    ()
instance Arbitrary.Arbitrary MarkShardsAsProvisionedResponse where 
  arbitrary = Monad.liftM MarkShardsAsProvisionedResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_MarkShardsAsProvisionedResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkShardsAsProvisionedResponse{markShardsAsProvisionedResponse_updated_shards = markShardsAsProvisionedResponse_updated_shards obj} then Nothing else Just $ default_MarkShardsAsProvisionedResponse{markShardsAsProvisionedResponse_updated_shards = markShardsAsProvisionedResponse_updated_shards obj}
    , if obj == default_MarkShardsAsProvisionedResponse{markShardsAsProvisionedResponse_new_nodes_configuration_version = markShardsAsProvisionedResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_MarkShardsAsProvisionedResponse{markShardsAsProvisionedResponse_new_nodes_configuration_version = markShardsAsProvisionedResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'MarkShardsAsProvisionedResponse' to a 'Types.ThriftVal'
from_MarkShardsAsProvisionedResponse :: MarkShardsAsProvisionedResponse -> Types.ThriftVal
from_MarkShardsAsProvisionedResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v118 -> Just (1, ("updated_shards",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v120 -> Common_Types.from_ShardID _v120) $ Vector.toList _v118))) $ markShardsAsProvisionedResponse_updated_shards record
  , (\_v118 -> Just (2, ("new_nodes_configuration_version",Types.TI64 _v118))) $ markShardsAsProvisionedResponse_new_nodes_configuration_version record
  ]
-- | Write a 'MarkShardsAsProvisionedResponse' with the given 'Thrift.Protocol'
write_MarkShardsAsProvisionedResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisionedResponse -> IO ()
write_MarkShardsAsProvisionedResponse oprot record = Thrift.writeVal oprot $ from_MarkShardsAsProvisionedResponse record
-- | Serialize a 'MarkShardsAsProvisionedResponse' in pure code
encode_MarkShardsAsProvisionedResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisionedResponse -> BS.ByteString
encode_MarkShardsAsProvisionedResponse oprot record = Thrift.serializeVal oprot $ from_MarkShardsAsProvisionedResponse record
-- | Translate a 'Types.ThriftVal' to a 'MarkShardsAsProvisionedResponse'
to_MarkShardsAsProvisionedResponse :: Types.ThriftVal -> MarkShardsAsProvisionedResponse
to_MarkShardsAsProvisionedResponse (Types.TStruct fields) = MarkShardsAsProvisionedResponse{
  markShardsAsProvisionedResponse_updated_shards = maybe (markShardsAsProvisionedResponse_updated_shards default_MarkShardsAsProvisionedResponse) (\(_,_val122) -> (case _val122 of {Types.TList _ _val123 -> (Vector.fromList $ map (\_v124 -> (case _v124 of {Types.TStruct _val125 -> (Common_Types.to_ShardID (Types.TStruct _val125)); _ -> error "wrong type"})) _val123); _ -> error "wrong type"})) (Map.lookup (1) fields),
  markShardsAsProvisionedResponse_new_nodes_configuration_version = maybe (markShardsAsProvisionedResponse_new_nodes_configuration_version default_MarkShardsAsProvisionedResponse) (\(_,_val122) -> (case _val122 of {Types.TI64 _val126 -> _val126; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_MarkShardsAsProvisionedResponse _ = error "not a struct"
-- | Read a 'MarkShardsAsProvisionedResponse' struct with the given 'Thrift.Protocol'
read_MarkShardsAsProvisionedResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkShardsAsProvisionedResponse
read_MarkShardsAsProvisionedResponse iprot = to_MarkShardsAsProvisionedResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisionedResponse)
-- | Deserialize a 'MarkShardsAsProvisionedResponse' in pure code
decode_MarkShardsAsProvisionedResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkShardsAsProvisionedResponse
decode_MarkShardsAsProvisionedResponse iprot bs = to_MarkShardsAsProvisionedResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisionedResponse) bs
-- | 'TypeMap' for the 'MarkShardsAsProvisionedResponse' struct
typemap_MarkShardsAsProvisionedResponse :: Types.TypeMap
typemap_MarkShardsAsProvisionedResponse = Map.fromList [("updated_shards",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID)))),("new_nodes_configuration_version",(2,Types.T_I64))]
-- | Default values for the 'MarkShardsAsProvisionedResponse' struct
default_MarkShardsAsProvisionedResponse :: MarkShardsAsProvisionedResponse
default_MarkShardsAsProvisionedResponse = MarkShardsAsProvisionedResponse{
  markShardsAsProvisionedResponse_updated_shards = Vector.empty,
  markShardsAsProvisionedResponse_new_nodes_configuration_version = 0}
-- | Definition of the BumpGenerationRequest struct
data BumpGenerationRequest = BumpGenerationRequest
  { bumpGenerationRequest_node_filters :: (Vector.Vector Nodes_Types.NodesFilter)
    -- ^ node_filters field of the BumpGenerationRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BumpGenerationRequest where
  encode = encode_BumpGenerationRequest
  decode = decode_BumpGenerationRequest
instance Hashable.Hashable BumpGenerationRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bumpGenerationRequest_node_filters record  
instance DeepSeq.NFData BumpGenerationRequest where
  rnf _record127 =
    DeepSeq.rnf (bumpGenerationRequest_node_filters _record127) `seq`
    ()
instance Arbitrary.Arbitrary BumpGenerationRequest where 
  arbitrary = Monad.liftM BumpGenerationRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_BumpGenerationRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BumpGenerationRequest{bumpGenerationRequest_node_filters = bumpGenerationRequest_node_filters obj} then Nothing else Just $ default_BumpGenerationRequest{bumpGenerationRequest_node_filters = bumpGenerationRequest_node_filters obj}
    ]
-- | Translate a 'BumpGenerationRequest' to a 'Types.ThriftVal'
from_BumpGenerationRequest :: BumpGenerationRequest -> Types.ThriftVal
from_BumpGenerationRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v130 -> Just (1, ("node_filters",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodesFilter) $ map (\_v132 -> Nodes_Types.from_NodesFilter _v132) $ Vector.toList _v130))) $ bumpGenerationRequest_node_filters record
  ]
-- | Write a 'BumpGenerationRequest' with the given 'Thrift.Protocol'
write_BumpGenerationRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpGenerationRequest -> IO ()
write_BumpGenerationRequest oprot record = Thrift.writeVal oprot $ from_BumpGenerationRequest record
-- | Serialize a 'BumpGenerationRequest' in pure code
encode_BumpGenerationRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpGenerationRequest -> BS.ByteString
encode_BumpGenerationRequest oprot record = Thrift.serializeVal oprot $ from_BumpGenerationRequest record
-- | Translate a 'Types.ThriftVal' to a 'BumpGenerationRequest'
to_BumpGenerationRequest :: Types.ThriftVal -> BumpGenerationRequest
to_BumpGenerationRequest (Types.TStruct fields) = BumpGenerationRequest{
  bumpGenerationRequest_node_filters = maybe (bumpGenerationRequest_node_filters default_BumpGenerationRequest) (\(_,_val134) -> (case _val134 of {Types.TList _ _val135 -> (Vector.fromList $ map (\_v136 -> (case _v136 of {Types.TStruct _val137 -> (Nodes_Types.to_NodesFilter (Types.TStruct _val137)); _ -> error "wrong type"})) _val135); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_BumpGenerationRequest _ = error "not a struct"
-- | Read a 'BumpGenerationRequest' struct with the given 'Thrift.Protocol'
read_BumpGenerationRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BumpGenerationRequest
read_BumpGenerationRequest iprot = to_BumpGenerationRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BumpGenerationRequest)
-- | Deserialize a 'BumpGenerationRequest' in pure code
decode_BumpGenerationRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BumpGenerationRequest
decode_BumpGenerationRequest iprot bs = to_BumpGenerationRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BumpGenerationRequest) bs
-- | 'TypeMap' for the 'BumpGenerationRequest' struct
typemap_BumpGenerationRequest :: Types.TypeMap
typemap_BumpGenerationRequest = Map.fromList [("node_filters",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodesFilter))))]
-- | Default values for the 'BumpGenerationRequest' struct
default_BumpGenerationRequest :: BumpGenerationRequest
default_BumpGenerationRequest = BumpGenerationRequest{
  bumpGenerationRequest_node_filters = Vector.empty}
-- | Definition of the BumpGenerationResponse struct
data BumpGenerationResponse = BumpGenerationResponse
  { bumpGenerationResponse_bumped_nodes :: (Vector.Vector Common_Types.NodeID)
    -- ^ bumped_nodes field of the BumpGenerationResponse struct
  , bumpGenerationResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the BumpGenerationResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BumpGenerationResponse where
  encode = encode_BumpGenerationResponse
  decode = decode_BumpGenerationResponse
instance Hashable.Hashable BumpGenerationResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bumpGenerationResponse_bumped_nodes record   `Hashable.hashWithSalt` bumpGenerationResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData BumpGenerationResponse where
  rnf _record138 =
    DeepSeq.rnf (bumpGenerationResponse_bumped_nodes _record138) `seq`
    DeepSeq.rnf (bumpGenerationResponse_new_nodes_configuration_version _record138) `seq`
    ()
instance Arbitrary.Arbitrary BumpGenerationResponse where 
  arbitrary = Monad.liftM BumpGenerationResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_BumpGenerationResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BumpGenerationResponse{bumpGenerationResponse_bumped_nodes = bumpGenerationResponse_bumped_nodes obj} then Nothing else Just $ default_BumpGenerationResponse{bumpGenerationResponse_bumped_nodes = bumpGenerationResponse_bumped_nodes obj}
    , if obj == default_BumpGenerationResponse{bumpGenerationResponse_new_nodes_configuration_version = bumpGenerationResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_BumpGenerationResponse{bumpGenerationResponse_new_nodes_configuration_version = bumpGenerationResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'BumpGenerationResponse' to a 'Types.ThriftVal'
from_BumpGenerationResponse :: BumpGenerationResponse -> Types.ThriftVal
from_BumpGenerationResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v141 -> Just (1, ("bumped_nodes",Types.TList (Types.T_STRUCT Common_Types.typemap_NodeID) $ map (\_v143 -> Common_Types.from_NodeID _v143) $ Vector.toList _v141))) $ bumpGenerationResponse_bumped_nodes record
  , (\_v141 -> Just (2, ("new_nodes_configuration_version",Types.TI64 _v141))) $ bumpGenerationResponse_new_nodes_configuration_version record
  ]
-- | Write a 'BumpGenerationResponse' with the given 'Thrift.Protocol'
write_BumpGenerationResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpGenerationResponse -> IO ()
write_BumpGenerationResponse oprot record = Thrift.writeVal oprot $ from_BumpGenerationResponse record
-- | Serialize a 'BumpGenerationResponse' in pure code
encode_BumpGenerationResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpGenerationResponse -> BS.ByteString
encode_BumpGenerationResponse oprot record = Thrift.serializeVal oprot $ from_BumpGenerationResponse record
-- | Translate a 'Types.ThriftVal' to a 'BumpGenerationResponse'
to_BumpGenerationResponse :: Types.ThriftVal -> BumpGenerationResponse
to_BumpGenerationResponse (Types.TStruct fields) = BumpGenerationResponse{
  bumpGenerationResponse_bumped_nodes = maybe (bumpGenerationResponse_bumped_nodes default_BumpGenerationResponse) (\(_,_val145) -> (case _val145 of {Types.TList _ _val146 -> (Vector.fromList $ map (\_v147 -> (case _v147 of {Types.TStruct _val148 -> (Common_Types.to_NodeID (Types.TStruct _val148)); _ -> error "wrong type"})) _val146); _ -> error "wrong type"})) (Map.lookup (1) fields),
  bumpGenerationResponse_new_nodes_configuration_version = maybe (bumpGenerationResponse_new_nodes_configuration_version default_BumpGenerationResponse) (\(_,_val145) -> (case _val145 of {Types.TI64 _val149 -> _val149; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_BumpGenerationResponse _ = error "not a struct"
-- | Read a 'BumpGenerationResponse' struct with the given 'Thrift.Protocol'
read_BumpGenerationResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BumpGenerationResponse
read_BumpGenerationResponse iprot = to_BumpGenerationResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BumpGenerationResponse)
-- | Deserialize a 'BumpGenerationResponse' in pure code
decode_BumpGenerationResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BumpGenerationResponse
decode_BumpGenerationResponse iprot bs = to_BumpGenerationResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BumpGenerationResponse) bs
-- | 'TypeMap' for the 'BumpGenerationResponse' struct
typemap_BumpGenerationResponse :: Types.TypeMap
typemap_BumpGenerationResponse = Map.fromList [("bumped_nodes",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_NodeID)))),("new_nodes_configuration_version",(2,Types.T_I64))]
-- | Default values for the 'BumpGenerationResponse' struct
default_BumpGenerationResponse :: BumpGenerationResponse
default_BumpGenerationResponse = BumpGenerationResponse{
  bumpGenerationResponse_bumped_nodes = Vector.empty,
  bumpGenerationResponse_new_nodes_configuration_version = 0}
-- | Definition of the BootstrapClusterRequest struct
data BootstrapClusterRequest = BootstrapClusterRequest
  { bootstrapClusterRequest_metadata_replication_property :: (Map.HashMap Common_Types.LocationScope Int.Int32)
    -- ^ metadata_replication_property field of the BootstrapClusterRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BootstrapClusterRequest where
  encode = encode_BootstrapClusterRequest
  decode = decode_BootstrapClusterRequest
instance Hashable.Hashable BootstrapClusterRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bootstrapClusterRequest_metadata_replication_property record  
instance DeepSeq.NFData BootstrapClusterRequest where
  rnf _record150 =
    DeepSeq.rnf (bootstrapClusterRequest_metadata_replication_property _record150) `seq`
    ()
instance Arbitrary.Arbitrary BootstrapClusterRequest where 
  arbitrary = Monad.liftM BootstrapClusterRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_BootstrapClusterRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BootstrapClusterRequest{bootstrapClusterRequest_metadata_replication_property = bootstrapClusterRequest_metadata_replication_property obj} then Nothing else Just $ default_BootstrapClusterRequest{bootstrapClusterRequest_metadata_replication_property = bootstrapClusterRequest_metadata_replication_property obj}
    ]
-- | Translate a 'BootstrapClusterRequest' to a 'Types.ThriftVal'
from_BootstrapClusterRequest :: BootstrapClusterRequest -> Types.ThriftVal
from_BootstrapClusterRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v153 -> Just (1, ("metadata_replication_property",Types.TMap Types.T_I32 Types.T_I32 $ map (\(_k154,_v155) -> (Types.TI32 $ fromIntegral $ fromEnum _k154, Types.TI32 _v155)) $ Map.toList _v153))) $ bootstrapClusterRequest_metadata_replication_property record
  ]
-- | Write a 'BootstrapClusterRequest' with the given 'Thrift.Protocol'
write_BootstrapClusterRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapClusterRequest -> IO ()
write_BootstrapClusterRequest oprot record = Thrift.writeVal oprot $ from_BootstrapClusterRequest record
-- | Serialize a 'BootstrapClusterRequest' in pure code
encode_BootstrapClusterRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapClusterRequest -> BS.ByteString
encode_BootstrapClusterRequest oprot record = Thrift.serializeVal oprot $ from_BootstrapClusterRequest record
-- | Translate a 'Types.ThriftVal' to a 'BootstrapClusterRequest'
to_BootstrapClusterRequest :: Types.ThriftVal -> BootstrapClusterRequest
to_BootstrapClusterRequest (Types.TStruct fields) = BootstrapClusterRequest{
  bootstrapClusterRequest_metadata_replication_property = maybe (bootstrapClusterRequest_metadata_replication_property default_BootstrapClusterRequest) (\(_,_val157) -> (case _val157 of {Types.TMap _ _ _val158 -> (Map.fromList $ map (\(_k160,_v159) -> ((case _k160 of {Types.TI32 _val161 -> toEnum $ fromIntegral _val161; _ -> error "wrong type"}),(case _v159 of {Types.TI32 _val162 -> _val162; _ -> error "wrong type"}))) _val158); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_BootstrapClusterRequest _ = error "not a struct"
-- | Read a 'BootstrapClusterRequest' struct with the given 'Thrift.Protocol'
read_BootstrapClusterRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BootstrapClusterRequest
read_BootstrapClusterRequest iprot = to_BootstrapClusterRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BootstrapClusterRequest)
-- | Deserialize a 'BootstrapClusterRequest' in pure code
decode_BootstrapClusterRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BootstrapClusterRequest
decode_BootstrapClusterRequest iprot bs = to_BootstrapClusterRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BootstrapClusterRequest) bs
-- | 'TypeMap' for the 'BootstrapClusterRequest' struct
typemap_BootstrapClusterRequest :: Types.TypeMap
typemap_BootstrapClusterRequest = Map.fromList [("metadata_replication_property",(1,(Types.T_MAP Types.T_I32 Types.T_I32)))]
-- | Default values for the 'BootstrapClusterRequest' struct
default_BootstrapClusterRequest :: BootstrapClusterRequest
default_BootstrapClusterRequest = BootstrapClusterRequest{
  bootstrapClusterRequest_metadata_replication_property = Map.empty}
-- | Definition of the BootstrapClusterResponse struct
data BootstrapClusterResponse = BootstrapClusterResponse
  { bootstrapClusterResponse_new_nodes_configuration_version :: Int.Int64
    -- ^ new_nodes_configuration_version field of the BootstrapClusterResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BootstrapClusterResponse where
  encode = encode_BootstrapClusterResponse
  decode = decode_BootstrapClusterResponse
instance Hashable.Hashable BootstrapClusterResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bootstrapClusterResponse_new_nodes_configuration_version record  
instance DeepSeq.NFData BootstrapClusterResponse where
  rnf _record163 =
    DeepSeq.rnf (bootstrapClusterResponse_new_nodes_configuration_version _record163) `seq`
    ()
instance Arbitrary.Arbitrary BootstrapClusterResponse where 
  arbitrary = Monad.liftM BootstrapClusterResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_BootstrapClusterResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BootstrapClusterResponse{bootstrapClusterResponse_new_nodes_configuration_version = bootstrapClusterResponse_new_nodes_configuration_version obj} then Nothing else Just $ default_BootstrapClusterResponse{bootstrapClusterResponse_new_nodes_configuration_version = bootstrapClusterResponse_new_nodes_configuration_version obj}
    ]
-- | Translate a 'BootstrapClusterResponse' to a 'Types.ThriftVal'
from_BootstrapClusterResponse :: BootstrapClusterResponse -> Types.ThriftVal
from_BootstrapClusterResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v166 -> Just (1, ("new_nodes_configuration_version",Types.TI64 _v166))) $ bootstrapClusterResponse_new_nodes_configuration_version record
  ]
-- | Write a 'BootstrapClusterResponse' with the given 'Thrift.Protocol'
write_BootstrapClusterResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapClusterResponse -> IO ()
write_BootstrapClusterResponse oprot record = Thrift.writeVal oprot $ from_BootstrapClusterResponse record
-- | Serialize a 'BootstrapClusterResponse' in pure code
encode_BootstrapClusterResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapClusterResponse -> BS.ByteString
encode_BootstrapClusterResponse oprot record = Thrift.serializeVal oprot $ from_BootstrapClusterResponse record
-- | Translate a 'Types.ThriftVal' to a 'BootstrapClusterResponse'
to_BootstrapClusterResponse :: Types.ThriftVal -> BootstrapClusterResponse
to_BootstrapClusterResponse (Types.TStruct fields) = BootstrapClusterResponse{
  bootstrapClusterResponse_new_nodes_configuration_version = maybe (bootstrapClusterResponse_new_nodes_configuration_version default_BootstrapClusterResponse) (\(_,_val168) -> (case _val168 of {Types.TI64 _val169 -> _val169; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_BootstrapClusterResponse _ = error "not a struct"
-- | Read a 'BootstrapClusterResponse' struct with the given 'Thrift.Protocol'
read_BootstrapClusterResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BootstrapClusterResponse
read_BootstrapClusterResponse iprot = to_BootstrapClusterResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BootstrapClusterResponse)
-- | Deserialize a 'BootstrapClusterResponse' in pure code
decode_BootstrapClusterResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BootstrapClusterResponse
decode_BootstrapClusterResponse iprot bs = to_BootstrapClusterResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BootstrapClusterResponse) bs
-- | 'TypeMap' for the 'BootstrapClusterResponse' struct
typemap_BootstrapClusterResponse :: Types.TypeMap
typemap_BootstrapClusterResponse = Map.fromList [("new_nodes_configuration_version",(1,Types.T_I64))]
-- | Default values for the 'BootstrapClusterResponse' struct
default_BootstrapClusterResponse :: BootstrapClusterResponse
default_BootstrapClusterResponse = BootstrapClusterResponse{
  bootstrapClusterResponse_new_nodes_configuration_version = 0}

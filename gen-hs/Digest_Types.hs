{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Digest_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Fb303_Types as Fb303_Types


-- | Definition of the LogTag struct
data LogTag = LogTag
  { logTag_lsn :: Int.Int64
    -- ^ lsn field of the LogTag struct
  , logTag_storage_time_ms :: Int.Int64
    -- ^ storage_time_ms field of the LogTag struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogTag where
  encode = encode_LogTag
  decode = decode_LogTag
instance Hashable.Hashable LogTag where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logTag_lsn record   `Hashable.hashWithSalt` logTag_storage_time_ms record  
instance DeepSeq.NFData LogTag where
  rnf _record0 =
    DeepSeq.rnf (logTag_lsn _record0) `seq`
    DeepSeq.rnf (logTag_storage_time_ms _record0) `seq`
    ()
instance Arbitrary.Arbitrary LogTag where 
  arbitrary = Monad.liftM LogTag (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogTag = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogTag{logTag_lsn = logTag_lsn obj} then Nothing else Just $ default_LogTag{logTag_lsn = logTag_lsn obj}
    , if obj == default_LogTag{logTag_storage_time_ms = logTag_storage_time_ms obj} then Nothing else Just $ default_LogTag{logTag_storage_time_ms = logTag_storage_time_ms obj}
    ]
-- | Translate a 'LogTag' to a 'Types.ThriftVal'
from_LogTag :: LogTag -> Types.ThriftVal
from_LogTag record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("lsn",Types.TI64 _v3))) $ logTag_lsn record
  , (\_v3 -> Just (2, ("storage_time_ms",Types.TI64 _v3))) $ logTag_storage_time_ms record
  ]
-- | Write a 'LogTag' with the given 'Thrift.Protocol'
write_LogTag :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogTag -> IO ()
write_LogTag oprot record = Thrift.writeVal oprot $ from_LogTag record
-- | Serialize a 'LogTag' in pure code
encode_LogTag :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogTag -> BS.ByteString
encode_LogTag oprot record = Thrift.serializeVal oprot $ from_LogTag record
-- | Translate a 'Types.ThriftVal' to a 'LogTag'
to_LogTag :: Types.ThriftVal -> LogTag
to_LogTag (Types.TStruct fields) = LogTag{
  logTag_lsn = maybe (logTag_lsn default_LogTag) (\(_,_val5) -> (case _val5 of {Types.TI64 _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logTag_storage_time_ms = maybe (logTag_storage_time_ms default_LogTag) (\(_,_val5) -> (case _val5 of {Types.TI64 _val7 -> _val7; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_LogTag _ = error "not a struct"
-- | Read a 'LogTag' struct with the given 'Thrift.Protocol'
read_LogTag :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogTag
read_LogTag iprot = to_LogTag <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogTag)
-- | Deserialize a 'LogTag' in pure code
decode_LogTag :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogTag
decode_LogTag iprot bs = to_LogTag $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogTag) bs
-- | 'TypeMap' for the 'LogTag' struct
typemap_LogTag :: Types.TypeMap
typemap_LogTag = Map.fromList [("lsn",(1,Types.T_I64)),("storage_time_ms",(2,Types.T_I64))]
-- | Default values for the 'LogTag' struct
default_LogTag :: LogTag
default_LogTag = LogTag{
  logTag_lsn = 0,
  logTag_storage_time_ms = 0}
-- | Definition of the QueryRequest struct
data QueryRequest = QueryRequest
  { queryRequest_log_id :: Int.Int64
    -- ^ log_id field of the QueryRequest struct
  , queryRequest_start_tag :: Maybe Digest_Types.LogTag
    -- ^ start_tag field of the QueryRequest struct
  , queryRequest_end_tag :: Maybe Digest_Types.LogTag
    -- ^ end_tag field of the QueryRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable QueryRequest where
  encode = encode_QueryRequest
  decode = decode_QueryRequest
instance Hashable.Hashable QueryRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` queryRequest_log_id record   `Hashable.hashWithSalt` queryRequest_start_tag record   `Hashable.hashWithSalt` queryRequest_end_tag record  
instance DeepSeq.NFData QueryRequest where
  rnf _record8 =
    DeepSeq.rnf (queryRequest_log_id _record8) `seq`
    DeepSeq.rnf (queryRequest_start_tag _record8) `seq`
    DeepSeq.rnf (queryRequest_end_tag _record8) `seq`
    ()
instance Arbitrary.Arbitrary QueryRequest where 
  arbitrary = Monad.liftM QueryRequest (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_QueryRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_QueryRequest{queryRequest_log_id = queryRequest_log_id obj} then Nothing else Just $ default_QueryRequest{queryRequest_log_id = queryRequest_log_id obj}
    , if obj == default_QueryRequest{queryRequest_start_tag = queryRequest_start_tag obj} then Nothing else Just $ default_QueryRequest{queryRequest_start_tag = queryRequest_start_tag obj}
    , if obj == default_QueryRequest{queryRequest_end_tag = queryRequest_end_tag obj} then Nothing else Just $ default_QueryRequest{queryRequest_end_tag = queryRequest_end_tag obj}
    ]
-- | Translate a 'QueryRequest' to a 'Types.ThriftVal'
from_QueryRequest :: QueryRequest -> Types.ThriftVal
from_QueryRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v11 -> Just (1, ("log_id",Types.TI64 _v11))) $ queryRequest_log_id record
  , (\_v11 -> (2, ("start_tag",Digest_Types.from_LogTag _v11))) <$> queryRequest_start_tag record
  , (\_v11 -> (3, ("end_tag",Digest_Types.from_LogTag _v11))) <$> queryRequest_end_tag record
  ]
-- | Write a 'QueryRequest' with the given 'Thrift.Protocol'
write_QueryRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryRequest -> IO ()
write_QueryRequest oprot record = Thrift.writeVal oprot $ from_QueryRequest record
-- | Serialize a 'QueryRequest' in pure code
encode_QueryRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryRequest -> BS.ByteString
encode_QueryRequest oprot record = Thrift.serializeVal oprot $ from_QueryRequest record
-- | Translate a 'Types.ThriftVal' to a 'QueryRequest'
to_QueryRequest :: Types.ThriftVal -> QueryRequest
to_QueryRequest (Types.TStruct fields) = QueryRequest{
  queryRequest_log_id = maybe (queryRequest_log_id default_QueryRequest) (\(_,_val13) -> (case _val13 of {Types.TI64 _val14 -> _val14; _ -> error "wrong type"})) (Map.lookup (1) fields),
  queryRequest_start_tag = maybe (Nothing) (\(_,_val13) -> Just (case _val13 of {Types.TStruct _val15 -> (Digest_Types.to_LogTag (Types.TStruct _val15)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  queryRequest_end_tag = maybe (Nothing) (\(_,_val13) -> Just (case _val13 of {Types.TStruct _val16 -> (Digest_Types.to_LogTag (Types.TStruct _val16)); _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_QueryRequest _ = error "not a struct"
-- | Read a 'QueryRequest' struct with the given 'Thrift.Protocol'
read_QueryRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO QueryRequest
read_QueryRequest iprot = to_QueryRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_QueryRequest)
-- | Deserialize a 'QueryRequest' in pure code
decode_QueryRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> QueryRequest
decode_QueryRequest iprot bs = to_QueryRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_QueryRequest) bs
-- | 'TypeMap' for the 'QueryRequest' struct
typemap_QueryRequest :: Types.TypeMap
typemap_QueryRequest = Map.fromList [("log_id",(1,Types.T_I64)),("start_tag",(2,(Types.T_STRUCT Digest_Types.typemap_LogTag))),("end_tag",(3,(Types.T_STRUCT Digest_Types.typemap_LogTag)))]
-- | Default values for the 'QueryRequest' struct
default_QueryRequest :: QueryRequest
default_QueryRequest = QueryRequest{
  queryRequest_log_id = 0,
  queryRequest_start_tag = Nothing,
  queryRequest_end_tag = Nothing}
-- | Definition of the SubscribeRequest struct
data SubscribeRequest = SubscribeRequest
  { subscribeRequest_log_id :: Int.Int64
    -- ^ log_id field of the SubscribeRequest struct
  , subscribeRequest_start_tag :: Maybe Digest_Types.LogTag
    -- ^ start_tag field of the SubscribeRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SubscribeRequest where
  encode = encode_SubscribeRequest
  decode = decode_SubscribeRequest
instance Hashable.Hashable SubscribeRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` subscribeRequest_log_id record   `Hashable.hashWithSalt` subscribeRequest_start_tag record  
instance DeepSeq.NFData SubscribeRequest where
  rnf _record17 =
    DeepSeq.rnf (subscribeRequest_log_id _record17) `seq`
    DeepSeq.rnf (subscribeRequest_start_tag _record17) `seq`
    ()
instance Arbitrary.Arbitrary SubscribeRequest where 
  arbitrary = Monad.liftM SubscribeRequest (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_SubscribeRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SubscribeRequest{subscribeRequest_log_id = subscribeRequest_log_id obj} then Nothing else Just $ default_SubscribeRequest{subscribeRequest_log_id = subscribeRequest_log_id obj}
    , if obj == default_SubscribeRequest{subscribeRequest_start_tag = subscribeRequest_start_tag obj} then Nothing else Just $ default_SubscribeRequest{subscribeRequest_start_tag = subscribeRequest_start_tag obj}
    ]
-- | Translate a 'SubscribeRequest' to a 'Types.ThriftVal'
from_SubscribeRequest :: SubscribeRequest -> Types.ThriftVal
from_SubscribeRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v20 -> Just (1, ("log_id",Types.TI64 _v20))) $ subscribeRequest_log_id record
  , (\_v20 -> (2, ("start_tag",Digest_Types.from_LogTag _v20))) <$> subscribeRequest_start_tag record
  ]
-- | Write a 'SubscribeRequest' with the given 'Thrift.Protocol'
write_SubscribeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeRequest -> IO ()
write_SubscribeRequest oprot record = Thrift.writeVal oprot $ from_SubscribeRequest record
-- | Serialize a 'SubscribeRequest' in pure code
encode_SubscribeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeRequest -> BS.ByteString
encode_SubscribeRequest oprot record = Thrift.serializeVal oprot $ from_SubscribeRequest record
-- | Translate a 'Types.ThriftVal' to a 'SubscribeRequest'
to_SubscribeRequest :: Types.ThriftVal -> SubscribeRequest
to_SubscribeRequest (Types.TStruct fields) = SubscribeRequest{
  subscribeRequest_log_id = maybe (subscribeRequest_log_id default_SubscribeRequest) (\(_,_val22) -> (case _val22 of {Types.TI64 _val23 -> _val23; _ -> error "wrong type"})) (Map.lookup (1) fields),
  subscribeRequest_start_tag = maybe (Nothing) (\(_,_val22) -> Just (case _val22 of {Types.TStruct _val24 -> (Digest_Types.to_LogTag (Types.TStruct _val24)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_SubscribeRequest _ = error "not a struct"
-- | Read a 'SubscribeRequest' struct with the given 'Thrift.Protocol'
read_SubscribeRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SubscribeRequest
read_SubscribeRequest iprot = to_SubscribeRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SubscribeRequest)
-- | Deserialize a 'SubscribeRequest' in pure code
decode_SubscribeRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SubscribeRequest
decode_SubscribeRequest iprot bs = to_SubscribeRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SubscribeRequest) bs
-- | 'TypeMap' for the 'SubscribeRequest' struct
typemap_SubscribeRequest :: Types.TypeMap
typemap_SubscribeRequest = Map.fromList [("log_id",(1,Types.T_I64)),("start_tag",(2,(Types.T_STRUCT Digest_Types.typemap_LogTag)))]
-- | Default values for the 'SubscribeRequest' struct
default_SubscribeRequest :: SubscribeRequest
default_SubscribeRequest = SubscribeRequest{
  subscribeRequest_log_id = 0,
  subscribeRequest_start_tag = Nothing}
-- | Definition of the DigestFragment struct
data DigestFragment = DigestFragment
  { digestFragment_log_id :: Int.Int64
    -- ^ log_id field of the DigestFragment struct
  , digestFragment_lsns :: (Vector.Vector Int.Int64)
    -- ^ lsns field of the DigestFragment struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable DigestFragment where
  encode = encode_DigestFragment
  decode = decode_DigestFragment
instance Hashable.Hashable DigestFragment where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` digestFragment_log_id record   `Hashable.hashWithSalt` digestFragment_lsns record  
instance DeepSeq.NFData DigestFragment where
  rnf _record25 =
    DeepSeq.rnf (digestFragment_log_id _record25) `seq`
    DeepSeq.rnf (digestFragment_lsns _record25) `seq`
    ()
instance Arbitrary.Arbitrary DigestFragment where 
  arbitrary = Monad.liftM DigestFragment (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_DigestFragment = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_DigestFragment{digestFragment_log_id = digestFragment_log_id obj} then Nothing else Just $ default_DigestFragment{digestFragment_log_id = digestFragment_log_id obj}
    , if obj == default_DigestFragment{digestFragment_lsns = digestFragment_lsns obj} then Nothing else Just $ default_DigestFragment{digestFragment_lsns = digestFragment_lsns obj}
    ]
-- | Translate a 'DigestFragment' to a 'Types.ThriftVal'
from_DigestFragment :: DigestFragment -> Types.ThriftVal
from_DigestFragment record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v28 -> Just (1, ("log_id",Types.TI64 _v28))) $ digestFragment_log_id record
  , (\_v28 -> Just (2, ("lsns",Types.TList Types.T_I64 $ map (\_v30 -> Types.TI64 _v30) $ Vector.toList _v28))) $ digestFragment_lsns record
  ]
-- | Write a 'DigestFragment' with the given 'Thrift.Protocol'
write_DigestFragment :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DigestFragment -> IO ()
write_DigestFragment oprot record = Thrift.writeVal oprot $ from_DigestFragment record
-- | Serialize a 'DigestFragment' in pure code
encode_DigestFragment :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DigestFragment -> BS.ByteString
encode_DigestFragment oprot record = Thrift.serializeVal oprot $ from_DigestFragment record
-- | Translate a 'Types.ThriftVal' to a 'DigestFragment'
to_DigestFragment :: Types.ThriftVal -> DigestFragment
to_DigestFragment (Types.TStruct fields) = DigestFragment{
  digestFragment_log_id = maybe (digestFragment_log_id default_DigestFragment) (\(_,_val32) -> (case _val32 of {Types.TI64 _val33 -> _val33; _ -> error "wrong type"})) (Map.lookup (1) fields),
  digestFragment_lsns = maybe (digestFragment_lsns default_DigestFragment) (\(_,_val32) -> (case _val32 of {Types.TList _ _val34 -> (Vector.fromList $ map (\_v35 -> (case _v35 of {Types.TI64 _val36 -> _val36; _ -> error "wrong type"})) _val34); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_DigestFragment _ = error "not a struct"
-- | Read a 'DigestFragment' struct with the given 'Thrift.Protocol'
read_DigestFragment :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO DigestFragment
read_DigestFragment iprot = to_DigestFragment <$> Thrift.readVal iprot (Types.T_STRUCT typemap_DigestFragment)
-- | Deserialize a 'DigestFragment' in pure code
decode_DigestFragment :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> DigestFragment
decode_DigestFragment iprot bs = to_DigestFragment $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_DigestFragment) bs
-- | 'TypeMap' for the 'DigestFragment' struct
typemap_DigestFragment :: Types.TypeMap
typemap_DigestFragment = Map.fromList [("log_id",(1,Types.T_I64)),("lsns",(2,(Types.T_LIST Types.T_I64)))]
-- | Default values for the 'DigestFragment' struct
default_DigestFragment :: DigestFragment
default_DigestFragment = DigestFragment{
  digestFragment_log_id = 0,
  digestFragment_lsns = Vector.empty}
-- | Definition of the QueryResponse struct
data QueryResponse = QueryResponse
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable QueryResponse where
  encode = encode_QueryResponse
  decode = decode_QueryResponse
instance Hashable.Hashable QueryResponse where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData QueryResponse where
  rnf _record37 =
    ()
instance Arbitrary.Arbitrary QueryResponse where 
  arbitrary = QuickCheck.elements [QueryResponse]
-- | Translate a 'QueryResponse' to a 'Types.ThriftVal'
from_QueryResponse :: QueryResponse -> Types.ThriftVal
from_QueryResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'QueryResponse' with the given 'Thrift.Protocol'
write_QueryResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryResponse -> IO ()
write_QueryResponse oprot record = Thrift.writeVal oprot $ from_QueryResponse record
-- | Serialize a 'QueryResponse' in pure code
encode_QueryResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryResponse -> BS.ByteString
encode_QueryResponse oprot record = Thrift.serializeVal oprot $ from_QueryResponse record
-- | Translate a 'Types.ThriftVal' to a 'QueryResponse'
to_QueryResponse :: Types.ThriftVal -> QueryResponse
to_QueryResponse (Types.TStruct fields) = QueryResponse{

  }
to_QueryResponse _ = error "not a struct"
-- | Read a 'QueryResponse' struct with the given 'Thrift.Protocol'
read_QueryResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO QueryResponse
read_QueryResponse iprot = to_QueryResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_QueryResponse)
-- | Deserialize a 'QueryResponse' in pure code
decode_QueryResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> QueryResponse
decode_QueryResponse iprot bs = to_QueryResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_QueryResponse) bs
-- | 'TypeMap' for the 'QueryResponse' struct
typemap_QueryResponse :: Types.TypeMap
typemap_QueryResponse = Map.fromList []
-- | Default values for the 'QueryResponse' struct
default_QueryResponse :: QueryResponse
default_QueryResponse = QueryResponse{
}
-- | Definition of the QueryStreamResponse struct
data QueryStreamResponse = QueryStreamResponse
  { queryStreamResponse_fragment :: Digest_Types.DigestFragment
    -- ^ fragment field of the QueryStreamResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable QueryStreamResponse where
  encode = encode_QueryStreamResponse
  decode = decode_QueryStreamResponse
instance Hashable.Hashable QueryStreamResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` queryStreamResponse_fragment record  
instance DeepSeq.NFData QueryStreamResponse where
  rnf _record43 =
    DeepSeq.rnf (queryStreamResponse_fragment _record43) `seq`
    ()
instance Arbitrary.Arbitrary QueryStreamResponse where 
  arbitrary = Monad.liftM QueryStreamResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_QueryStreamResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_QueryStreamResponse{queryStreamResponse_fragment = queryStreamResponse_fragment obj} then Nothing else Just $ default_QueryStreamResponse{queryStreamResponse_fragment = queryStreamResponse_fragment obj}
    ]
-- | Translate a 'QueryStreamResponse' to a 'Types.ThriftVal'
from_QueryStreamResponse :: QueryStreamResponse -> Types.ThriftVal
from_QueryStreamResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v46 -> Just (1, ("fragment",Digest_Types.from_DigestFragment _v46))) $ queryStreamResponse_fragment record
  ]
-- | Write a 'QueryStreamResponse' with the given 'Thrift.Protocol'
write_QueryStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryStreamResponse -> IO ()
write_QueryStreamResponse oprot record = Thrift.writeVal oprot $ from_QueryStreamResponse record
-- | Serialize a 'QueryStreamResponse' in pure code
encode_QueryStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> QueryStreamResponse -> BS.ByteString
encode_QueryStreamResponse oprot record = Thrift.serializeVal oprot $ from_QueryStreamResponse record
-- | Translate a 'Types.ThriftVal' to a 'QueryStreamResponse'
to_QueryStreamResponse :: Types.ThriftVal -> QueryStreamResponse
to_QueryStreamResponse (Types.TStruct fields) = QueryStreamResponse{
  queryStreamResponse_fragment = maybe (queryStreamResponse_fragment default_QueryStreamResponse) (\(_,_val48) -> (case _val48 of {Types.TStruct _val49 -> (Digest_Types.to_DigestFragment (Types.TStruct _val49)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_QueryStreamResponse _ = error "not a struct"
-- | Read a 'QueryStreamResponse' struct with the given 'Thrift.Protocol'
read_QueryStreamResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO QueryStreamResponse
read_QueryStreamResponse iprot = to_QueryStreamResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_QueryStreamResponse)
-- | Deserialize a 'QueryStreamResponse' in pure code
decode_QueryStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> QueryStreamResponse
decode_QueryStreamResponse iprot bs = to_QueryStreamResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_QueryStreamResponse) bs
-- | 'TypeMap' for the 'QueryStreamResponse' struct
typemap_QueryStreamResponse :: Types.TypeMap
typemap_QueryStreamResponse = Map.fromList [("fragment",(1,(Types.T_STRUCT Digest_Types.typemap_DigestFragment)))]
-- | Default values for the 'QueryStreamResponse' struct
default_QueryStreamResponse :: QueryStreamResponse
default_QueryStreamResponse = QueryStreamResponse{
  queryStreamResponse_fragment = Digest_Types.default_DigestFragment}
-- | Definition of the SubscribeResponse struct
data SubscribeResponse = SubscribeResponse
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SubscribeResponse where
  encode = encode_SubscribeResponse
  decode = decode_SubscribeResponse
instance Hashable.Hashable SubscribeResponse where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData SubscribeResponse where
  rnf _record50 =
    ()
instance Arbitrary.Arbitrary SubscribeResponse where 
  arbitrary = QuickCheck.elements [SubscribeResponse]
-- | Translate a 'SubscribeResponse' to a 'Types.ThriftVal'
from_SubscribeResponse :: SubscribeResponse -> Types.ThriftVal
from_SubscribeResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'SubscribeResponse' with the given 'Thrift.Protocol'
write_SubscribeResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeResponse -> IO ()
write_SubscribeResponse oprot record = Thrift.writeVal oprot $ from_SubscribeResponse record
-- | Serialize a 'SubscribeResponse' in pure code
encode_SubscribeResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeResponse -> BS.ByteString
encode_SubscribeResponse oprot record = Thrift.serializeVal oprot $ from_SubscribeResponse record
-- | Translate a 'Types.ThriftVal' to a 'SubscribeResponse'
to_SubscribeResponse :: Types.ThriftVal -> SubscribeResponse
to_SubscribeResponse (Types.TStruct fields) = SubscribeResponse{

  }
to_SubscribeResponse _ = error "not a struct"
-- | Read a 'SubscribeResponse' struct with the given 'Thrift.Protocol'
read_SubscribeResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SubscribeResponse
read_SubscribeResponse iprot = to_SubscribeResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SubscribeResponse)
-- | Deserialize a 'SubscribeResponse' in pure code
decode_SubscribeResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SubscribeResponse
decode_SubscribeResponse iprot bs = to_SubscribeResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SubscribeResponse) bs
-- | 'TypeMap' for the 'SubscribeResponse' struct
typemap_SubscribeResponse :: Types.TypeMap
typemap_SubscribeResponse = Map.fromList []
-- | Default values for the 'SubscribeResponse' struct
default_SubscribeResponse :: SubscribeResponse
default_SubscribeResponse = SubscribeResponse{
}
-- | Definition of the SubscribeStreamResponse struct
data SubscribeStreamResponse = SubscribeStreamResponse
  { subscribeStreamResponse_fragment :: Digest_Types.DigestFragment
    -- ^ fragment field of the SubscribeStreamResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SubscribeStreamResponse where
  encode = encode_SubscribeStreamResponse
  decode = decode_SubscribeStreamResponse
instance Hashable.Hashable SubscribeStreamResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` subscribeStreamResponse_fragment record  
instance DeepSeq.NFData SubscribeStreamResponse where
  rnf _record56 =
    DeepSeq.rnf (subscribeStreamResponse_fragment _record56) `seq`
    ()
instance Arbitrary.Arbitrary SubscribeStreamResponse where 
  arbitrary = Monad.liftM SubscribeStreamResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_SubscribeStreamResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SubscribeStreamResponse{subscribeStreamResponse_fragment = subscribeStreamResponse_fragment obj} then Nothing else Just $ default_SubscribeStreamResponse{subscribeStreamResponse_fragment = subscribeStreamResponse_fragment obj}
    ]
-- | Translate a 'SubscribeStreamResponse' to a 'Types.ThriftVal'
from_SubscribeStreamResponse :: SubscribeStreamResponse -> Types.ThriftVal
from_SubscribeStreamResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v59 -> Just (1, ("fragment",Digest_Types.from_DigestFragment _v59))) $ subscribeStreamResponse_fragment record
  ]
-- | Write a 'SubscribeStreamResponse' with the given 'Thrift.Protocol'
write_SubscribeStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeStreamResponse -> IO ()
write_SubscribeStreamResponse oprot record = Thrift.writeVal oprot $ from_SubscribeStreamResponse record
-- | Serialize a 'SubscribeStreamResponse' in pure code
encode_SubscribeStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SubscribeStreamResponse -> BS.ByteString
encode_SubscribeStreamResponse oprot record = Thrift.serializeVal oprot $ from_SubscribeStreamResponse record
-- | Translate a 'Types.ThriftVal' to a 'SubscribeStreamResponse'
to_SubscribeStreamResponse :: Types.ThriftVal -> SubscribeStreamResponse
to_SubscribeStreamResponse (Types.TStruct fields) = SubscribeStreamResponse{
  subscribeStreamResponse_fragment = maybe (subscribeStreamResponse_fragment default_SubscribeStreamResponse) (\(_,_val61) -> (case _val61 of {Types.TStruct _val62 -> (Digest_Types.to_DigestFragment (Types.TStruct _val62)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_SubscribeStreamResponse _ = error "not a struct"
-- | Read a 'SubscribeStreamResponse' struct with the given 'Thrift.Protocol'
read_SubscribeStreamResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SubscribeStreamResponse
read_SubscribeStreamResponse iprot = to_SubscribeStreamResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SubscribeStreamResponse)
-- | Deserialize a 'SubscribeStreamResponse' in pure code
decode_SubscribeStreamResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SubscribeStreamResponse
decode_SubscribeStreamResponse iprot bs = to_SubscribeStreamResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SubscribeStreamResponse) bs
-- | 'TypeMap' for the 'SubscribeStreamResponse' struct
typemap_SubscribeStreamResponse :: Types.TypeMap
typemap_SubscribeStreamResponse = Map.fromList [("fragment",(1,(Types.T_STRUCT Digest_Types.typemap_DigestFragment)))]
-- | Default values for the 'SubscribeStreamResponse' struct
default_SubscribeStreamResponse :: SubscribeStreamResponse
default_SubscribeStreamResponse = SubscribeStreamResponse{
  subscribeStreamResponse_fragment = Digest_Types.default_DigestFragment}

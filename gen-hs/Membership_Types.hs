{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Membership_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries


data StorageState = NONE|NONE_TO_RO|READ_ONLY|READ_WRITE|RW_TO_RO|DATA_MIGRATION|PROVISIONING|INVALID  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum StorageState where
  fromEnum t = case t of
    NONE -> 0
    NONE_TO_RO -> 1
    READ_ONLY -> 2
    READ_WRITE -> 3
    RW_TO_RO -> 4
    DATA_MIGRATION -> 5
    PROVISIONING -> 7
    INVALID -> 6
  toEnum t = case t of
    0 -> NONE
    1 -> NONE_TO_RO
    2 -> READ_ONLY
    3 -> READ_WRITE
    4 -> RW_TO_RO
    5 -> DATA_MIGRATION
    7 -> PROVISIONING
    6 -> INVALID
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    NONE -> NONE_TO_RO
    NONE_TO_RO -> READ_ONLY
    READ_ONLY -> READ_WRITE
    READ_WRITE -> RW_TO_RO
    RW_TO_RO -> DATA_MIGRATION
    DATA_MIGRATION -> PROVISIONING
    PROVISIONING -> INVALID
    INVALID -> Exception.throw Thrift.ThriftException
  pred t = case t of
    NONE -> Exception.throw Thrift.ThriftException
    NONE_TO_RO -> NONE
    READ_ONLY -> NONE_TO_RO
    READ_WRITE -> READ_ONLY
    RW_TO_RO -> READ_WRITE
    DATA_MIGRATION -> RW_TO_RO
    PROVISIONING -> DATA_MIGRATION
    INVALID -> PROVISIONING
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable StorageState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData StorageState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary StorageState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data MetaDataStorageState = NONE|METADATA|PROMOTING|INVALID  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum MetaDataStorageState where
  fromEnum t = case t of
    NONE -> 0
    METADATA -> 1
    PROMOTING -> 2
    INVALID -> 3
  toEnum t = case t of
    0 -> NONE
    1 -> METADATA
    2 -> PROMOTING
    3 -> INVALID
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    NONE -> METADATA
    METADATA -> PROMOTING
    PROMOTING -> INVALID
    INVALID -> Exception.throw Thrift.ThriftException
  pred t = case t of
    NONE -> Exception.throw Thrift.ThriftException
    METADATA -> NONE
    PROMOTING -> METADATA
    INVALID -> PROMOTING
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable MetaDataStorageState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData MetaDataStorageState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary MetaDataStorageState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
type U8 = Int.Int8

type U16 = Int.Int16

type U32 = Int.Int32

type U64 = Int.Int64

type Node_idx = Int.Int16

type StorageNodeState = Map.HashMap Int.Int16 (Vector.Vector Membership_Types.ShardState)

-- | Definition of the ShardID struct
data ShardID = ShardID
  { shardID_node_idx :: Int.Int16
    -- ^ node_idx field of the ShardID struct
  , shardID_shard_idx :: Int.Int16
    -- ^ shard_idx field of the ShardID struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardID where
  encode = encode_ShardID
  decode = decode_ShardID
instance Hashable.Hashable ShardID where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardID_node_idx record   `Hashable.hashWithSalt` shardID_shard_idx record  
instance DeepSeq.NFData ShardID where
  rnf _record0 =
    DeepSeq.rnf (shardID_node_idx _record0) `seq`
    DeepSeq.rnf (shardID_shard_idx _record0) `seq`
    ()
instance Arbitrary.Arbitrary ShardID where 
  arbitrary = Monad.liftM ShardID (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardID = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardID{shardID_node_idx = shardID_node_idx obj} then Nothing else Just $ default_ShardID{shardID_node_idx = shardID_node_idx obj}
    , if obj == default_ShardID{shardID_shard_idx = shardID_shard_idx obj} then Nothing else Just $ default_ShardID{shardID_shard_idx = shardID_shard_idx obj}
    ]
-- | Translate a 'ShardID' to a 'Types.ThriftVal'
from_ShardID :: ShardID -> Types.ThriftVal
from_ShardID record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("node_idx",Types.TI16 _v3))) $ shardID_node_idx record
  , (\_v3 -> Just (2, ("shard_idx",Types.TI16 _v3))) $ shardID_shard_idx record
  ]
-- | Write a 'ShardID' with the given 'Thrift.Protocol'
write_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardID -> IO ()
write_ShardID oprot record = Thrift.writeVal oprot $ from_ShardID record
-- | Serialize a 'ShardID' in pure code
encode_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardID -> BS.ByteString
encode_ShardID oprot record = Thrift.serializeVal oprot $ from_ShardID record
-- | Translate a 'Types.ThriftVal' to a 'ShardID'
to_ShardID :: Types.ThriftVal -> ShardID
to_ShardID (Types.TStruct fields) = ShardID{
  shardID_node_idx = maybe (shardID_node_idx default_ShardID) (\(_,_val5) -> (case _val5 of {Types.TI16 _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardID_shard_idx = maybe (shardID_shard_idx default_ShardID) (\(_,_val5) -> (case _val5 of {Types.TI16 _val7 -> _val7; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_ShardID _ = error "not a struct"
-- | Read a 'ShardID' struct with the given 'Thrift.Protocol'
read_ShardID :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardID
read_ShardID iprot = to_ShardID <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardID)
-- | Deserialize a 'ShardID' in pure code
decode_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardID
decode_ShardID iprot bs = to_ShardID $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardID) bs
-- | 'TypeMap' for the 'ShardID' struct
typemap_ShardID :: Types.TypeMap
typemap_ShardID = Map.fromList [("node_idx",(1,Types.T_I16)),("shard_idx",(2,Types.T_I16))]
-- | Default values for the 'ShardID' struct
default_ShardID :: ShardID
default_ShardID = ShardID{
  shardID_node_idx = 0,
  shardID_shard_idx = 0}
-- | Definition of the ShardState struct
data ShardState = ShardState
  { shardState_shard_idx :: Int.Int16
    -- ^ shard_idx field of the ShardState struct
  , shardState_storage_state :: Membership_Types.StorageState
    -- ^ storage_state field of the ShardState struct
  , shardState_flags :: Int.Int32
    -- ^ flags field of the ShardState struct
  , shardState_metadata_state :: Membership_Types.MetaDataStorageState
    -- ^ metadata_state field of the ShardState struct
  , shardState_since_version :: Int.Int64
    -- ^ since_version field of the ShardState struct
  , shardState_manual_override :: Bool
    -- ^ manual_override field of the ShardState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardState where
  encode = encode_ShardState
  decode = decode_ShardState
instance Hashable.Hashable ShardState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardState_shard_idx record   `Hashable.hashWithSalt` shardState_storage_state record   `Hashable.hashWithSalt` shardState_flags record   `Hashable.hashWithSalt` shardState_metadata_state record   `Hashable.hashWithSalt` shardState_since_version record   `Hashable.hashWithSalt` shardState_manual_override record  
instance DeepSeq.NFData ShardState where
  rnf _record8 =
    DeepSeq.rnf (shardState_shard_idx _record8) `seq`
    DeepSeq.rnf (shardState_storage_state _record8) `seq`
    DeepSeq.rnf (shardState_flags _record8) `seq`
    DeepSeq.rnf (shardState_metadata_state _record8) `seq`
    DeepSeq.rnf (shardState_since_version _record8) `seq`
    DeepSeq.rnf (shardState_manual_override _record8) `seq`
    ()
instance Arbitrary.Arbitrary ShardState where 
  arbitrary = Monad.liftM ShardState (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardState{shardState_shard_idx = shardState_shard_idx obj} then Nothing else Just $ default_ShardState{shardState_shard_idx = shardState_shard_idx obj}
    , if obj == default_ShardState{shardState_storage_state = shardState_storage_state obj} then Nothing else Just $ default_ShardState{shardState_storage_state = shardState_storage_state obj}
    , if obj == default_ShardState{shardState_flags = shardState_flags obj} then Nothing else Just $ default_ShardState{shardState_flags = shardState_flags obj}
    , if obj == default_ShardState{shardState_metadata_state = shardState_metadata_state obj} then Nothing else Just $ default_ShardState{shardState_metadata_state = shardState_metadata_state obj}
    , if obj == default_ShardState{shardState_since_version = shardState_since_version obj} then Nothing else Just $ default_ShardState{shardState_since_version = shardState_since_version obj}
    , if obj == default_ShardState{shardState_manual_override = shardState_manual_override obj} then Nothing else Just $ default_ShardState{shardState_manual_override = shardState_manual_override obj}
    ]
-- | Translate a 'ShardState' to a 'Types.ThriftVal'
from_ShardState :: ShardState -> Types.ThriftVal
from_ShardState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v11 -> Just (1, ("shard_idx",Types.TI16 _v11))) $ shardState_shard_idx record
  , (\_v11 -> Just (2, ("storage_state",Types.TI32 $ fromIntegral $ fromEnum _v11))) $ shardState_storage_state record
  , (\_v11 -> Just (3, ("flags",Types.TI32 _v11))) $ shardState_flags record
  , (\_v11 -> Just (4, ("metadata_state",Types.TI32 $ fromIntegral $ fromEnum _v11))) $ shardState_metadata_state record
  , (\_v11 -> Just (6, ("since_version",Types.TI64 _v11))) $ shardState_since_version record
  , (\_v11 -> Just (7, ("manual_override",Types.TBool _v11))) $ shardState_manual_override record
  ]
-- | Write a 'ShardState' with the given 'Thrift.Protocol'
write_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardState -> IO ()
write_ShardState oprot record = Thrift.writeVal oprot $ from_ShardState record
-- | Serialize a 'ShardState' in pure code
encode_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardState -> BS.ByteString
encode_ShardState oprot record = Thrift.serializeVal oprot $ from_ShardState record
-- | Translate a 'Types.ThriftVal' to a 'ShardState'
to_ShardState :: Types.ThriftVal -> ShardState
to_ShardState (Types.TStruct fields) = ShardState{
  shardState_shard_idx = maybe (shardState_shard_idx default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TI16 _val14 -> _val14; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardState_storage_state = maybe (shardState_storage_state default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TI32 _val15 -> toEnum $ fromIntegral _val15; _ -> error "wrong type"})) (Map.lookup (2) fields),
  shardState_flags = maybe (shardState_flags default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TI32 _val16 -> _val16; _ -> error "wrong type"})) (Map.lookup (3) fields),
  shardState_metadata_state = maybe (shardState_metadata_state default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TI32 _val17 -> toEnum $ fromIntegral _val17; _ -> error "wrong type"})) (Map.lookup (4) fields),
  shardState_since_version = maybe (shardState_since_version default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TI64 _val18 -> _val18; _ -> error "wrong type"})) (Map.lookup (6) fields),
  shardState_manual_override = maybe (shardState_manual_override default_ShardState) (\(_,_val13) -> (case _val13 of {Types.TBool _val19 -> _val19; _ -> error "wrong type"})) (Map.lookup (7) fields)
  }
to_ShardState _ = error "not a struct"
-- | Read a 'ShardState' struct with the given 'Thrift.Protocol'
read_ShardState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardState
read_ShardState iprot = to_ShardState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardState)
-- | Deserialize a 'ShardState' in pure code
decode_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardState
decode_ShardState iprot bs = to_ShardState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardState) bs
-- | 'TypeMap' for the 'ShardState' struct
typemap_ShardState :: Types.TypeMap
typemap_ShardState = Map.fromList [("shard_idx",(1,Types.T_I16)),("storage_state",(2,Types.T_I32)),("flags",(3,Types.T_I32)),("metadata_state",(4,Types.T_I32)),("since_version",(6,Types.T_I64)),("manual_override",(7,Types.T_BOOL))]
-- | Default values for the 'ShardState' struct
default_ShardState :: ShardState
default_ShardState = ShardState{
  shardState_shard_idx = 0,
  shardState_storage_state = (toEnum 0),
  shardState_flags = 0,
  shardState_metadata_state = (toEnum 0),
  shardState_since_version = 0,
  shardState_manual_override = False}
-- | Definition of the StorageMembership struct
data StorageMembership = StorageMembership
  { storageMembership_proto_version :: Int.Int32
    -- ^ proto_version field of the StorageMembership struct
  , storageMembership_membership_version :: Int.Int64
    -- ^ membership_version field of the StorageMembership struct
  , storageMembership_node_states :: (Map.HashMap Int.Int16 (Vector.Vector Membership_Types.ShardState))
    -- ^ node_states field of the StorageMembership struct
  , storageMembership_metadata_shards :: (Vector.Vector Membership_Types.ShardID)
    -- ^ metadata_shards field of the StorageMembership struct
  , storageMembership_bootstrapping :: Bool
    -- ^ bootstrapping field of the StorageMembership struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable StorageMembership where
  encode = encode_StorageMembership
  decode = decode_StorageMembership
instance Hashable.Hashable StorageMembership where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` storageMembership_proto_version record   `Hashable.hashWithSalt` storageMembership_membership_version record   `Hashable.hashWithSalt` storageMembership_node_states record   `Hashable.hashWithSalt` storageMembership_metadata_shards record   `Hashable.hashWithSalt` storageMembership_bootstrapping record  
instance DeepSeq.NFData StorageMembership where
  rnf _record20 =
    DeepSeq.rnf (storageMembership_proto_version _record20) `seq`
    DeepSeq.rnf (storageMembership_membership_version _record20) `seq`
    DeepSeq.rnf (storageMembership_node_states _record20) `seq`
    DeepSeq.rnf (storageMembership_metadata_shards _record20) `seq`
    DeepSeq.rnf (storageMembership_bootstrapping _record20) `seq`
    ()
instance Arbitrary.Arbitrary StorageMembership where 
  arbitrary = Monad.liftM StorageMembership (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_StorageMembership = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_StorageMembership{storageMembership_proto_version = storageMembership_proto_version obj} then Nothing else Just $ default_StorageMembership{storageMembership_proto_version = storageMembership_proto_version obj}
    , if obj == default_StorageMembership{storageMembership_membership_version = storageMembership_membership_version obj} then Nothing else Just $ default_StorageMembership{storageMembership_membership_version = storageMembership_membership_version obj}
    , if obj == default_StorageMembership{storageMembership_node_states = storageMembership_node_states obj} then Nothing else Just $ default_StorageMembership{storageMembership_node_states = storageMembership_node_states obj}
    , if obj == default_StorageMembership{storageMembership_metadata_shards = storageMembership_metadata_shards obj} then Nothing else Just $ default_StorageMembership{storageMembership_metadata_shards = storageMembership_metadata_shards obj}
    , if obj == default_StorageMembership{storageMembership_bootstrapping = storageMembership_bootstrapping obj} then Nothing else Just $ default_StorageMembership{storageMembership_bootstrapping = storageMembership_bootstrapping obj}
    ]
-- | Translate a 'StorageMembership' to a 'Types.ThriftVal'
from_StorageMembership :: StorageMembership -> Types.ThriftVal
from_StorageMembership record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v23 -> Just (1, ("proto_version",Types.TI32 _v23))) $ storageMembership_proto_version record
  , (\_v23 -> Just (2, ("membership_version",Types.TI64 _v23))) $ storageMembership_membership_version record
  , (\_v23 -> Just (3, ("node_states",Types.TMap Types.T_I16 (Types.T_LIST (Types.T_STRUCT Membership_Types.typemap_ShardState)) $ map (\(_k24,_v25) -> (Types.TI16 _k24, Types.TList (Types.T_STRUCT Membership_Types.typemap_ShardState) $ map (\_v27 -> Membership_Types.from_ShardState _v27) $ Vector.toList _v25)) $ Map.toList _v23))) $ storageMembership_node_states record
  , (\_v23 -> Just (4, ("metadata_shards",Types.TList (Types.T_STRUCT Membership_Types.typemap_ShardID) $ map (\_v29 -> Membership_Types.from_ShardID _v29) $ Vector.toList _v23))) $ storageMembership_metadata_shards record
  , (\_v23 -> Just (5, ("bootstrapping",Types.TBool _v23))) $ storageMembership_bootstrapping record
  ]
-- | Write a 'StorageMembership' with the given 'Thrift.Protocol'
write_StorageMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> StorageMembership -> IO ()
write_StorageMembership oprot record = Thrift.writeVal oprot $ from_StorageMembership record
-- | Serialize a 'StorageMembership' in pure code
encode_StorageMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> StorageMembership -> BS.ByteString
encode_StorageMembership oprot record = Thrift.serializeVal oprot $ from_StorageMembership record
-- | Translate a 'Types.ThriftVal' to a 'StorageMembership'
to_StorageMembership :: Types.ThriftVal -> StorageMembership
to_StorageMembership (Types.TStruct fields) = StorageMembership{
  storageMembership_proto_version = maybe (storageMembership_proto_version default_StorageMembership) (\(_,_val31) -> (case _val31 of {Types.TI32 _val32 -> _val32; _ -> error "wrong type"})) (Map.lookup (1) fields),
  storageMembership_membership_version = maybe (storageMembership_membership_version default_StorageMembership) (\(_,_val31) -> (case _val31 of {Types.TI64 _val33 -> _val33; _ -> error "wrong type"})) (Map.lookup (2) fields),
  storageMembership_node_states = maybe (storageMembership_node_states default_StorageMembership) (\(_,_val31) -> (case _val31 of {Types.TMap _ _ _val34 -> (Map.fromList $ map (\(_k36,_v35) -> ((case _k36 of {Types.TI16 _val37 -> _val37; _ -> error "wrong type"}),(case _v35 of {Types.TList _ _val38 -> (Vector.fromList $ map (\_v39 -> (case _v39 of {Types.TStruct _val40 -> (Membership_Types.to_ShardState (Types.TStruct _val40)); _ -> error "wrong type"})) _val38); _ -> error "wrong type"}))) _val34); _ -> error "wrong type"})) (Map.lookup (3) fields),
  storageMembership_metadata_shards = maybe (storageMembership_metadata_shards default_StorageMembership) (\(_,_val31) -> (case _val31 of {Types.TList _ _val41 -> (Vector.fromList $ map (\_v42 -> (case _v42 of {Types.TStruct _val43 -> (Membership_Types.to_ShardID (Types.TStruct _val43)); _ -> error "wrong type"})) _val41); _ -> error "wrong type"})) (Map.lookup (4) fields),
  storageMembership_bootstrapping = maybe (storageMembership_bootstrapping default_StorageMembership) (\(_,_val31) -> (case _val31 of {Types.TBool _val44 -> _val44; _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_StorageMembership _ = error "not a struct"
-- | Read a 'StorageMembership' struct with the given 'Thrift.Protocol'
read_StorageMembership :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO StorageMembership
read_StorageMembership iprot = to_StorageMembership <$> Thrift.readVal iprot (Types.T_STRUCT typemap_StorageMembership)
-- | Deserialize a 'StorageMembership' in pure code
decode_StorageMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> StorageMembership
decode_StorageMembership iprot bs = to_StorageMembership $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_StorageMembership) bs
-- | 'TypeMap' for the 'StorageMembership' struct
typemap_StorageMembership :: Types.TypeMap
typemap_StorageMembership = Map.fromList [("proto_version",(1,Types.T_I32)),("membership_version",(2,Types.T_I64)),("node_states",(3,(Types.T_MAP Types.T_I16 (Types.T_LIST (Types.T_STRUCT Membership_Types.typemap_ShardState))))),("metadata_shards",(4,(Types.T_LIST (Types.T_STRUCT Membership_Types.typemap_ShardID)))),("bootstrapping",(5,Types.T_BOOL))]
-- | Default values for the 'StorageMembership' struct
default_StorageMembership :: StorageMembership
default_StorageMembership = StorageMembership{
  storageMembership_proto_version = 0,
  storageMembership_membership_version = 0,
  storageMembership_node_states = Map.empty,
  storageMembership_metadata_shards = Vector.empty,
  storageMembership_bootstrapping = False}
-- | Definition of the SequencerNodeState struct
data SequencerNodeState = SequencerNodeState
  { sequencerNodeState_weight :: Double
    -- ^ weight field of the SequencerNodeState struct
  , sequencerNodeState_sequencer_enabled :: Bool
    -- ^ sequencer_enabled field of the SequencerNodeState struct
  , sequencerNodeState_manual_override :: Bool
    -- ^ manual_override field of the SequencerNodeState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SequencerNodeState where
  encode = encode_SequencerNodeState
  decode = decode_SequencerNodeState
instance Hashable.Hashable SequencerNodeState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` sequencerNodeState_weight record   `Hashable.hashWithSalt` sequencerNodeState_sequencer_enabled record   `Hashable.hashWithSalt` sequencerNodeState_manual_override record  
instance DeepSeq.NFData SequencerNodeState where
  rnf _record45 =
    DeepSeq.rnf (sequencerNodeState_weight _record45) `seq`
    DeepSeq.rnf (sequencerNodeState_sequencer_enabled _record45) `seq`
    DeepSeq.rnf (sequencerNodeState_manual_override _record45) `seq`
    ()
instance Arbitrary.Arbitrary SequencerNodeState where 
  arbitrary = Monad.liftM SequencerNodeState (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_SequencerNodeState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SequencerNodeState{sequencerNodeState_weight = sequencerNodeState_weight obj} then Nothing else Just $ default_SequencerNodeState{sequencerNodeState_weight = sequencerNodeState_weight obj}
    , if obj == default_SequencerNodeState{sequencerNodeState_sequencer_enabled = sequencerNodeState_sequencer_enabled obj} then Nothing else Just $ default_SequencerNodeState{sequencerNodeState_sequencer_enabled = sequencerNodeState_sequencer_enabled obj}
    , if obj == default_SequencerNodeState{sequencerNodeState_manual_override = sequencerNodeState_manual_override obj} then Nothing else Just $ default_SequencerNodeState{sequencerNodeState_manual_override = sequencerNodeState_manual_override obj}
    ]
-- | Translate a 'SequencerNodeState' to a 'Types.ThriftVal'
from_SequencerNodeState :: SequencerNodeState -> Types.ThriftVal
from_SequencerNodeState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v48 -> Just (1, ("weight",Types.TDouble _v48))) $ sequencerNodeState_weight record
  , (\_v48 -> Just (3, ("sequencer_enabled",Types.TBool _v48))) $ sequencerNodeState_sequencer_enabled record
  , (\_v48 -> Just (4, ("manual_override",Types.TBool _v48))) $ sequencerNodeState_manual_override record
  ]
-- | Write a 'SequencerNodeState' with the given 'Thrift.Protocol'
write_SequencerNodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerNodeState -> IO ()
write_SequencerNodeState oprot record = Thrift.writeVal oprot $ from_SequencerNodeState record
-- | Serialize a 'SequencerNodeState' in pure code
encode_SequencerNodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerNodeState -> BS.ByteString
encode_SequencerNodeState oprot record = Thrift.serializeVal oprot $ from_SequencerNodeState record
-- | Translate a 'Types.ThriftVal' to a 'SequencerNodeState'
to_SequencerNodeState :: Types.ThriftVal -> SequencerNodeState
to_SequencerNodeState (Types.TStruct fields) = SequencerNodeState{
  sequencerNodeState_weight = maybe (sequencerNodeState_weight default_SequencerNodeState) (\(_,_val50) -> (case _val50 of {Types.TDouble _val51 -> _val51; _ -> error "wrong type"})) (Map.lookup (1) fields),
  sequencerNodeState_sequencer_enabled = maybe (sequencerNodeState_sequencer_enabled default_SequencerNodeState) (\(_,_val50) -> (case _val50 of {Types.TBool _val52 -> _val52; _ -> error "wrong type"})) (Map.lookup (3) fields),
  sequencerNodeState_manual_override = maybe (sequencerNodeState_manual_override default_SequencerNodeState) (\(_,_val50) -> (case _val50 of {Types.TBool _val53 -> _val53; _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_SequencerNodeState _ = error "not a struct"
-- | Read a 'SequencerNodeState' struct with the given 'Thrift.Protocol'
read_SequencerNodeState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SequencerNodeState
read_SequencerNodeState iprot = to_SequencerNodeState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SequencerNodeState)
-- | Deserialize a 'SequencerNodeState' in pure code
decode_SequencerNodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SequencerNodeState
decode_SequencerNodeState iprot bs = to_SequencerNodeState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SequencerNodeState) bs
-- | 'TypeMap' for the 'SequencerNodeState' struct
typemap_SequencerNodeState :: Types.TypeMap
typemap_SequencerNodeState = Map.fromList [("weight",(1,Types.T_DOUBLE)),("sequencer_enabled",(3,Types.T_BOOL)),("manual_override",(4,Types.T_BOOL))]
-- | Default values for the 'SequencerNodeState' struct
default_SequencerNodeState :: SequencerNodeState
default_SequencerNodeState = SequencerNodeState{
  sequencerNodeState_weight = 0,
  sequencerNodeState_sequencer_enabled = False,
  sequencerNodeState_manual_override = False}
-- | Definition of the SequencerMembership struct
data SequencerMembership = SequencerMembership
  { sequencerMembership_proto_version :: Int.Int32
    -- ^ proto_version field of the SequencerMembership struct
  , sequencerMembership_membership_version :: Int.Int64
    -- ^ membership_version field of the SequencerMembership struct
  , sequencerMembership_node_states :: (Map.HashMap Int.Int16 Membership_Types.SequencerNodeState)
    -- ^ node_states field of the SequencerMembership struct
  , sequencerMembership_bootstrapping :: Bool
    -- ^ bootstrapping field of the SequencerMembership struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SequencerMembership where
  encode = encode_SequencerMembership
  decode = decode_SequencerMembership
instance Hashable.Hashable SequencerMembership where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` sequencerMembership_proto_version record   `Hashable.hashWithSalt` sequencerMembership_membership_version record   `Hashable.hashWithSalt` sequencerMembership_node_states record   `Hashable.hashWithSalt` sequencerMembership_bootstrapping record  
instance DeepSeq.NFData SequencerMembership where
  rnf _record54 =
    DeepSeq.rnf (sequencerMembership_proto_version _record54) `seq`
    DeepSeq.rnf (sequencerMembership_membership_version _record54) `seq`
    DeepSeq.rnf (sequencerMembership_node_states _record54) `seq`
    DeepSeq.rnf (sequencerMembership_bootstrapping _record54) `seq`
    ()
instance Arbitrary.Arbitrary SequencerMembership where 
  arbitrary = Monad.liftM SequencerMembership (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_SequencerMembership = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SequencerMembership{sequencerMembership_proto_version = sequencerMembership_proto_version obj} then Nothing else Just $ default_SequencerMembership{sequencerMembership_proto_version = sequencerMembership_proto_version obj}
    , if obj == default_SequencerMembership{sequencerMembership_membership_version = sequencerMembership_membership_version obj} then Nothing else Just $ default_SequencerMembership{sequencerMembership_membership_version = sequencerMembership_membership_version obj}
    , if obj == default_SequencerMembership{sequencerMembership_node_states = sequencerMembership_node_states obj} then Nothing else Just $ default_SequencerMembership{sequencerMembership_node_states = sequencerMembership_node_states obj}
    , if obj == default_SequencerMembership{sequencerMembership_bootstrapping = sequencerMembership_bootstrapping obj} then Nothing else Just $ default_SequencerMembership{sequencerMembership_bootstrapping = sequencerMembership_bootstrapping obj}
    ]
-- | Translate a 'SequencerMembership' to a 'Types.ThriftVal'
from_SequencerMembership :: SequencerMembership -> Types.ThriftVal
from_SequencerMembership record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v57 -> Just (1, ("proto_version",Types.TI32 _v57))) $ sequencerMembership_proto_version record
  , (\_v57 -> Just (2, ("membership_version",Types.TI64 _v57))) $ sequencerMembership_membership_version record
  , (\_v57 -> Just (3, ("node_states",Types.TMap Types.T_I16 (Types.T_STRUCT Membership_Types.typemap_SequencerNodeState) $ map (\(_k58,_v59) -> (Types.TI16 _k58, Membership_Types.from_SequencerNodeState _v59)) $ Map.toList _v57))) $ sequencerMembership_node_states record
  , (\_v57 -> Just (4, ("bootstrapping",Types.TBool _v57))) $ sequencerMembership_bootstrapping record
  ]
-- | Write a 'SequencerMembership' with the given 'Thrift.Protocol'
write_SequencerMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerMembership -> IO ()
write_SequencerMembership oprot record = Thrift.writeVal oprot $ from_SequencerMembership record
-- | Serialize a 'SequencerMembership' in pure code
encode_SequencerMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerMembership -> BS.ByteString
encode_SequencerMembership oprot record = Thrift.serializeVal oprot $ from_SequencerMembership record
-- | Translate a 'Types.ThriftVal' to a 'SequencerMembership'
to_SequencerMembership :: Types.ThriftVal -> SequencerMembership
to_SequencerMembership (Types.TStruct fields) = SequencerMembership{
  sequencerMembership_proto_version = maybe (sequencerMembership_proto_version default_SequencerMembership) (\(_,_val61) -> (case _val61 of {Types.TI32 _val62 -> _val62; _ -> error "wrong type"})) (Map.lookup (1) fields),
  sequencerMembership_membership_version = maybe (sequencerMembership_membership_version default_SequencerMembership) (\(_,_val61) -> (case _val61 of {Types.TI64 _val63 -> _val63; _ -> error "wrong type"})) (Map.lookup (2) fields),
  sequencerMembership_node_states = maybe (sequencerMembership_node_states default_SequencerMembership) (\(_,_val61) -> (case _val61 of {Types.TMap _ _ _val64 -> (Map.fromList $ map (\(_k66,_v65) -> ((case _k66 of {Types.TI16 _val67 -> _val67; _ -> error "wrong type"}),(case _v65 of {Types.TStruct _val68 -> (Membership_Types.to_SequencerNodeState (Types.TStruct _val68)); _ -> error "wrong type"}))) _val64); _ -> error "wrong type"})) (Map.lookup (3) fields),
  sequencerMembership_bootstrapping = maybe (sequencerMembership_bootstrapping default_SequencerMembership) (\(_,_val61) -> (case _val61 of {Types.TBool _val69 -> _val69; _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_SequencerMembership _ = error "not a struct"
-- | Read a 'SequencerMembership' struct with the given 'Thrift.Protocol'
read_SequencerMembership :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SequencerMembership
read_SequencerMembership iprot = to_SequencerMembership <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SequencerMembership)
-- | Deserialize a 'SequencerMembership' in pure code
decode_SequencerMembership :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SequencerMembership
decode_SequencerMembership iprot bs = to_SequencerMembership $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SequencerMembership) bs
-- | 'TypeMap' for the 'SequencerMembership' struct
typemap_SequencerMembership :: Types.TypeMap
typemap_SequencerMembership = Map.fromList [("proto_version",(1,Types.T_I32)),("membership_version",(2,Types.T_I64)),("node_states",(3,(Types.T_MAP Types.T_I16 (Types.T_STRUCT Membership_Types.typemap_SequencerNodeState)))),("bootstrapping",(4,Types.T_BOOL))]
-- | Default values for the 'SequencerMembership' struct
default_SequencerMembership :: SequencerMembership
default_SequencerMembership = SequencerMembership{
  sequencerMembership_proto_version = 0,
  sequencerMembership_membership_version = 0,
  sequencerMembership_node_states = Map.empty,
  sequencerMembership_bootstrapping = False}

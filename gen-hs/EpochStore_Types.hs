{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module EpochStore_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Common_Types as Common_Types


type U8 = Int.Int8

type U16 = Int.Int16

type U32 = Int.Int32

type U64 = Int.Int64

type StorageSet = Vector.Vector EpochStore_Types.ShardID

-- | Definition of the ShardID struct
data ShardID = ShardID
  { shardID_node_idx :: Int.Int16
    -- ^ node_idx field of the ShardID struct
  , shardID_shard_idx :: Int.Int16
    -- ^ shard_idx field of the ShardID struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardID where
  encode = encode_ShardID
  decode = decode_ShardID
instance Hashable.Hashable ShardID where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardID_node_idx record   `Hashable.hashWithSalt` shardID_shard_idx record  
instance DeepSeq.NFData ShardID where
  rnf _record0 =
    DeepSeq.rnf (shardID_node_idx _record0) `seq`
    DeepSeq.rnf (shardID_shard_idx _record0) `seq`
    ()
instance Arbitrary.Arbitrary ShardID where 
  arbitrary = Monad.liftM ShardID (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardID = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardID{shardID_node_idx = shardID_node_idx obj} then Nothing else Just $ default_ShardID{shardID_node_idx = shardID_node_idx obj}
    , if obj == default_ShardID{shardID_shard_idx = shardID_shard_idx obj} then Nothing else Just $ default_ShardID{shardID_shard_idx = shardID_shard_idx obj}
    ]
-- | Translate a 'ShardID' to a 'Types.ThriftVal'
from_ShardID :: ShardID -> Types.ThriftVal
from_ShardID record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("node_idx",Types.TI16 _v3))) $ shardID_node_idx record
  , (\_v3 -> Just (2, ("shard_idx",Types.TI16 _v3))) $ shardID_shard_idx record
  ]
-- | Write a 'ShardID' with the given 'Thrift.Protocol'
write_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardID -> IO ()
write_ShardID oprot record = Thrift.writeVal oprot $ from_ShardID record
-- | Serialize a 'ShardID' in pure code
encode_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardID -> BS.ByteString
encode_ShardID oprot record = Thrift.serializeVal oprot $ from_ShardID record
-- | Translate a 'Types.ThriftVal' to a 'ShardID'
to_ShardID :: Types.ThriftVal -> ShardID
to_ShardID (Types.TStruct fields) = ShardID{
  shardID_node_idx = maybe (shardID_node_idx default_ShardID) (\(_,_val5) -> (case _val5 of {Types.TI16 _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardID_shard_idx = maybe (shardID_shard_idx default_ShardID) (\(_,_val5) -> (case _val5 of {Types.TI16 _val7 -> _val7; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_ShardID _ = error "not a struct"
-- | Read a 'ShardID' struct with the given 'Thrift.Protocol'
read_ShardID :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardID
read_ShardID iprot = to_ShardID <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardID)
-- | Deserialize a 'ShardID' in pure code
decode_ShardID :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardID
decode_ShardID iprot bs = to_ShardID $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardID) bs
-- | 'TypeMap' for the 'ShardID' struct
typemap_ShardID :: Types.TypeMap
typemap_ShardID = Map.fromList [("node_idx",(1,Types.T_I16)),("shard_idx",(2,Types.T_I16))]
-- | Default values for the 'ShardID' struct
default_ShardID :: ShardID
default_ShardID = ShardID{
  shardID_node_idx = 0,
  shardID_shard_idx = 0}
-- | Definition of the TailRecord struct
data TailRecord = TailRecord
  { tailRecord_logid :: Int.Int64
    -- ^ logid field of the TailRecord struct
  , tailRecord_lsn :: Int.Int64
    -- ^ lsn field of the TailRecord struct
  , tailRecord_timestamp :: Int.Int64
    -- ^ timestamp field of the TailRecord struct
  , tailRecord_flags_value :: Int.Int32
    -- ^ flags_value field of the TailRecord struct
  , tailRecord_offset_map :: (Map.HashMap Int.Int8 Int.Int64)
    -- ^ offset_map field of the TailRecord struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TailRecord where
  encode = encode_TailRecord
  decode = decode_TailRecord
instance Hashable.Hashable TailRecord where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` tailRecord_logid record   `Hashable.hashWithSalt` tailRecord_lsn record   `Hashable.hashWithSalt` tailRecord_timestamp record   `Hashable.hashWithSalt` tailRecord_flags_value record   `Hashable.hashWithSalt` tailRecord_offset_map record  
instance DeepSeq.NFData TailRecord where
  rnf _record8 =
    DeepSeq.rnf (tailRecord_logid _record8) `seq`
    DeepSeq.rnf (tailRecord_lsn _record8) `seq`
    DeepSeq.rnf (tailRecord_timestamp _record8) `seq`
    DeepSeq.rnf (tailRecord_flags_value _record8) `seq`
    DeepSeq.rnf (tailRecord_offset_map _record8) `seq`
    ()
instance Arbitrary.Arbitrary TailRecord where 
  arbitrary = Monad.liftM TailRecord (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_TailRecord = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TailRecord{tailRecord_logid = tailRecord_logid obj} then Nothing else Just $ default_TailRecord{tailRecord_logid = tailRecord_logid obj}
    , if obj == default_TailRecord{tailRecord_lsn = tailRecord_lsn obj} then Nothing else Just $ default_TailRecord{tailRecord_lsn = tailRecord_lsn obj}
    , if obj == default_TailRecord{tailRecord_timestamp = tailRecord_timestamp obj} then Nothing else Just $ default_TailRecord{tailRecord_timestamp = tailRecord_timestamp obj}
    , if obj == default_TailRecord{tailRecord_flags_value = tailRecord_flags_value obj} then Nothing else Just $ default_TailRecord{tailRecord_flags_value = tailRecord_flags_value obj}
    , if obj == default_TailRecord{tailRecord_offset_map = tailRecord_offset_map obj} then Nothing else Just $ default_TailRecord{tailRecord_offset_map = tailRecord_offset_map obj}
    ]
-- | Translate a 'TailRecord' to a 'Types.ThriftVal'
from_TailRecord :: TailRecord -> Types.ThriftVal
from_TailRecord record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v11 -> Just (1, ("logid",Types.TI64 _v11))) $ tailRecord_logid record
  , (\_v11 -> Just (2, ("lsn",Types.TI64 _v11))) $ tailRecord_lsn record
  , (\_v11 -> Just (3, ("timestamp",Types.TI64 _v11))) $ tailRecord_timestamp record
  , (\_v11 -> Just (4, ("flags_value",Types.TI32 _v11))) $ tailRecord_flags_value record
  , (\_v11 -> Just (5, ("offset_map",Types.TMap Types.T_BYTE Types.T_I64 $ map (\(_k12,_v13) -> (Types.TByte _k12, Types.TI64 _v13)) $ Map.toList _v11))) $ tailRecord_offset_map record
  ]
-- | Write a 'TailRecord' with the given 'Thrift.Protocol'
write_TailRecord :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TailRecord -> IO ()
write_TailRecord oprot record = Thrift.writeVal oprot $ from_TailRecord record
-- | Serialize a 'TailRecord' in pure code
encode_TailRecord :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TailRecord -> BS.ByteString
encode_TailRecord oprot record = Thrift.serializeVal oprot $ from_TailRecord record
-- | Translate a 'Types.ThriftVal' to a 'TailRecord'
to_TailRecord :: Types.ThriftVal -> TailRecord
to_TailRecord (Types.TStruct fields) = TailRecord{
  tailRecord_logid = maybe (tailRecord_logid default_TailRecord) (\(_,_val15) -> (case _val15 of {Types.TI64 _val16 -> _val16; _ -> error "wrong type"})) (Map.lookup (1) fields),
  tailRecord_lsn = maybe (tailRecord_lsn default_TailRecord) (\(_,_val15) -> (case _val15 of {Types.TI64 _val17 -> _val17; _ -> error "wrong type"})) (Map.lookup (2) fields),
  tailRecord_timestamp = maybe (tailRecord_timestamp default_TailRecord) (\(_,_val15) -> (case _val15 of {Types.TI64 _val18 -> _val18; _ -> error "wrong type"})) (Map.lookup (3) fields),
  tailRecord_flags_value = maybe (tailRecord_flags_value default_TailRecord) (\(_,_val15) -> (case _val15 of {Types.TI32 _val19 -> _val19; _ -> error "wrong type"})) (Map.lookup (4) fields),
  tailRecord_offset_map = maybe (tailRecord_offset_map default_TailRecord) (\(_,_val15) -> (case _val15 of {Types.TMap _ _ _val20 -> (Map.fromList $ map (\(_k22,_v21) -> ((case _k22 of {Types.TByte _val23 -> _val23; _ -> error "wrong type"}),(case _v21 of {Types.TI64 _val24 -> _val24; _ -> error "wrong type"}))) _val20); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_TailRecord _ = error "not a struct"
-- | Read a 'TailRecord' struct with the given 'Thrift.Protocol'
read_TailRecord :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TailRecord
read_TailRecord iprot = to_TailRecord <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TailRecord)
-- | Deserialize a 'TailRecord' in pure code
decode_TailRecord :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TailRecord
decode_TailRecord iprot bs = to_TailRecord $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TailRecord) bs
-- | 'TypeMap' for the 'TailRecord' struct
typemap_TailRecord :: Types.TypeMap
typemap_TailRecord = Map.fromList [("logid",(1,Types.T_I64)),("lsn",(2,Types.T_I64)),("timestamp",(3,Types.T_I64)),("flags_value",(4,Types.T_I32)),("offset_map",(5,(Types.T_MAP Types.T_BYTE Types.T_I64)))]
-- | Default values for the 'TailRecord' struct
default_TailRecord :: TailRecord
default_TailRecord = TailRecord{
  tailRecord_logid = 0,
  tailRecord_lsn = 0,
  tailRecord_timestamp = 0,
  tailRecord_flags_value = 0,
  tailRecord_offset_map = Map.empty}
-- | Definition of the EpochReplicationConfig struct
data EpochReplicationConfig = EpochReplicationConfig
  { epochReplicationConfig_effective_since :: Int.Int32
    -- ^ effective_since field of the EpochReplicationConfig struct
  , epochReplicationConfig_creation_timestamp :: Int.Int64
    -- ^ creation_timestamp field of the EpochReplicationConfig struct
  , epochReplicationConfig_storage_set :: (Vector.Vector EpochStore_Types.ShardID)
    -- ^ storage_set field of the EpochReplicationConfig struct
  , epochReplicationConfig_replication :: (Map.HashMap Common_Types.LocationScope Int.Int32)
    -- ^ replication field of the EpochReplicationConfig struct
  , epochReplicationConfig_weights :: Maybe (Vector.Vector Double)
    -- ^ weights field of the EpochReplicationConfig struct
  , epochReplicationConfig_written_in_metadatalog :: Bool
    -- ^ written_in_metadatalog field of the EpochReplicationConfig struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable EpochReplicationConfig where
  encode = encode_EpochReplicationConfig
  decode = decode_EpochReplicationConfig
instance Hashable.Hashable EpochReplicationConfig where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` epochReplicationConfig_effective_since record   `Hashable.hashWithSalt` epochReplicationConfig_creation_timestamp record   `Hashable.hashWithSalt` epochReplicationConfig_storage_set record   `Hashable.hashWithSalt` epochReplicationConfig_replication record   `Hashable.hashWithSalt` epochReplicationConfig_weights record   `Hashable.hashWithSalt` epochReplicationConfig_written_in_metadatalog record  
instance DeepSeq.NFData EpochReplicationConfig where
  rnf _record25 =
    DeepSeq.rnf (epochReplicationConfig_effective_since _record25) `seq`
    DeepSeq.rnf (epochReplicationConfig_creation_timestamp _record25) `seq`
    DeepSeq.rnf (epochReplicationConfig_storage_set _record25) `seq`
    DeepSeq.rnf (epochReplicationConfig_replication _record25) `seq`
    DeepSeq.rnf (epochReplicationConfig_weights _record25) `seq`
    DeepSeq.rnf (epochReplicationConfig_written_in_metadatalog _record25) `seq`
    ()
instance Arbitrary.Arbitrary EpochReplicationConfig where 
  arbitrary = Monad.liftM EpochReplicationConfig (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_EpochReplicationConfig = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_EpochReplicationConfig{epochReplicationConfig_effective_since = epochReplicationConfig_effective_since obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_effective_since = epochReplicationConfig_effective_since obj}
    , if obj == default_EpochReplicationConfig{epochReplicationConfig_creation_timestamp = epochReplicationConfig_creation_timestamp obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_creation_timestamp = epochReplicationConfig_creation_timestamp obj}
    , if obj == default_EpochReplicationConfig{epochReplicationConfig_storage_set = epochReplicationConfig_storage_set obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_storage_set = epochReplicationConfig_storage_set obj}
    , if obj == default_EpochReplicationConfig{epochReplicationConfig_replication = epochReplicationConfig_replication obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_replication = epochReplicationConfig_replication obj}
    , if obj == default_EpochReplicationConfig{epochReplicationConfig_weights = epochReplicationConfig_weights obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_weights = epochReplicationConfig_weights obj}
    , if obj == default_EpochReplicationConfig{epochReplicationConfig_written_in_metadatalog = epochReplicationConfig_written_in_metadatalog obj} then Nothing else Just $ default_EpochReplicationConfig{epochReplicationConfig_written_in_metadatalog = epochReplicationConfig_written_in_metadatalog obj}
    ]
-- | Translate a 'EpochReplicationConfig' to a 'Types.ThriftVal'
from_EpochReplicationConfig :: EpochReplicationConfig -> Types.ThriftVal
from_EpochReplicationConfig record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v28 -> Just (1, ("effective_since",Types.TI32 _v28))) $ epochReplicationConfig_effective_since record
  , (\_v28 -> Just (2, ("creation_timestamp",Types.TI64 _v28))) $ epochReplicationConfig_creation_timestamp record
  , (\_v28 -> Just (3, ("storage_set",Types.TList (Types.T_STRUCT EpochStore_Types.typemap_ShardID) $ map (\_v30 -> EpochStore_Types.from_ShardID _v30) $ Vector.toList _v28))) $ epochReplicationConfig_storage_set record
  , (\_v28 -> Just (4, ("replication",Types.TMap Types.T_I32 Types.T_I32 $ map (\(_k31,_v32) -> (Types.TI32 $ fromIntegral $ fromEnum _k31, Types.TI32 _v32)) $ Map.toList _v28))) $ epochReplicationConfig_replication record
  , (\_v28 -> (5, ("weights",Types.TList Types.T_DOUBLE $ map (\_v34 -> Types.TDouble _v34) $ Vector.toList _v28))) <$> epochReplicationConfig_weights record
  , (\_v28 -> Just (6, ("written_in_metadatalog",Types.TBool _v28))) $ epochReplicationConfig_written_in_metadatalog record
  ]
-- | Write a 'EpochReplicationConfig' with the given 'Thrift.Protocol'
write_EpochReplicationConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> EpochReplicationConfig -> IO ()
write_EpochReplicationConfig oprot record = Thrift.writeVal oprot $ from_EpochReplicationConfig record
-- | Serialize a 'EpochReplicationConfig' in pure code
encode_EpochReplicationConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> EpochReplicationConfig -> BS.ByteString
encode_EpochReplicationConfig oprot record = Thrift.serializeVal oprot $ from_EpochReplicationConfig record
-- | Translate a 'Types.ThriftVal' to a 'EpochReplicationConfig'
to_EpochReplicationConfig :: Types.ThriftVal -> EpochReplicationConfig
to_EpochReplicationConfig (Types.TStruct fields) = EpochReplicationConfig{
  epochReplicationConfig_effective_since = maybe (epochReplicationConfig_effective_since default_EpochReplicationConfig) (\(_,_val36) -> (case _val36 of {Types.TI32 _val37 -> _val37; _ -> error "wrong type"})) (Map.lookup (1) fields),
  epochReplicationConfig_creation_timestamp = maybe (epochReplicationConfig_creation_timestamp default_EpochReplicationConfig) (\(_,_val36) -> (case _val36 of {Types.TI64 _val38 -> _val38; _ -> error "wrong type"})) (Map.lookup (2) fields),
  epochReplicationConfig_storage_set = maybe (epochReplicationConfig_storage_set default_EpochReplicationConfig) (\(_,_val36) -> (case _val36 of {Types.TList _ _val39 -> (Vector.fromList $ map (\_v40 -> (case _v40 of {Types.TStruct _val41 -> (EpochStore_Types.to_ShardID (Types.TStruct _val41)); _ -> error "wrong type"})) _val39); _ -> error "wrong type"})) (Map.lookup (3) fields),
  epochReplicationConfig_replication = maybe (epochReplicationConfig_replication default_EpochReplicationConfig) (\(_,_val36) -> (case _val36 of {Types.TMap _ _ _val42 -> (Map.fromList $ map (\(_k44,_v43) -> ((case _k44 of {Types.TI32 _val45 -> toEnum $ fromIntegral _val45; _ -> error "wrong type"}),(case _v43 of {Types.TI32 _val46 -> _val46; _ -> error "wrong type"}))) _val42); _ -> error "wrong type"})) (Map.lookup (4) fields),
  epochReplicationConfig_weights = maybe (Nothing) (\(_,_val36) -> Just (case _val36 of {Types.TList _ _val47 -> (Vector.fromList $ map (\_v48 -> (case _v48 of {Types.TDouble _val49 -> _val49; _ -> error "wrong type"})) _val47); _ -> error "wrong type"})) (Map.lookup (5) fields),
  epochReplicationConfig_written_in_metadatalog = maybe (epochReplicationConfig_written_in_metadatalog default_EpochReplicationConfig) (\(_,_val36) -> (case _val36 of {Types.TBool _val50 -> _val50; _ -> error "wrong type"})) (Map.lookup (6) fields)
  }
to_EpochReplicationConfig _ = error "not a struct"
-- | Read a 'EpochReplicationConfig' struct with the given 'Thrift.Protocol'
read_EpochReplicationConfig :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO EpochReplicationConfig
read_EpochReplicationConfig iprot = to_EpochReplicationConfig <$> Thrift.readVal iprot (Types.T_STRUCT typemap_EpochReplicationConfig)
-- | Deserialize a 'EpochReplicationConfig' in pure code
decode_EpochReplicationConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> EpochReplicationConfig
decode_EpochReplicationConfig iprot bs = to_EpochReplicationConfig $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_EpochReplicationConfig) bs
-- | 'TypeMap' for the 'EpochReplicationConfig' struct
typemap_EpochReplicationConfig :: Types.TypeMap
typemap_EpochReplicationConfig = Map.fromList [("effective_since",(1,Types.T_I32)),("creation_timestamp",(2,Types.T_I64)),("storage_set",(3,(Types.T_LIST (Types.T_STRUCT EpochStore_Types.typemap_ShardID)))),("replication",(4,(Types.T_MAP Types.T_I32 Types.T_I32))),("weights",(5,(Types.T_LIST Types.T_DOUBLE))),("written_in_metadatalog",(6,Types.T_BOOL))]
-- | Default values for the 'EpochReplicationConfig' struct
default_EpochReplicationConfig :: EpochReplicationConfig
default_EpochReplicationConfig = EpochReplicationConfig{
  epochReplicationConfig_effective_since = 0,
  epochReplicationConfig_creation_timestamp = 0,
  epochReplicationConfig_storage_set = Vector.empty,
  epochReplicationConfig_replication = Map.empty,
  epochReplicationConfig_weights = Nothing,
  epochReplicationConfig_written_in_metadatalog = False}
-- | Definition of the NodeSetParams struct
data NodeSetParams = NodeSetParams
  { nodeSetParams_signature :: Int.Int64
    -- ^ signature field of the NodeSetParams struct
  , nodeSetParams_seed :: Int.Int64
    -- ^ seed field of the NodeSetParams struct
  , nodeSetParams_target_nodeset_size :: Int.Int16
    -- ^ target_nodeset_size field of the NodeSetParams struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodeSetParams where
  encode = encode_NodeSetParams
  decode = decode_NodeSetParams
instance Hashable.Hashable NodeSetParams where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodeSetParams_signature record   `Hashable.hashWithSalt` nodeSetParams_seed record   `Hashable.hashWithSalt` nodeSetParams_target_nodeset_size record  
instance DeepSeq.NFData NodeSetParams where
  rnf _record51 =
    DeepSeq.rnf (nodeSetParams_signature _record51) `seq`
    DeepSeq.rnf (nodeSetParams_seed _record51) `seq`
    DeepSeq.rnf (nodeSetParams_target_nodeset_size _record51) `seq`
    ()
instance Arbitrary.Arbitrary NodeSetParams where 
  arbitrary = Monad.liftM NodeSetParams (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_NodeSetParams = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodeSetParams{nodeSetParams_signature = nodeSetParams_signature obj} then Nothing else Just $ default_NodeSetParams{nodeSetParams_signature = nodeSetParams_signature obj}
    , if obj == default_NodeSetParams{nodeSetParams_seed = nodeSetParams_seed obj} then Nothing else Just $ default_NodeSetParams{nodeSetParams_seed = nodeSetParams_seed obj}
    , if obj == default_NodeSetParams{nodeSetParams_target_nodeset_size = nodeSetParams_target_nodeset_size obj} then Nothing else Just $ default_NodeSetParams{nodeSetParams_target_nodeset_size = nodeSetParams_target_nodeset_size obj}
    ]
-- | Translate a 'NodeSetParams' to a 'Types.ThriftVal'
from_NodeSetParams :: NodeSetParams -> Types.ThriftVal
from_NodeSetParams record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v54 -> Just (1, ("signature",Types.TI64 _v54))) $ nodeSetParams_signature record
  , (\_v54 -> Just (2, ("seed",Types.TI64 _v54))) $ nodeSetParams_seed record
  , (\_v54 -> Just (3, ("target_nodeset_size",Types.TI16 _v54))) $ nodeSetParams_target_nodeset_size record
  ]
-- | Write a 'NodeSetParams' with the given 'Thrift.Protocol'
write_NodeSetParams :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeSetParams -> IO ()
write_NodeSetParams oprot record = Thrift.writeVal oprot $ from_NodeSetParams record
-- | Serialize a 'NodeSetParams' in pure code
encode_NodeSetParams :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeSetParams -> BS.ByteString
encode_NodeSetParams oprot record = Thrift.serializeVal oprot $ from_NodeSetParams record
-- | Translate a 'Types.ThriftVal' to a 'NodeSetParams'
to_NodeSetParams :: Types.ThriftVal -> NodeSetParams
to_NodeSetParams (Types.TStruct fields) = NodeSetParams{
  nodeSetParams_signature = maybe (nodeSetParams_signature default_NodeSetParams) (\(_,_val56) -> (case _val56 of {Types.TI64 _val57 -> _val57; _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodeSetParams_seed = maybe (nodeSetParams_seed default_NodeSetParams) (\(_,_val56) -> (case _val56 of {Types.TI64 _val58 -> _val58; _ -> error "wrong type"})) (Map.lookup (2) fields),
  nodeSetParams_target_nodeset_size = maybe (nodeSetParams_target_nodeset_size default_NodeSetParams) (\(_,_val56) -> (case _val56 of {Types.TI16 _val59 -> _val59; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_NodeSetParams _ = error "not a struct"
-- | Read a 'NodeSetParams' struct with the given 'Thrift.Protocol'
read_NodeSetParams :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodeSetParams
read_NodeSetParams iprot = to_NodeSetParams <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodeSetParams)
-- | Deserialize a 'NodeSetParams' in pure code
decode_NodeSetParams :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodeSetParams
decode_NodeSetParams iprot bs = to_NodeSetParams $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodeSetParams) bs
-- | 'TypeMap' for the 'NodeSetParams' struct
typemap_NodeSetParams :: Types.TypeMap
typemap_NodeSetParams = Map.fromList [("signature",(1,Types.T_I64)),("seed",(2,Types.T_I64)),("target_nodeset_size",(3,Types.T_I16))]
-- | Default values for the 'NodeSetParams' struct
default_NodeSetParams :: NodeSetParams
default_NodeSetParams = NodeSetParams{
  nodeSetParams_signature = 0,
  nodeSetParams_seed = 0,
  nodeSetParams_target_nodeset_size = 0}
-- | Definition of the LogMetaData struct
data LogMetaData = LogMetaData
  { logMetaData_next_epoch :: Int.Int32
    -- ^ next_epoch field of the LogMetaData struct
  , logMetaData_epoch_incremented_by :: Maybe Int.Int16
    -- ^ epoch_incremented_by field of the LogMetaData struct
  , logMetaData_epoch_incremented_by_generation :: Int.Int16
    -- ^ epoch_incremented_by_generation field of the LogMetaData struct
  , logMetaData_epoch_incremented_at_ms :: Int.Int64
    -- ^ epoch_incremented_at_ms field of the LogMetaData struct
  , logMetaData_current_replication_config :: EpochStore_Types.EpochReplicationConfig
    -- ^ current_replication_config field of the LogMetaData struct
  , logMetaData_data_last_clean_epoch :: Int.Int32
    -- ^ data_last_clean_epoch field of the LogMetaData struct
  , logMetaData_data_tail_record :: EpochStore_Types.TailRecord
    -- ^ data_tail_record field of the LogMetaData struct
  , logMetaData_metadata_last_clean_epoch :: Int.Int32
    -- ^ metadata_last_clean_epoch field of the LogMetaData struct
  , logMetaData_metadata_tail_record :: EpochStore_Types.TailRecord
    -- ^ metadata_tail_record field of the LogMetaData struct
  , logMetaData_nodeset_params :: Maybe EpochStore_Types.NodeSetParams
    -- ^ nodeset_params field of the LogMetaData struct
  , logMetaData_disabled :: Bool
    -- ^ disabled field of the LogMetaData struct
  , logMetaData_version :: Int.Int64
    -- ^ version field of the LogMetaData struct
  , logMetaData_last_modified_at_ms :: Int.Int64
    -- ^ last_modified_at_ms field of the LogMetaData struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogMetaData where
  encode = encode_LogMetaData
  decode = decode_LogMetaData
instance Hashable.Hashable LogMetaData where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logMetaData_next_epoch record   `Hashable.hashWithSalt` logMetaData_epoch_incremented_by record   `Hashable.hashWithSalt` logMetaData_epoch_incremented_by_generation record   `Hashable.hashWithSalt` logMetaData_epoch_incremented_at_ms record   `Hashable.hashWithSalt` logMetaData_current_replication_config record   `Hashable.hashWithSalt` logMetaData_data_last_clean_epoch record   `Hashable.hashWithSalt` logMetaData_data_tail_record record   `Hashable.hashWithSalt` logMetaData_metadata_last_clean_epoch record   `Hashable.hashWithSalt` logMetaData_metadata_tail_record record   `Hashable.hashWithSalt` logMetaData_nodeset_params record   `Hashable.hashWithSalt` logMetaData_disabled record   `Hashable.hashWithSalt` logMetaData_version record   `Hashable.hashWithSalt` logMetaData_last_modified_at_ms record  
instance DeepSeq.NFData LogMetaData where
  rnf _record60 =
    DeepSeq.rnf (logMetaData_next_epoch _record60) `seq`
    DeepSeq.rnf (logMetaData_epoch_incremented_by _record60) `seq`
    DeepSeq.rnf (logMetaData_epoch_incremented_by_generation _record60) `seq`
    DeepSeq.rnf (logMetaData_epoch_incremented_at_ms _record60) `seq`
    DeepSeq.rnf (logMetaData_current_replication_config _record60) `seq`
    DeepSeq.rnf (logMetaData_data_last_clean_epoch _record60) `seq`
    DeepSeq.rnf (logMetaData_data_tail_record _record60) `seq`
    DeepSeq.rnf (logMetaData_metadata_last_clean_epoch _record60) `seq`
    DeepSeq.rnf (logMetaData_metadata_tail_record _record60) `seq`
    DeepSeq.rnf (logMetaData_nodeset_params _record60) `seq`
    DeepSeq.rnf (logMetaData_disabled _record60) `seq`
    DeepSeq.rnf (logMetaData_version _record60) `seq`
    DeepSeq.rnf (logMetaData_last_modified_at_ms _record60) `seq`
    ()
instance Arbitrary.Arbitrary LogMetaData where 
  arbitrary = Monad.liftM LogMetaData (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogMetaData = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogMetaData{logMetaData_next_epoch = logMetaData_next_epoch obj} then Nothing else Just $ default_LogMetaData{logMetaData_next_epoch = logMetaData_next_epoch obj}
    , if obj == default_LogMetaData{logMetaData_epoch_incremented_by = logMetaData_epoch_incremented_by obj} then Nothing else Just $ default_LogMetaData{logMetaData_epoch_incremented_by = logMetaData_epoch_incremented_by obj}
    , if obj == default_LogMetaData{logMetaData_epoch_incremented_by_generation = logMetaData_epoch_incremented_by_generation obj} then Nothing else Just $ default_LogMetaData{logMetaData_epoch_incremented_by_generation = logMetaData_epoch_incremented_by_generation obj}
    , if obj == default_LogMetaData{logMetaData_epoch_incremented_at_ms = logMetaData_epoch_incremented_at_ms obj} then Nothing else Just $ default_LogMetaData{logMetaData_epoch_incremented_at_ms = logMetaData_epoch_incremented_at_ms obj}
    , if obj == default_LogMetaData{logMetaData_current_replication_config = logMetaData_current_replication_config obj} then Nothing else Just $ default_LogMetaData{logMetaData_current_replication_config = logMetaData_current_replication_config obj}
    , if obj == default_LogMetaData{logMetaData_data_last_clean_epoch = logMetaData_data_last_clean_epoch obj} then Nothing else Just $ default_LogMetaData{logMetaData_data_last_clean_epoch = logMetaData_data_last_clean_epoch obj}
    , if obj == default_LogMetaData{logMetaData_data_tail_record = logMetaData_data_tail_record obj} then Nothing else Just $ default_LogMetaData{logMetaData_data_tail_record = logMetaData_data_tail_record obj}
    , if obj == default_LogMetaData{logMetaData_metadata_last_clean_epoch = logMetaData_metadata_last_clean_epoch obj} then Nothing else Just $ default_LogMetaData{logMetaData_metadata_last_clean_epoch = logMetaData_metadata_last_clean_epoch obj}
    , if obj == default_LogMetaData{logMetaData_metadata_tail_record = logMetaData_metadata_tail_record obj} then Nothing else Just $ default_LogMetaData{logMetaData_metadata_tail_record = logMetaData_metadata_tail_record obj}
    , if obj == default_LogMetaData{logMetaData_nodeset_params = logMetaData_nodeset_params obj} then Nothing else Just $ default_LogMetaData{logMetaData_nodeset_params = logMetaData_nodeset_params obj}
    , if obj == default_LogMetaData{logMetaData_disabled = logMetaData_disabled obj} then Nothing else Just $ default_LogMetaData{logMetaData_disabled = logMetaData_disabled obj}
    , if obj == default_LogMetaData{logMetaData_version = logMetaData_version obj} then Nothing else Just $ default_LogMetaData{logMetaData_version = logMetaData_version obj}
    , if obj == default_LogMetaData{logMetaData_last_modified_at_ms = logMetaData_last_modified_at_ms obj} then Nothing else Just $ default_LogMetaData{logMetaData_last_modified_at_ms = logMetaData_last_modified_at_ms obj}
    ]
-- | Translate a 'LogMetaData' to a 'Types.ThriftVal'
from_LogMetaData :: LogMetaData -> Types.ThriftVal
from_LogMetaData record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v63 -> Just (1, ("next_epoch",Types.TI32 _v63))) $ logMetaData_next_epoch record
  , (\_v63 -> (2, ("epoch_incremented_by",Types.TI16 _v63))) <$> logMetaData_epoch_incremented_by record
  , (\_v63 -> Just (3, ("epoch_incremented_by_generation",Types.TI16 _v63))) $ logMetaData_epoch_incremented_by_generation record
  , (\_v63 -> Just (4, ("epoch_incremented_at_ms",Types.TI64 _v63))) $ logMetaData_epoch_incremented_at_ms record
  , (\_v63 -> Just (5, ("current_replication_config",EpochStore_Types.from_EpochReplicationConfig _v63))) $ logMetaData_current_replication_config record
  , (\_v63 -> Just (6, ("data_last_clean_epoch",Types.TI32 _v63))) $ logMetaData_data_last_clean_epoch record
  , (\_v63 -> Just (7, ("data_tail_record",EpochStore_Types.from_TailRecord _v63))) $ logMetaData_data_tail_record record
  , (\_v63 -> Just (8, ("metadata_last_clean_epoch",Types.TI32 _v63))) $ logMetaData_metadata_last_clean_epoch record
  , (\_v63 -> Just (9, ("metadata_tail_record",EpochStore_Types.from_TailRecord _v63))) $ logMetaData_metadata_tail_record record
  , (\_v63 -> (10, ("nodeset_params",EpochStore_Types.from_NodeSetParams _v63))) <$> logMetaData_nodeset_params record
  , (\_v63 -> Just (11, ("disabled",Types.TBool _v63))) $ logMetaData_disabled record
  , (\_v63 -> Just (12, ("version",Types.TI64 _v63))) $ logMetaData_version record
  , (\_v63 -> Just (13, ("last_modified_at_ms",Types.TI64 _v63))) $ logMetaData_last_modified_at_ms record
  ]
-- | Write a 'LogMetaData' with the given 'Thrift.Protocol'
write_LogMetaData :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogMetaData -> IO ()
write_LogMetaData oprot record = Thrift.writeVal oprot $ from_LogMetaData record
-- | Serialize a 'LogMetaData' in pure code
encode_LogMetaData :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogMetaData -> BS.ByteString
encode_LogMetaData oprot record = Thrift.serializeVal oprot $ from_LogMetaData record
-- | Translate a 'Types.ThriftVal' to a 'LogMetaData'
to_LogMetaData :: Types.ThriftVal -> LogMetaData
to_LogMetaData (Types.TStruct fields) = LogMetaData{
  logMetaData_next_epoch = maybe (logMetaData_next_epoch default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI32 _val66 -> _val66; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logMetaData_epoch_incremented_by = maybe (Nothing) (\(_,_val65) -> Just (case _val65 of {Types.TI16 _val67 -> _val67; _ -> error "wrong type"})) (Map.lookup (2) fields),
  logMetaData_epoch_incremented_by_generation = maybe (logMetaData_epoch_incremented_by_generation default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI16 _val68 -> _val68; _ -> error "wrong type"})) (Map.lookup (3) fields),
  logMetaData_epoch_incremented_at_ms = maybe (logMetaData_epoch_incremented_at_ms default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI64 _val69 -> _val69; _ -> error "wrong type"})) (Map.lookup (4) fields),
  logMetaData_current_replication_config = maybe (logMetaData_current_replication_config default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TStruct _val70 -> (EpochStore_Types.to_EpochReplicationConfig (Types.TStruct _val70)); _ -> error "wrong type"})) (Map.lookup (5) fields),
  logMetaData_data_last_clean_epoch = maybe (logMetaData_data_last_clean_epoch default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI32 _val71 -> _val71; _ -> error "wrong type"})) (Map.lookup (6) fields),
  logMetaData_data_tail_record = maybe (logMetaData_data_tail_record default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TStruct _val72 -> (EpochStore_Types.to_TailRecord (Types.TStruct _val72)); _ -> error "wrong type"})) (Map.lookup (7) fields),
  logMetaData_metadata_last_clean_epoch = maybe (logMetaData_metadata_last_clean_epoch default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI32 _val73 -> _val73; _ -> error "wrong type"})) (Map.lookup (8) fields),
  logMetaData_metadata_tail_record = maybe (logMetaData_metadata_tail_record default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TStruct _val74 -> (EpochStore_Types.to_TailRecord (Types.TStruct _val74)); _ -> error "wrong type"})) (Map.lookup (9) fields),
  logMetaData_nodeset_params = maybe (Nothing) (\(_,_val65) -> Just (case _val65 of {Types.TStruct _val75 -> (EpochStore_Types.to_NodeSetParams (Types.TStruct _val75)); _ -> error "wrong type"})) (Map.lookup (10) fields),
  logMetaData_disabled = maybe (logMetaData_disabled default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TBool _val76 -> _val76; _ -> error "wrong type"})) (Map.lookup (11) fields),
  logMetaData_version = maybe (logMetaData_version default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI64 _val77 -> _val77; _ -> error "wrong type"})) (Map.lookup (12) fields),
  logMetaData_last_modified_at_ms = maybe (logMetaData_last_modified_at_ms default_LogMetaData) (\(_,_val65) -> (case _val65 of {Types.TI64 _val78 -> _val78; _ -> error "wrong type"})) (Map.lookup (13) fields)
  }
to_LogMetaData _ = error "not a struct"
-- | Read a 'LogMetaData' struct with the given 'Thrift.Protocol'
read_LogMetaData :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogMetaData
read_LogMetaData iprot = to_LogMetaData <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogMetaData)
-- | Deserialize a 'LogMetaData' in pure code
decode_LogMetaData :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogMetaData
decode_LogMetaData iprot bs = to_LogMetaData $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogMetaData) bs
-- | 'TypeMap' for the 'LogMetaData' struct
typemap_LogMetaData :: Types.TypeMap
typemap_LogMetaData = Map.fromList [("next_epoch",(1,Types.T_I32)),("epoch_incremented_by",(2,Types.T_I16)),("epoch_incremented_by_generation",(3,Types.T_I16)),("epoch_incremented_at_ms",(4,Types.T_I64)),("current_replication_config",(5,(Types.T_STRUCT EpochStore_Types.typemap_EpochReplicationConfig))),("data_last_clean_epoch",(6,Types.T_I32)),("data_tail_record",(7,(Types.T_STRUCT EpochStore_Types.typemap_TailRecord))),("metadata_last_clean_epoch",(8,Types.T_I32)),("metadata_tail_record",(9,(Types.T_STRUCT EpochStore_Types.typemap_TailRecord))),("nodeset_params",(10,(Types.T_STRUCT EpochStore_Types.typemap_NodeSetParams))),("disabled",(11,Types.T_BOOL)),("version",(12,Types.T_I64)),("last_modified_at_ms",(13,Types.T_I64))]
-- | Default values for the 'LogMetaData' struct
default_LogMetaData :: LogMetaData
default_LogMetaData = LogMetaData{
  logMetaData_next_epoch = 0,
  logMetaData_epoch_incremented_by = Nothing,
  logMetaData_epoch_incremented_by_generation = 0,
  logMetaData_epoch_incremented_at_ms = 0,
  logMetaData_current_replication_config = EpochStore_Types.default_EpochReplicationConfig,
  logMetaData_data_last_clean_epoch = 0,
  logMetaData_data_tail_record = EpochStore_Types.default_TailRecord,
  logMetaData_metadata_last_clean_epoch = 0,
  logMetaData_metadata_tail_record = EpochStore_Types.default_TailRecord,
  logMetaData_nodeset_params = Nothing,
  logMetaData_disabled = False,
  logMetaData_version = 0,
  logMetaData_last_modified_at_ms = 0}

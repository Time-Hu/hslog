{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module AdminAPI_Fuzzer (main) where
import qualified Admin_Types
import qualified AdminAPI_Client as Client
import qualified Fb303_Types
import qualified Common_Types
import qualified Admin_commands_Types
import qualified Cluster_membership_Types
import qualified Exceptions_Types
import qualified Logtree_Types
import qualified Maintenance_Types
import qualified Nodes_Types
import qualified Safety_Types
import qualified Settings_Types

import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Fb303_Types as Fb303_Types
import qualified Common_Types as Common_Types
import qualified Admin_commands_Types as Admin_commands_Types
import qualified Cluster_membership_Types as Cluster_membership_Types
import qualified Exceptions_Types as Exceptions_Types
import qualified Logtree_Types as Logtree_Types
import qualified Maintenance_Types as Maintenance_Types
import qualified Nodes_Types as Nodes_Types
import qualified Safety_Types as Safety_Types
import qualified Settings_Types as Settings_Types

import Prelude ((>>), print)
import qualified Prelude as P
import Control.Monad (forM)
import qualified Data.List as L
import Data.Maybe (fromJust)
import qualified Data.Map as Map
import GHC.Int (Int64, Int32)
import Data.ByteString.Lazy (ByteString)
import System.Environment (getArgs)
import Test.QuickCheck (arbitrary)
import Test.QuickCheck.Gen (Gen(..))
import Thrift.FuzzerSupport


handleOptions :: ([Options -> Options], [String], [String]) -> Options
handleOptions (transformers, (serviceName:[]), []) | serviceName `P.elem` serviceNames
    = (P.foldl (P.flip ($)) defaultOptions transformers) { opt_service = serviceName } 
handleOptions (_, (serviceName:[]), []) | P.otherwise
    = P.error $ usage ++ "\nUnknown serviceName " ++ serviceName ++ ", should be one of " ++ (P.show serviceNames)
handleOptions (_, [], _) = P.error $ usage ++ "\nMissing mandatory serviceName to fuzz."
handleOptions (_, _a, []) = P.error $ usage ++ "\nToo many serviceNames, pick one."
handleOptions (_, _, e) = P.error $ usage ++ (P.show e)

main :: IO ()
main = do
    args <- getArgs
    let config = handleOptions (getOptions args)
    fuzz config

selectFuzzer :: Options -> (Options -> IO ())
selectFuzzer (Options _host _port service _timeout _framed _verbose) 
    = fromJust $ P.lookup service fuzzerFunctions

fuzz :: Options -> IO ()
fuzz config = (selectFuzzer config) config

-- Dynamic content

-- Configuration via command-line parsing

serviceNames :: [String]
serviceNames = ["getNodesConfig", "getNodesState", "addNodes", "updateNodes", "removeNodes", "markShardsAsProvisioned", "bumpNodeGeneration", "bootstrapCluster", "getMaintenances", "applyMaintenance", "removeMaintenances", "markAllShardsUnrecoverable", "checkImpact", "getSettings", "applySettingOverride", "removeSettingOverride", "takeLogTreeSnapshot", "takeMaintenanceLogSnapshot", "getLogGroupThroughput", "getLogGroupCustomCounters", "executeAdminCommand"]

fuzzerFunctions :: [(String, (Options -> IO ()))]
fuzzerFunctions = [("getNodesConfig", getNodesConfig_fuzzer), ("getNodesState", getNodesState_fuzzer), ("addNodes", addNodes_fuzzer), ("updateNodes", updateNodes_fuzzer), ("removeNodes", removeNodes_fuzzer), ("markShardsAsProvisioned", markShardsAsProvisioned_fuzzer), ("bumpNodeGeneration", bumpNodeGeneration_fuzzer), ("bootstrapCluster", bootstrapCluster_fuzzer), ("getMaintenances", getMaintenances_fuzzer), ("applyMaintenance", applyMaintenance_fuzzer), ("removeMaintenances", removeMaintenances_fuzzer), ("markAllShardsUnrecoverable", markAllShardsUnrecoverable_fuzzer), ("checkImpact", checkImpact_fuzzer), ("getSettings", getSettings_fuzzer), ("applySettingOverride", applySettingOverride_fuzzer), ("removeSettingOverride", removeSettingOverride_fuzzer), ("takeLogTreeSnapshot", takeLogTreeSnapshot_fuzzer), ("takeMaintenanceLogSnapshot", takeMaintenanceLogSnapshot_fuzzer), ("getLogGroupThroughput", getLogGroupThroughput_fuzzer), ("getLogGroupCustomCounters", getLogGroupCustomCounters_fuzzer), ("executeAdminCommand", executeAdminCommand_fuzzer)]

-- Random data generation
inf_Admin_commands_Types_AdminCommandRequest :: IO [Admin_commands_Types.AdminCommandRequest]
inf_Admin_commands_Types_AdminCommandRequest = infexamples (Arbitrary.arbitrary :: Gen Admin_commands_Types.AdminCommandRequest)

inf_Cluster_membership_Types_AddNodesRequest :: IO [Cluster_membership_Types.AddNodesRequest]
inf_Cluster_membership_Types_AddNodesRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.AddNodesRequest)

inf_Cluster_membership_Types_BootstrapClusterRequest :: IO [Cluster_membership_Types.BootstrapClusterRequest]
inf_Cluster_membership_Types_BootstrapClusterRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.BootstrapClusterRequest)

inf_Cluster_membership_Types_BumpGenerationRequest :: IO [Cluster_membership_Types.BumpGenerationRequest]
inf_Cluster_membership_Types_BumpGenerationRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.BumpGenerationRequest)

inf_Cluster_membership_Types_MarkShardsAsProvisionedRequest :: IO [Cluster_membership_Types.MarkShardsAsProvisionedRequest]
inf_Cluster_membership_Types_MarkShardsAsProvisionedRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.MarkShardsAsProvisionedRequest)

inf_Cluster_membership_Types_RemoveNodesRequest :: IO [Cluster_membership_Types.RemoveNodesRequest]
inf_Cluster_membership_Types_RemoveNodesRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.RemoveNodesRequest)

inf_Cluster_membership_Types_UpdateNodesRequest :: IO [Cluster_membership_Types.UpdateNodesRequest]
inf_Cluster_membership_Types_UpdateNodesRequest = infexamples (Arbitrary.arbitrary :: Gen Cluster_membership_Types.UpdateNodesRequest)

inf_Int_Int64 :: IO [Int.Int64]
inf_Int_Int64 = infexamples (Arbitrary.arbitrary :: Gen Int.Int64)

inf_Logtree_Types_LogGroupCustomCountersRequest :: IO [Logtree_Types.LogGroupCustomCountersRequest]
inf_Logtree_Types_LogGroupCustomCountersRequest = infexamples (Arbitrary.arbitrary :: Gen Logtree_Types.LogGroupCustomCountersRequest)

inf_Logtree_Types_LogGroupThroughputRequest :: IO [Logtree_Types.LogGroupThroughputRequest]
inf_Logtree_Types_LogGroupThroughputRequest = infexamples (Arbitrary.arbitrary :: Gen Logtree_Types.LogGroupThroughputRequest)

inf_Maintenance_Types_MaintenanceDefinition :: IO [Maintenance_Types.MaintenanceDefinition]
inf_Maintenance_Types_MaintenanceDefinition = infexamples (Arbitrary.arbitrary :: Gen Maintenance_Types.MaintenanceDefinition)

inf_Maintenance_Types_MaintenancesFilter :: IO [Maintenance_Types.MaintenancesFilter]
inf_Maintenance_Types_MaintenancesFilter = infexamples (Arbitrary.arbitrary :: Gen Maintenance_Types.MaintenancesFilter)

inf_Maintenance_Types_MarkAllShardsUnrecoverableRequest :: IO [Maintenance_Types.MarkAllShardsUnrecoverableRequest]
inf_Maintenance_Types_MarkAllShardsUnrecoverableRequest = infexamples (Arbitrary.arbitrary :: Gen Maintenance_Types.MarkAllShardsUnrecoverableRequest)

inf_Maintenance_Types_RemoveMaintenancesRequest :: IO [Maintenance_Types.RemoveMaintenancesRequest]
inf_Maintenance_Types_RemoveMaintenancesRequest = infexamples (Arbitrary.arbitrary :: Gen Maintenance_Types.RemoveMaintenancesRequest)

inf_Nodes_Types_NodesFilter :: IO [Nodes_Types.NodesFilter]
inf_Nodes_Types_NodesFilter = infexamples (Arbitrary.arbitrary :: Gen Nodes_Types.NodesFilter)

inf_Nodes_Types_NodesStateRequest :: IO [Nodes_Types.NodesStateRequest]
inf_Nodes_Types_NodesStateRequest = infexamples (Arbitrary.arbitrary :: Gen Nodes_Types.NodesStateRequest)

inf_Safety_Types_CheckImpactRequest :: IO [Safety_Types.CheckImpactRequest]
inf_Safety_Types_CheckImpactRequest = infexamples (Arbitrary.arbitrary :: Gen Safety_Types.CheckImpactRequest)

inf_Settings_Types_ApplySettingOverrideRequest :: IO [Settings_Types.ApplySettingOverrideRequest]
inf_Settings_Types_ApplySettingOverrideRequest = infexamples (Arbitrary.arbitrary :: Gen Settings_Types.ApplySettingOverrideRequest)

inf_Settings_Types_RemoveSettingOverrideRequest :: IO [Settings_Types.RemoveSettingOverrideRequest]
inf_Settings_Types_RemoveSettingOverrideRequest = infexamples (Arbitrary.arbitrary :: Gen Settings_Types.RemoveSettingOverrideRequest)

inf_Settings_Types_SettingsRequest :: IO [Settings_Types.SettingsRequest]
inf_Settings_Types_SettingsRequest = infexamples (Arbitrary.arbitrary :: Gen Settings_Types.SettingsRequest)

-- Fuzzers and exception handlers
getNodesConfig_fuzzer :: Options -> IO ()
getNodesConfig_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Nodes_Types_NodesFilter
  _ <- forM (Applicative.getZipList a1) getNodesConfig_fuzzFunc
  return ()
  where
  getNodesConfig_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getNodesConfig_fuzzOnce param) (getNodesConfig_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getNodesConfig_fuzzOnce param) (getNodesConfig_exceptionHandler param)

getNodesConfig_exceptionHandler :: (Show a1) => (a1) -> IO ()
getNodesConfig_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getNodesConfig_fuzzOnce (a1) client = Client.getNodesConfig client a1 >> return ()

getNodesState_fuzzer :: Options -> IO ()
getNodesState_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Nodes_Types_NodesStateRequest
  _ <- forM (Applicative.getZipList a1) getNodesState_fuzzFunc
  return ()
  where
  getNodesState_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getNodesState_fuzzOnce param) (getNodesState_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getNodesState_fuzzOnce param) (getNodesState_exceptionHandler param)

getNodesState_exceptionHandler :: (Show a1) => (a1) -> IO ()
getNodesState_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getNodesState_fuzzOnce (a1) client = Client.getNodesState client a1 >> return ()

addNodes_fuzzer :: Options -> IO ()
addNodes_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_AddNodesRequest
  _ <- forM (Applicative.getZipList a1) addNodes_fuzzFunc
  return ()
  where
  addNodes_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (addNodes_fuzzOnce param) (addNodes_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (addNodes_fuzzOnce param) (addNodes_exceptionHandler param)

addNodes_exceptionHandler :: (Show a1) => (a1) -> IO ()
addNodes_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
addNodes_fuzzOnce (a1) client = Client.addNodes client a1 >> return ()

updateNodes_fuzzer :: Options -> IO ()
updateNodes_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_UpdateNodesRequest
  _ <- forM (Applicative.getZipList a1) updateNodes_fuzzFunc
  return ()
  where
  updateNodes_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (updateNodes_fuzzOnce param) (updateNodes_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (updateNodes_fuzzOnce param) (updateNodes_exceptionHandler param)

updateNodes_exceptionHandler :: (Show a1) => (a1) -> IO ()
updateNodes_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
updateNodes_fuzzOnce (a1) client = Client.updateNodes client a1 >> return ()

removeNodes_fuzzer :: Options -> IO ()
removeNodes_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_RemoveNodesRequest
  _ <- forM (Applicative.getZipList a1) removeNodes_fuzzFunc
  return ()
  where
  removeNodes_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (removeNodes_fuzzOnce param) (removeNodes_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (removeNodes_fuzzOnce param) (removeNodes_exceptionHandler param)

removeNodes_exceptionHandler :: (Show a1) => (a1) -> IO ()
removeNodes_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
removeNodes_fuzzOnce (a1) client = Client.removeNodes client a1 >> return ()

markShardsAsProvisioned_fuzzer :: Options -> IO ()
markShardsAsProvisioned_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_MarkShardsAsProvisionedRequest
  _ <- forM (Applicative.getZipList a1) markShardsAsProvisioned_fuzzFunc
  return ()
  where
  markShardsAsProvisioned_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (markShardsAsProvisioned_fuzzOnce param) (markShardsAsProvisioned_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (markShardsAsProvisioned_fuzzOnce param) (markShardsAsProvisioned_exceptionHandler param)

markShardsAsProvisioned_exceptionHandler :: (Show a1) => (a1) -> IO ()
markShardsAsProvisioned_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
markShardsAsProvisioned_fuzzOnce (a1) client = Client.markShardsAsProvisioned client a1 >> return ()

bumpNodeGeneration_fuzzer :: Options -> IO ()
bumpNodeGeneration_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_BumpGenerationRequest
  _ <- forM (Applicative.getZipList a1) bumpNodeGeneration_fuzzFunc
  return ()
  where
  bumpNodeGeneration_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (bumpNodeGeneration_fuzzOnce param) (bumpNodeGeneration_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (bumpNodeGeneration_fuzzOnce param) (bumpNodeGeneration_exceptionHandler param)

bumpNodeGeneration_exceptionHandler :: (Show a1) => (a1) -> IO ()
bumpNodeGeneration_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
bumpNodeGeneration_fuzzOnce (a1) client = Client.bumpNodeGeneration client a1 >> return ()

bootstrapCluster_fuzzer :: Options -> IO ()
bootstrapCluster_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Cluster_membership_Types_BootstrapClusterRequest
  _ <- forM (Applicative.getZipList a1) bootstrapCluster_fuzzFunc
  return ()
  where
  bootstrapCluster_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (bootstrapCluster_fuzzOnce param) (bootstrapCluster_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (bootstrapCluster_fuzzOnce param) (bootstrapCluster_exceptionHandler param)

bootstrapCluster_exceptionHandler :: (Show a1) => (a1) -> IO ()
bootstrapCluster_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
bootstrapCluster_fuzzOnce (a1) client = Client.bootstrapCluster client a1 >> return ()

getMaintenances_fuzzer :: Options -> IO ()
getMaintenances_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Maintenance_Types_MaintenancesFilter
  _ <- forM (Applicative.getZipList a1) getMaintenances_fuzzFunc
  return ()
  where
  getMaintenances_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getMaintenances_fuzzOnce param) (getMaintenances_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getMaintenances_fuzzOnce param) (getMaintenances_exceptionHandler param)

getMaintenances_exceptionHandler :: (Show a1) => (a1) -> IO ()
getMaintenances_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getMaintenances_fuzzOnce (a1) client = Client.getMaintenances client a1 >> return ()

applyMaintenance_fuzzer :: Options -> IO ()
applyMaintenance_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Maintenance_Types_MaintenanceDefinition
  _ <- forM (Applicative.getZipList a1) applyMaintenance_fuzzFunc
  return ()
  where
  applyMaintenance_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (applyMaintenance_fuzzOnce param) (applyMaintenance_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (applyMaintenance_fuzzOnce param) (applyMaintenance_exceptionHandler param)

applyMaintenance_exceptionHandler :: (Show a1) => (a1) -> IO ()
applyMaintenance_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
applyMaintenance_fuzzOnce (a1) client = Client.applyMaintenance client a1 >> return ()

removeMaintenances_fuzzer :: Options -> IO ()
removeMaintenances_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Maintenance_Types_RemoveMaintenancesRequest
  _ <- forM (Applicative.getZipList a1) removeMaintenances_fuzzFunc
  return ()
  where
  removeMaintenances_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (removeMaintenances_fuzzOnce param) (removeMaintenances_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (removeMaintenances_fuzzOnce param) (removeMaintenances_exceptionHandler param)

removeMaintenances_exceptionHandler :: (Show a1) => (a1) -> IO ()
removeMaintenances_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
removeMaintenances_fuzzOnce (a1) client = Client.removeMaintenances client a1 >> return ()

markAllShardsUnrecoverable_fuzzer :: Options -> IO ()
markAllShardsUnrecoverable_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Maintenance_Types_MarkAllShardsUnrecoverableRequest
  _ <- forM (Applicative.getZipList a1) markAllShardsUnrecoverable_fuzzFunc
  return ()
  where
  markAllShardsUnrecoverable_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (markAllShardsUnrecoverable_fuzzOnce param) (markAllShardsUnrecoverable_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (markAllShardsUnrecoverable_fuzzOnce param) (markAllShardsUnrecoverable_exceptionHandler param)

markAllShardsUnrecoverable_exceptionHandler :: (Show a1) => (a1) -> IO ()
markAllShardsUnrecoverable_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
markAllShardsUnrecoverable_fuzzOnce (a1) client = Client.markAllShardsUnrecoverable client a1 >> return ()

checkImpact_fuzzer :: Options -> IO ()
checkImpact_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Safety_Types_CheckImpactRequest
  _ <- forM (Applicative.getZipList a1) checkImpact_fuzzFunc
  return ()
  where
  checkImpact_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (checkImpact_fuzzOnce param) (checkImpact_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (checkImpact_fuzzOnce param) (checkImpact_exceptionHandler param)

checkImpact_exceptionHandler :: (Show a1) => (a1) -> IO ()
checkImpact_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
checkImpact_fuzzOnce (a1) client = Client.checkImpact client a1 >> return ()

getSettings_fuzzer :: Options -> IO ()
getSettings_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Settings_Types_SettingsRequest
  _ <- forM (Applicative.getZipList a1) getSettings_fuzzFunc
  return ()
  where
  getSettings_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getSettings_fuzzOnce param) (getSettings_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getSettings_fuzzOnce param) (getSettings_exceptionHandler param)

getSettings_exceptionHandler :: (Show a1) => (a1) -> IO ()
getSettings_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getSettings_fuzzOnce (a1) client = Client.getSettings client a1 >> return ()

applySettingOverride_fuzzer :: Options -> IO ()
applySettingOverride_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Settings_Types_ApplySettingOverrideRequest
  _ <- forM (Applicative.getZipList a1) applySettingOverride_fuzzFunc
  return ()
  where
  applySettingOverride_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (applySettingOverride_fuzzOnce param) (applySettingOverride_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (applySettingOverride_fuzzOnce param) (applySettingOverride_exceptionHandler param)

applySettingOverride_exceptionHandler :: (Show a1) => (a1) -> IO ()
applySettingOverride_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
applySettingOverride_fuzzOnce (a1) client = Client.applySettingOverride client a1 >> return ()

removeSettingOverride_fuzzer :: Options -> IO ()
removeSettingOverride_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Settings_Types_RemoveSettingOverrideRequest
  _ <- forM (Applicative.getZipList a1) removeSettingOverride_fuzzFunc
  return ()
  where
  removeSettingOverride_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (removeSettingOverride_fuzzOnce param) (removeSettingOverride_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (removeSettingOverride_fuzzOnce param) (removeSettingOverride_exceptionHandler param)

removeSettingOverride_exceptionHandler :: (Show a1) => (a1) -> IO ()
removeSettingOverride_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
removeSettingOverride_fuzzOnce (a1) client = Client.removeSettingOverride client a1 >> return ()

takeLogTreeSnapshot_fuzzer :: Options -> IO ()
takeLogTreeSnapshot_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Int_Int64
  _ <- forM (Applicative.getZipList a1) takeLogTreeSnapshot_fuzzFunc
  return ()
  where
  takeLogTreeSnapshot_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (takeLogTreeSnapshot_fuzzOnce param) (takeLogTreeSnapshot_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (takeLogTreeSnapshot_fuzzOnce param) (takeLogTreeSnapshot_exceptionHandler param)

takeLogTreeSnapshot_exceptionHandler :: (Show a1) => (a1) -> IO ()
takeLogTreeSnapshot_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
takeLogTreeSnapshot_fuzzOnce (a1) client = Client.takeLogTreeSnapshot client a1 >> return ()

takeMaintenanceLogSnapshot_fuzzer :: Options -> IO ()
takeMaintenanceLogSnapshot_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Int_Int64
  _ <- forM (Applicative.getZipList a1) takeMaintenanceLogSnapshot_fuzzFunc
  return ()
  where
  takeMaintenanceLogSnapshot_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (takeMaintenanceLogSnapshot_fuzzOnce param) (takeMaintenanceLogSnapshot_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (takeMaintenanceLogSnapshot_fuzzOnce param) (takeMaintenanceLogSnapshot_exceptionHandler param)

takeMaintenanceLogSnapshot_exceptionHandler :: (Show a1) => (a1) -> IO ()
takeMaintenanceLogSnapshot_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
takeMaintenanceLogSnapshot_fuzzOnce (a1) client = Client.takeMaintenanceLogSnapshot client a1 >> return ()

getLogGroupThroughput_fuzzer :: Options -> IO ()
getLogGroupThroughput_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Logtree_Types_LogGroupThroughputRequest
  _ <- forM (Applicative.getZipList a1) getLogGroupThroughput_fuzzFunc
  return ()
  where
  getLogGroupThroughput_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getLogGroupThroughput_fuzzOnce param) (getLogGroupThroughput_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getLogGroupThroughput_fuzzOnce param) (getLogGroupThroughput_exceptionHandler param)

getLogGroupThroughput_exceptionHandler :: (Show a1) => (a1) -> IO ()
getLogGroupThroughput_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getLogGroupThroughput_fuzzOnce (a1) client = Client.getLogGroupThroughput client a1 >> return ()

getLogGroupCustomCounters_fuzzer :: Options -> IO ()
getLogGroupCustomCounters_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Logtree_Types_LogGroupCustomCountersRequest
  _ <- forM (Applicative.getZipList a1) getLogGroupCustomCounters_fuzzFunc
  return ()
  where
  getLogGroupCustomCounters_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (getLogGroupCustomCounters_fuzzOnce param) (getLogGroupCustomCounters_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (getLogGroupCustomCounters_fuzzOnce param) (getLogGroupCustomCounters_exceptionHandler param)

getLogGroupCustomCounters_exceptionHandler :: (Show a1) => (a1) -> IO ()
getLogGroupCustomCounters_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
getLogGroupCustomCounters_fuzzOnce (a1) client = Client.getLogGroupCustomCounters client a1 >> return ()

executeAdminCommand_fuzzer :: Options -> IO ()
executeAdminCommand_fuzzer opts = do
  a1 <- Applicative.ZipList <$> inf_Admin_commands_Types_AdminCommandRequest
  _ <- forM (Applicative.getZipList a1) executeAdminCommand_fuzzFunc
  return ()
  where
  executeAdminCommand_fuzzFunc a1 = let param = (a1) in
    if opt_framed opts
    then withThriftDo opts (withFramedTransport opts) (executeAdminCommand_fuzzOnce param) (executeAdminCommand_exceptionHandler param)
    else withThriftDo opts (withHandle opts) (executeAdminCommand_fuzzOnce param) (executeAdminCommand_exceptionHandler param)

executeAdminCommand_exceptionHandler :: (Show a1) => (a1) -> IO ()
executeAdminCommand_exceptionHandler (a1) = do
  P.putStrLn $ "Got exception on data:"
  P.putStrLn $ "(" ++ show a1 ++ ")"
executeAdminCommand_fuzzOnce (a1) client = Client.executeAdminCommand client a1 >> return ()


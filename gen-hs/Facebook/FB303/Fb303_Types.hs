{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Facebook.FB303.Fb303_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries


data Fb_status = DEAD|STARTING|ALIVE|STOPPING|STOPPED|WARNING  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum Fb_status where
  fromEnum t = case t of
    DEAD -> 0
    STARTING -> 1
    ALIVE -> 2
    STOPPING -> 3
    STOPPED -> 4
    WARNING -> 5
  toEnum t = case t of
    0 -> DEAD
    1 -> STARTING
    2 -> ALIVE
    3 -> STOPPING
    4 -> STOPPED
    5 -> WARNING
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    DEAD -> STARTING
    STARTING -> ALIVE
    ALIVE -> STOPPING
    STOPPING -> STOPPED
    STOPPED -> WARNING
    WARNING -> Exception.throw Thrift.ThriftException
  pred t = case t of
    DEAD -> Exception.throw Thrift.ThriftException
    STARTING -> DEAD
    ALIVE -> STARTING
    STOPPING -> ALIVE
    STOPPED -> STOPPING
    WARNING -> STOPPED
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable Fb_status where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData Fb_status where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary Fb_status where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)

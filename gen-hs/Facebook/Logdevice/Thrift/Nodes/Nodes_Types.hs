{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Facebook.Logdevice.Thrift.Nodes.Nodes_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Facebook.Logdevice.Thrift.Common.Common_Types as Common_Types
import qualified Membership_Types as Membership_Types


data MaintenanceStatus = NOT_STARTED|STARTED|AWAITING_NODES_CONFIG_CHANGES|AWAITING_SAFETY_CHECK|BLOCKED_UNTIL_SAFE|AWAITING_DATA_REBUILDING|REBUILDING_IS_BLOCKED|COMPLETED|RETRY|AWAITING_NODES_CONFIG_TRANSITION|AWAITING_NODE_PROVISIONING|AWAITING_START_DATA_MIGRATION|BLOCKED_BY_ADMIN_OVERRIDE|AWAITING_NODE_TO_BE_ALIVE  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum MaintenanceStatus where
  fromEnum t = case t of
    NOT_STARTED -> 0
    STARTED -> 1
    AWAITING_NODES_CONFIG_CHANGES -> 2
    AWAITING_SAFETY_CHECK -> 3
    BLOCKED_UNTIL_SAFE -> 4
    AWAITING_DATA_REBUILDING -> 5
    REBUILDING_IS_BLOCKED -> 6
    COMPLETED -> 7
    RETRY -> 8
    AWAITING_NODES_CONFIG_TRANSITION -> 9
    AWAITING_NODE_PROVISIONING -> 10
    AWAITING_START_DATA_MIGRATION -> 11
    BLOCKED_BY_ADMIN_OVERRIDE -> 12
    AWAITING_NODE_TO_BE_ALIVE -> 13
  toEnum t = case t of
    0 -> NOT_STARTED
    1 -> STARTED
    2 -> AWAITING_NODES_CONFIG_CHANGES
    3 -> AWAITING_SAFETY_CHECK
    4 -> BLOCKED_UNTIL_SAFE
    5 -> AWAITING_DATA_REBUILDING
    6 -> REBUILDING_IS_BLOCKED
    7 -> COMPLETED
    8 -> RETRY
    9 -> AWAITING_NODES_CONFIG_TRANSITION
    10 -> AWAITING_NODE_PROVISIONING
    11 -> AWAITING_START_DATA_MIGRATION
    12 -> BLOCKED_BY_ADMIN_OVERRIDE
    13 -> AWAITING_NODE_TO_BE_ALIVE
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    NOT_STARTED -> STARTED
    STARTED -> AWAITING_NODES_CONFIG_CHANGES
    AWAITING_NODES_CONFIG_CHANGES -> AWAITING_SAFETY_CHECK
    AWAITING_SAFETY_CHECK -> BLOCKED_UNTIL_SAFE
    BLOCKED_UNTIL_SAFE -> AWAITING_DATA_REBUILDING
    AWAITING_DATA_REBUILDING -> REBUILDING_IS_BLOCKED
    REBUILDING_IS_BLOCKED -> COMPLETED
    COMPLETED -> RETRY
    RETRY -> AWAITING_NODES_CONFIG_TRANSITION
    AWAITING_NODES_CONFIG_TRANSITION -> AWAITING_NODE_PROVISIONING
    AWAITING_NODE_PROVISIONING -> AWAITING_START_DATA_MIGRATION
    AWAITING_START_DATA_MIGRATION -> BLOCKED_BY_ADMIN_OVERRIDE
    BLOCKED_BY_ADMIN_OVERRIDE -> AWAITING_NODE_TO_BE_ALIVE
    AWAITING_NODE_TO_BE_ALIVE -> Exception.throw Thrift.ThriftException
  pred t = case t of
    NOT_STARTED -> Exception.throw Thrift.ThriftException
    STARTED -> NOT_STARTED
    AWAITING_NODES_CONFIG_CHANGES -> STARTED
    AWAITING_SAFETY_CHECK -> AWAITING_NODES_CONFIG_CHANGES
    BLOCKED_UNTIL_SAFE -> AWAITING_SAFETY_CHECK
    AWAITING_DATA_REBUILDING -> BLOCKED_UNTIL_SAFE
    REBUILDING_IS_BLOCKED -> AWAITING_DATA_REBUILDING
    COMPLETED -> REBUILDING_IS_BLOCKED
    RETRY -> COMPLETED
    AWAITING_NODES_CONFIG_TRANSITION -> RETRY
    AWAITING_NODE_PROVISIONING -> AWAITING_NODES_CONFIG_TRANSITION
    AWAITING_START_DATA_MIGRATION -> AWAITING_NODE_PROVISIONING
    BLOCKED_BY_ADMIN_OVERRIDE -> AWAITING_START_DATA_MIGRATION
    AWAITING_NODE_TO_BE_ALIVE -> BLOCKED_BY_ADMIN_OVERRIDE
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable MaintenanceStatus where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData MaintenanceStatus where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary MaintenanceStatus where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data ShardDataHealth = UNKNOWN|HEALTHY|UNAVAILABLE|LOST_REGIONS|LOST_ALL|EMPTY  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ShardDataHealth where
  fromEnum t = case t of
    UNKNOWN -> 0
    HEALTHY -> 1
    UNAVAILABLE -> 2
    LOST_REGIONS -> 3
    LOST_ALL -> 4
    EMPTY -> 5
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> HEALTHY
    2 -> UNAVAILABLE
    3 -> LOST_REGIONS
    4 -> LOST_ALL
    5 -> EMPTY
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> HEALTHY
    HEALTHY -> UNAVAILABLE
    UNAVAILABLE -> LOST_REGIONS
    LOST_REGIONS -> LOST_ALL
    LOST_ALL -> EMPTY
    EMPTY -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    HEALTHY -> UNKNOWN
    UNAVAILABLE -> HEALTHY
    LOST_REGIONS -> UNAVAILABLE
    LOST_ALL -> LOST_REGIONS
    EMPTY -> LOST_ALL
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ShardDataHealth where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ShardDataHealth where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ShardDataHealth where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data ShardOperationalState = UNKNOWN|ENABLED|MAY_DISAPPEAR|DRAINED|MIGRATING_DATA|ENABLING|PROVISIONING|PASSIVE_DRAINING|INVALID  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ShardOperationalState where
  fromEnum t = case t of
    UNKNOWN -> 0
    ENABLED -> 1
    MAY_DISAPPEAR -> 2
    DRAINED -> 3
    MIGRATING_DATA -> 51
    ENABLING -> 52
    PROVISIONING -> 53
    PASSIVE_DRAINING -> 54
    INVALID -> 99
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> ENABLED
    2 -> MAY_DISAPPEAR
    3 -> DRAINED
    51 -> MIGRATING_DATA
    52 -> ENABLING
    53 -> PROVISIONING
    54 -> PASSIVE_DRAINING
    99 -> INVALID
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> ENABLED
    ENABLED -> MAY_DISAPPEAR
    MAY_DISAPPEAR -> DRAINED
    DRAINED -> MIGRATING_DATA
    MIGRATING_DATA -> ENABLING
    ENABLING -> PROVISIONING
    PROVISIONING -> PASSIVE_DRAINING
    PASSIVE_DRAINING -> INVALID
    INVALID -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    ENABLED -> UNKNOWN
    MAY_DISAPPEAR -> ENABLED
    DRAINED -> MAY_DISAPPEAR
    MIGRATING_DATA -> DRAINED
    ENABLING -> MIGRATING_DATA
    PROVISIONING -> ENABLING
    PASSIVE_DRAINING -> PROVISIONING
    INVALID -> PASSIVE_DRAINING
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ShardOperationalState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ShardOperationalState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ShardOperationalState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data ShardStorageState = DISABLED|READ_ONLY|READ_WRITE|DATA_MIGRATION  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ShardStorageState where
  fromEnum t = case t of
    DISABLED -> 0
    READ_ONLY -> 1
    READ_WRITE -> 2
    DATA_MIGRATION -> 3
  toEnum t = case t of
    0 -> DISABLED
    1 -> READ_ONLY
    2 -> READ_WRITE
    3 -> DATA_MIGRATION
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    DISABLED -> READ_ONLY
    READ_ONLY -> READ_WRITE
    READ_WRITE -> DATA_MIGRATION
    DATA_MIGRATION -> Exception.throw Thrift.ThriftException
  pred t = case t of
    DISABLED -> Exception.throw Thrift.ThriftException
    READ_ONLY -> DISABLED
    READ_WRITE -> READ_ONLY
    DATA_MIGRATION -> READ_WRITE
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ShardStorageState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ShardStorageState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ShardStorageState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data SequencingState = ENABLED|BOYCOTTED|DISABLED|UNKNOWN  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum SequencingState where
  fromEnum t = case t of
    ENABLED -> 1
    BOYCOTTED -> 2
    DISABLED -> 3
    UNKNOWN -> 4
  toEnum t = case t of
    1 -> ENABLED
    2 -> BOYCOTTED
    3 -> DISABLED
    4 -> UNKNOWN
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    ENABLED -> BOYCOTTED
    BOYCOTTED -> DISABLED
    DISABLED -> UNKNOWN
    UNKNOWN -> Exception.throw Thrift.ThriftException
  pred t = case t of
    ENABLED -> Exception.throw Thrift.ThriftException
    BOYCOTTED -> ENABLED
    DISABLED -> BOYCOTTED
    UNKNOWN -> DISABLED
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable SequencingState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData SequencingState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary SequencingState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data ServiceState = UNKNOWN|ALIVE|STARTING_UP|SHUTTING_DOWN|DEAD  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ServiceState where
  fromEnum t = case t of
    UNKNOWN -> 0
    ALIVE -> 1
    STARTING_UP -> 2
    SHUTTING_DOWN -> 3
    DEAD -> 5
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> ALIVE
    2 -> STARTING_UP
    3 -> SHUTTING_DOWN
    5 -> DEAD
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> ALIVE
    ALIVE -> STARTING_UP
    STARTING_UP -> SHUTTING_DOWN
    SHUTTING_DOWN -> DEAD
    DEAD -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    ALIVE -> UNKNOWN
    STARTING_UP -> ALIVE
    SHUTTING_DOWN -> STARTING_UP
    DEAD -> SHUTTING_DOWN
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ServiceState where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ServiceState where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ServiceState where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data ServiceHealthStatus = UNKNOWN|UNDEFINED|HEALTHY|OVERLOADED|UNHEALTHY  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum ServiceHealthStatus where
  fromEnum t = case t of
    UNKNOWN -> 0
    UNDEFINED -> 1
    HEALTHY -> 2
    OVERLOADED -> 3
    UNHEALTHY -> 4
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> UNDEFINED
    2 -> HEALTHY
    3 -> OVERLOADED
    4 -> UNHEALTHY
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> UNDEFINED
    UNDEFINED -> HEALTHY
    HEALTHY -> OVERLOADED
    OVERLOADED -> UNHEALTHY
    UNHEALTHY -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    UNDEFINED -> UNKNOWN
    HEALTHY -> UNDEFINED
    OVERLOADED -> HEALTHY
    UNHEALTHY -> OVERLOADED
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable ServiceHealthStatus where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData ServiceHealthStatus where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary ServiceHealthStatus where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
type NodesConfig = Vector.Vector Nodes_Types.NodeConfig

type NodesState = Vector.Vector Nodes_Types.NodeState

-- | Definition of the SequencerConfig struct
data SequencerConfig = SequencerConfig
  { sequencerConfig_weight :: Double
    -- ^ weight field of the SequencerConfig struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SequencerConfig where
  encode = encode_SequencerConfig
  decode = decode_SequencerConfig
instance Hashable.Hashable SequencerConfig where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` sequencerConfig_weight record  
instance DeepSeq.NFData SequencerConfig where
  rnf _record0 =
    DeepSeq.rnf (sequencerConfig_weight _record0) `seq`
    ()
instance Arbitrary.Arbitrary SequencerConfig where 
  arbitrary = Monad.liftM SequencerConfig (Arbitrary.arbitrary)
  shrink obj | obj == default_SequencerConfig = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SequencerConfig{sequencerConfig_weight = sequencerConfig_weight obj} then Nothing else Just $ default_SequencerConfig{sequencerConfig_weight = sequencerConfig_weight obj}
    ]
-- | Translate a 'SequencerConfig' to a 'Types.ThriftVal'
from_SequencerConfig :: SequencerConfig -> Types.ThriftVal
from_SequencerConfig record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("weight",Types.TDouble _v3))) $ sequencerConfig_weight record
  ]
-- | Write a 'SequencerConfig' with the given 'Thrift.Protocol'
write_SequencerConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerConfig -> IO ()
write_SequencerConfig oprot record = Thrift.writeVal oprot $ from_SequencerConfig record
-- | Serialize a 'SequencerConfig' in pure code
encode_SequencerConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerConfig -> BS.ByteString
encode_SequencerConfig oprot record = Thrift.serializeVal oprot $ from_SequencerConfig record
-- | Translate a 'Types.ThriftVal' to a 'SequencerConfig'
to_SequencerConfig :: Types.ThriftVal -> SequencerConfig
to_SequencerConfig (Types.TStruct fields) = SequencerConfig{
  sequencerConfig_weight = maybe (sequencerConfig_weight default_SequencerConfig) (\(_,_val5) -> (case _val5 of {Types.TDouble _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_SequencerConfig _ = error "not a struct"
-- | Read a 'SequencerConfig' struct with the given 'Thrift.Protocol'
read_SequencerConfig :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SequencerConfig
read_SequencerConfig iprot = to_SequencerConfig <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SequencerConfig)
-- | Deserialize a 'SequencerConfig' in pure code
decode_SequencerConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SequencerConfig
decode_SequencerConfig iprot bs = to_SequencerConfig $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SequencerConfig) bs
-- | 'TypeMap' for the 'SequencerConfig' struct
typemap_SequencerConfig :: Types.TypeMap
typemap_SequencerConfig = Map.fromList [("weight",(1,Types.T_DOUBLE))]
-- | Default values for the 'SequencerConfig' struct
default_SequencerConfig :: SequencerConfig
default_SequencerConfig = SequencerConfig{
  sequencerConfig_weight = 1}
-- | Definition of the StorageConfig struct
data StorageConfig = StorageConfig
  { storageConfig_weight :: Double
    -- ^ weight field of the StorageConfig struct
  , storageConfig_num_shards :: Int.Int32
    -- ^ num_shards field of the StorageConfig struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable StorageConfig where
  encode = encode_StorageConfig
  decode = decode_StorageConfig
instance Hashable.Hashable StorageConfig where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` storageConfig_weight record   `Hashable.hashWithSalt` storageConfig_num_shards record  
instance DeepSeq.NFData StorageConfig where
  rnf _record7 =
    DeepSeq.rnf (storageConfig_weight _record7) `seq`
    DeepSeq.rnf (storageConfig_num_shards _record7) `seq`
    ()
instance Arbitrary.Arbitrary StorageConfig where 
  arbitrary = Monad.liftM StorageConfig (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_StorageConfig = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_StorageConfig{storageConfig_weight = storageConfig_weight obj} then Nothing else Just $ default_StorageConfig{storageConfig_weight = storageConfig_weight obj}
    , if obj == default_StorageConfig{storageConfig_num_shards = storageConfig_num_shards obj} then Nothing else Just $ default_StorageConfig{storageConfig_num_shards = storageConfig_num_shards obj}
    ]
-- | Translate a 'StorageConfig' to a 'Types.ThriftVal'
from_StorageConfig :: StorageConfig -> Types.ThriftVal
from_StorageConfig record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v10 -> Just (1, ("weight",Types.TDouble _v10))) $ storageConfig_weight record
  , (\_v10 -> Just (2, ("num_shards",Types.TI32 _v10))) $ storageConfig_num_shards record
  ]
-- | Write a 'StorageConfig' with the given 'Thrift.Protocol'
write_StorageConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> StorageConfig -> IO ()
write_StorageConfig oprot record = Thrift.writeVal oprot $ from_StorageConfig record
-- | Serialize a 'StorageConfig' in pure code
encode_StorageConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> StorageConfig -> BS.ByteString
encode_StorageConfig oprot record = Thrift.serializeVal oprot $ from_StorageConfig record
-- | Translate a 'Types.ThriftVal' to a 'StorageConfig'
to_StorageConfig :: Types.ThriftVal -> StorageConfig
to_StorageConfig (Types.TStruct fields) = StorageConfig{
  storageConfig_weight = maybe (storageConfig_weight default_StorageConfig) (\(_,_val12) -> (case _val12 of {Types.TDouble _val13 -> _val13; _ -> error "wrong type"})) (Map.lookup (1) fields),
  storageConfig_num_shards = maybe (storageConfig_num_shards default_StorageConfig) (\(_,_val12) -> (case _val12 of {Types.TI32 _val14 -> _val14; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_StorageConfig _ = error "not a struct"
-- | Read a 'StorageConfig' struct with the given 'Thrift.Protocol'
read_StorageConfig :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO StorageConfig
read_StorageConfig iprot = to_StorageConfig <$> Thrift.readVal iprot (Types.T_STRUCT typemap_StorageConfig)
-- | Deserialize a 'StorageConfig' in pure code
decode_StorageConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> StorageConfig
decode_StorageConfig iprot bs = to_StorageConfig $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_StorageConfig) bs
-- | 'TypeMap' for the 'StorageConfig' struct
typemap_StorageConfig :: Types.TypeMap
typemap_StorageConfig = Map.fromList [("weight",(1,Types.T_DOUBLE)),("num_shards",(2,Types.T_I32))]
-- | Default values for the 'StorageConfig' struct
default_StorageConfig :: StorageConfig
default_StorageConfig = StorageConfig{
  storageConfig_weight = 1,
  storageConfig_num_shards = 1}
-- | Definition of the NodeConfig struct
data NodeConfig = NodeConfig
  { nodeConfig_node_index :: Int.Int16
    -- ^ node_index field of the NodeConfig struct
  , nodeConfig_data_address :: Common_Types.SocketAddress
    -- ^ data_address field of the NodeConfig struct
  , nodeConfig_roles :: (Set.HashSet Common_Types.Role)
    -- ^ roles field of the NodeConfig struct
  , nodeConfig_other_addresses :: Maybe Common_Types.Addresses
    -- ^ other_addresses field of the NodeConfig struct
  , nodeConfig_location :: Maybe LT.Text
    -- ^ location field of the NodeConfig struct
  , nodeConfig_sequencer :: Maybe Nodes_Types.SequencerConfig
    -- ^ sequencer field of the NodeConfig struct
  , nodeConfig_storage :: Maybe Nodes_Types.StorageConfig
    -- ^ storage field of the NodeConfig struct
  , nodeConfig_location_per_scope :: (Map.HashMap Common_Types.LocationScope LT.Text)
    -- ^ location_per_scope field of the NodeConfig struct
  , nodeConfig_name :: LT.Text
    -- ^ name field of the NodeConfig struct
  , nodeConfig_tags :: (Map.HashMap LT.Text LT.Text)
    -- ^ tags field of the NodeConfig struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodeConfig where
  encode = encode_NodeConfig
  decode = decode_NodeConfig
instance Hashable.Hashable NodeConfig where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodeConfig_node_index record   `Hashable.hashWithSalt` nodeConfig_data_address record   `Hashable.hashWithSalt` nodeConfig_roles record   `Hashable.hashWithSalt` nodeConfig_other_addresses record   `Hashable.hashWithSalt` nodeConfig_location record   `Hashable.hashWithSalt` nodeConfig_sequencer record   `Hashable.hashWithSalt` nodeConfig_storage record   `Hashable.hashWithSalt` nodeConfig_location_per_scope record   `Hashable.hashWithSalt` nodeConfig_name record   `Hashable.hashWithSalt` nodeConfig_tags record  
instance DeepSeq.NFData NodeConfig where
  rnf _record15 =
    DeepSeq.rnf (nodeConfig_node_index _record15) `seq`
    DeepSeq.rnf (nodeConfig_data_address _record15) `seq`
    DeepSeq.rnf (nodeConfig_roles _record15) `seq`
    DeepSeq.rnf (nodeConfig_other_addresses _record15) `seq`
    DeepSeq.rnf (nodeConfig_location _record15) `seq`
    DeepSeq.rnf (nodeConfig_sequencer _record15) `seq`
    DeepSeq.rnf (nodeConfig_storage _record15) `seq`
    DeepSeq.rnf (nodeConfig_location_per_scope _record15) `seq`
    DeepSeq.rnf (nodeConfig_name _record15) `seq`
    DeepSeq.rnf (nodeConfig_tags _record15) `seq`
    ()
instance Arbitrary.Arbitrary NodeConfig where 
  arbitrary = Monad.liftM NodeConfig (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_NodeConfig = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodeConfig{nodeConfig_node_index = nodeConfig_node_index obj} then Nothing else Just $ default_NodeConfig{nodeConfig_node_index = nodeConfig_node_index obj}
    , if obj == default_NodeConfig{nodeConfig_data_address = nodeConfig_data_address obj} then Nothing else Just $ default_NodeConfig{nodeConfig_data_address = nodeConfig_data_address obj}
    , if obj == default_NodeConfig{nodeConfig_roles = nodeConfig_roles obj} then Nothing else Just $ default_NodeConfig{nodeConfig_roles = nodeConfig_roles obj}
    , if obj == default_NodeConfig{nodeConfig_other_addresses = nodeConfig_other_addresses obj} then Nothing else Just $ default_NodeConfig{nodeConfig_other_addresses = nodeConfig_other_addresses obj}
    , if obj == default_NodeConfig{nodeConfig_location = nodeConfig_location obj} then Nothing else Just $ default_NodeConfig{nodeConfig_location = nodeConfig_location obj}
    , if obj == default_NodeConfig{nodeConfig_sequencer = nodeConfig_sequencer obj} then Nothing else Just $ default_NodeConfig{nodeConfig_sequencer = nodeConfig_sequencer obj}
    , if obj == default_NodeConfig{nodeConfig_storage = nodeConfig_storage obj} then Nothing else Just $ default_NodeConfig{nodeConfig_storage = nodeConfig_storage obj}
    , if obj == default_NodeConfig{nodeConfig_location_per_scope = nodeConfig_location_per_scope obj} then Nothing else Just $ default_NodeConfig{nodeConfig_location_per_scope = nodeConfig_location_per_scope obj}
    , if obj == default_NodeConfig{nodeConfig_name = nodeConfig_name obj} then Nothing else Just $ default_NodeConfig{nodeConfig_name = nodeConfig_name obj}
    , if obj == default_NodeConfig{nodeConfig_tags = nodeConfig_tags obj} then Nothing else Just $ default_NodeConfig{nodeConfig_tags = nodeConfig_tags obj}
    ]
-- | Translate a 'NodeConfig' to a 'Types.ThriftVal'
from_NodeConfig :: NodeConfig -> Types.ThriftVal
from_NodeConfig record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v18 -> Just (1, ("node_index",Types.TI16 _v18))) $ nodeConfig_node_index record
  , (\_v18 -> Just (2, ("data_address",Common_Types.from_SocketAddress _v18))) $ nodeConfig_data_address record
  , (\_v18 -> Just (3, ("roles",Types.TSet Types.T_I32 $ map (\_v20 -> Types.TI32 $ fromIntegral $ fromEnum _v20) $ Set.toList _v18))) $ nodeConfig_roles record
  , (\_v18 -> (4, ("other_addresses",Common_Types.from_Addresses _v18))) <$> nodeConfig_other_addresses record
  , (\_v18 -> (5, ("location",Types.TString $ Encoding.encodeUtf8 _v18))) <$> nodeConfig_location record
  , (\_v18 -> (6, ("sequencer",Nodes_Types.from_SequencerConfig _v18))) <$> nodeConfig_sequencer record
  , (\_v18 -> (7, ("storage",Nodes_Types.from_StorageConfig _v18))) <$> nodeConfig_storage record
  , (\_v18 -> Just (8, ("location_per_scope",Types.TMap Types.T_I32 Types.T_STRING $ map (\(_k21,_v22) -> (Types.TI32 $ fromIntegral $ fromEnum _k21, Types.TString $ Encoding.encodeUtf8 _v22)) $ Map.toList _v18))) $ nodeConfig_location_per_scope record
  , (\_v18 -> Just (9, ("name",Types.TString $ Encoding.encodeUtf8 _v18))) $ nodeConfig_name record
  , (\_v18 -> Just (10, ("tags",Types.TMap Types.T_STRING Types.T_STRING $ map (\(_k23,_v24) -> (Types.TString $ Encoding.encodeUtf8 _k23, Types.TString $ Encoding.encodeUtf8 _v24)) $ Map.toList _v18))) $ nodeConfig_tags record
  ]
-- | Write a 'NodeConfig' with the given 'Thrift.Protocol'
write_NodeConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeConfig -> IO ()
write_NodeConfig oprot record = Thrift.writeVal oprot $ from_NodeConfig record
-- | Serialize a 'NodeConfig' in pure code
encode_NodeConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeConfig -> BS.ByteString
encode_NodeConfig oprot record = Thrift.serializeVal oprot $ from_NodeConfig record
-- | Translate a 'Types.ThriftVal' to a 'NodeConfig'
to_NodeConfig :: Types.ThriftVal -> NodeConfig
to_NodeConfig (Types.TStruct fields) = NodeConfig{
  nodeConfig_node_index = maybe (nodeConfig_node_index default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TI16 _val27 -> _val27; _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodeConfig_data_address = maybe (nodeConfig_data_address default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TStruct _val28 -> (Common_Types.to_SocketAddress (Types.TStruct _val28)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  nodeConfig_roles = maybe (nodeConfig_roles default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TSet _ _val29 -> (Set.fromList $ map (\_v30 -> (case _v30 of {Types.TI32 _val31 -> toEnum $ fromIntegral _val31; _ -> error "wrong type"})) _val29); _ -> error "wrong type"})) (Map.lookup (3) fields),
  nodeConfig_other_addresses = maybe (Nothing) (\(_,_val26) -> Just (case _val26 of {Types.TStruct _val32 -> (Common_Types.to_Addresses (Types.TStruct _val32)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  nodeConfig_location = maybe (Nothing) (\(_,_val26) -> Just (case _val26 of {Types.TString _val33 -> Encoding.decodeUtf8 _val33; _ -> error "wrong type"})) (Map.lookup (5) fields),
  nodeConfig_sequencer = maybe (Nothing) (\(_,_val26) -> Just (case _val26 of {Types.TStruct _val34 -> (Nodes_Types.to_SequencerConfig (Types.TStruct _val34)); _ -> error "wrong type"})) (Map.lookup (6) fields),
  nodeConfig_storage = maybe (Nothing) (\(_,_val26) -> Just (case _val26 of {Types.TStruct _val35 -> (Nodes_Types.to_StorageConfig (Types.TStruct _val35)); _ -> error "wrong type"})) (Map.lookup (7) fields),
  nodeConfig_location_per_scope = maybe (nodeConfig_location_per_scope default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TMap _ _ _val36 -> (Map.fromList $ map (\(_k38,_v37) -> ((case _k38 of {Types.TI32 _val39 -> toEnum $ fromIntegral _val39; _ -> error "wrong type"}),(case _v37 of {Types.TString _val40 -> Encoding.decodeUtf8 _val40; _ -> error "wrong type"}))) _val36); _ -> error "wrong type"})) (Map.lookup (8) fields),
  nodeConfig_name = maybe (nodeConfig_name default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TString _val41 -> Encoding.decodeUtf8 _val41; _ -> error "wrong type"})) (Map.lookup (9) fields),
  nodeConfig_tags = maybe (nodeConfig_tags default_NodeConfig) (\(_,_val26) -> (case _val26 of {Types.TMap _ _ _val42 -> (Map.fromList $ map (\(_k44,_v43) -> ((case _k44 of {Types.TString _val45 -> Encoding.decodeUtf8 _val45; _ -> error "wrong type"}),(case _v43 of {Types.TString _val46 -> Encoding.decodeUtf8 _val46; _ -> error "wrong type"}))) _val42); _ -> error "wrong type"})) (Map.lookup (10) fields)
  }
to_NodeConfig _ = error "not a struct"
-- | Read a 'NodeConfig' struct with the given 'Thrift.Protocol'
read_NodeConfig :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodeConfig
read_NodeConfig iprot = to_NodeConfig <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodeConfig)
-- | Deserialize a 'NodeConfig' in pure code
decode_NodeConfig :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodeConfig
decode_NodeConfig iprot bs = to_NodeConfig $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodeConfig) bs
-- | 'TypeMap' for the 'NodeConfig' struct
typemap_NodeConfig :: Types.TypeMap
typemap_NodeConfig = Map.fromList [("node_index",(1,Types.T_I16)),("data_address",(2,(Types.T_STRUCT Common_Types.typemap_SocketAddress))),("roles",(3,(Types.T_SET Types.T_I32))),("other_addresses",(4,(Types.T_STRUCT Common_Types.typemap_Addresses))),("location",(5,Types.T_STRING)),("sequencer",(6,(Types.T_STRUCT Nodes_Types.typemap_SequencerConfig))),("storage",(7,(Types.T_STRUCT Nodes_Types.typemap_StorageConfig))),("location_per_scope",(8,(Types.T_MAP Types.T_I32 Types.T_STRING))),("name",(9,Types.T_STRING)),("tags",(10,(Types.T_MAP Types.T_STRING Types.T_STRING)))]
-- | Default values for the 'NodeConfig' struct
default_NodeConfig :: NodeConfig
default_NodeConfig = NodeConfig{
  nodeConfig_node_index = 0,
  nodeConfig_data_address = Common_Types.default_SocketAddress,
  nodeConfig_roles = Set.empty,
  nodeConfig_other_addresses = Nothing,
  nodeConfig_location = Nothing,
  nodeConfig_sequencer = Nothing,
  nodeConfig_storage = Nothing,
  nodeConfig_location_per_scope = Map.empty,
  nodeConfig_name = "",
  nodeConfig_tags = Map.empty}
-- | Definition of the ShardMaintenanceProgress struct
data ShardMaintenanceProgress = ShardMaintenanceProgress
  { shardMaintenanceProgress_status :: Nodes_Types.MaintenanceStatus
    -- ^ status field of the ShardMaintenanceProgress struct
  , shardMaintenanceProgress_target_states :: (Set.HashSet Nodes_Types.ShardOperationalState)
    -- ^ target_states field of the ShardMaintenanceProgress struct
  , shardMaintenanceProgress_created_at :: Int.Int64
    -- ^ created_at field of the ShardMaintenanceProgress struct
  , shardMaintenanceProgress_last_updated_at :: Int.Int64
    -- ^ last_updated_at field of the ShardMaintenanceProgress struct
  , shardMaintenanceProgress_associated_group_ids :: (Vector.Vector LT.Text)
    -- ^ associated_group_ids field of the ShardMaintenanceProgress struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardMaintenanceProgress where
  encode = encode_ShardMaintenanceProgress
  decode = decode_ShardMaintenanceProgress
instance Hashable.Hashable ShardMaintenanceProgress where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardMaintenanceProgress_status record   `Hashable.hashWithSalt` shardMaintenanceProgress_target_states record   `Hashable.hashWithSalt` shardMaintenanceProgress_created_at record   `Hashable.hashWithSalt` shardMaintenanceProgress_last_updated_at record   `Hashable.hashWithSalt` shardMaintenanceProgress_associated_group_ids record  
instance DeepSeq.NFData ShardMaintenanceProgress where
  rnf _record47 =
    DeepSeq.rnf (shardMaintenanceProgress_status _record47) `seq`
    DeepSeq.rnf (shardMaintenanceProgress_target_states _record47) `seq`
    DeepSeq.rnf (shardMaintenanceProgress_created_at _record47) `seq`
    DeepSeq.rnf (shardMaintenanceProgress_last_updated_at _record47) `seq`
    DeepSeq.rnf (shardMaintenanceProgress_associated_group_ids _record47) `seq`
    ()
instance Arbitrary.Arbitrary ShardMaintenanceProgress where 
  arbitrary = Monad.liftM ShardMaintenanceProgress (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardMaintenanceProgress = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardMaintenanceProgress{shardMaintenanceProgress_status = shardMaintenanceProgress_status obj} then Nothing else Just $ default_ShardMaintenanceProgress{shardMaintenanceProgress_status = shardMaintenanceProgress_status obj}
    , if obj == default_ShardMaintenanceProgress{shardMaintenanceProgress_target_states = shardMaintenanceProgress_target_states obj} then Nothing else Just $ default_ShardMaintenanceProgress{shardMaintenanceProgress_target_states = shardMaintenanceProgress_target_states obj}
    , if obj == default_ShardMaintenanceProgress{shardMaintenanceProgress_created_at = shardMaintenanceProgress_created_at obj} then Nothing else Just $ default_ShardMaintenanceProgress{shardMaintenanceProgress_created_at = shardMaintenanceProgress_created_at obj}
    , if obj == default_ShardMaintenanceProgress{shardMaintenanceProgress_last_updated_at = shardMaintenanceProgress_last_updated_at obj} then Nothing else Just $ default_ShardMaintenanceProgress{shardMaintenanceProgress_last_updated_at = shardMaintenanceProgress_last_updated_at obj}
    , if obj == default_ShardMaintenanceProgress{shardMaintenanceProgress_associated_group_ids = shardMaintenanceProgress_associated_group_ids obj} then Nothing else Just $ default_ShardMaintenanceProgress{shardMaintenanceProgress_associated_group_ids = shardMaintenanceProgress_associated_group_ids obj}
    ]
-- | Translate a 'ShardMaintenanceProgress' to a 'Types.ThriftVal'
from_ShardMaintenanceProgress :: ShardMaintenanceProgress -> Types.ThriftVal
from_ShardMaintenanceProgress record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v50 -> Just (1, ("status",Types.TI32 $ fromIntegral $ fromEnum _v50))) $ shardMaintenanceProgress_status record
  , (\_v50 -> Just (2, ("target_states",Types.TSet Types.T_I32 $ map (\_v52 -> Types.TI32 $ fromIntegral $ fromEnum _v52) $ Set.toList _v50))) $ shardMaintenanceProgress_target_states record
  , (\_v50 -> Just (3, ("created_at",Types.TI64 _v50))) $ shardMaintenanceProgress_created_at record
  , (\_v50 -> Just (4, ("last_updated_at",Types.TI64 _v50))) $ shardMaintenanceProgress_last_updated_at record
  , (\_v50 -> Just (5, ("associated_group_ids",Types.TList Types.T_STRING $ map (\_v54 -> Types.TString $ Encoding.encodeUtf8 _v54) $ Vector.toList _v50))) $ shardMaintenanceProgress_associated_group_ids record
  ]
-- | Write a 'ShardMaintenanceProgress' with the given 'Thrift.Protocol'
write_ShardMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardMaintenanceProgress -> IO ()
write_ShardMaintenanceProgress oprot record = Thrift.writeVal oprot $ from_ShardMaintenanceProgress record
-- | Serialize a 'ShardMaintenanceProgress' in pure code
encode_ShardMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardMaintenanceProgress -> BS.ByteString
encode_ShardMaintenanceProgress oprot record = Thrift.serializeVal oprot $ from_ShardMaintenanceProgress record
-- | Translate a 'Types.ThriftVal' to a 'ShardMaintenanceProgress'
to_ShardMaintenanceProgress :: Types.ThriftVal -> ShardMaintenanceProgress
to_ShardMaintenanceProgress (Types.TStruct fields) = ShardMaintenanceProgress{
  shardMaintenanceProgress_status = maybe (shardMaintenanceProgress_status default_ShardMaintenanceProgress) (\(_,_val56) -> (case _val56 of {Types.TI32 _val57 -> toEnum $ fromIntegral _val57; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardMaintenanceProgress_target_states = maybe (shardMaintenanceProgress_target_states default_ShardMaintenanceProgress) (\(_,_val56) -> (case _val56 of {Types.TSet _ _val58 -> (Set.fromList $ map (\_v59 -> (case _v59 of {Types.TI32 _val60 -> toEnum $ fromIntegral _val60; _ -> error "wrong type"})) _val58); _ -> error "wrong type"})) (Map.lookup (2) fields),
  shardMaintenanceProgress_created_at = maybe (shardMaintenanceProgress_created_at default_ShardMaintenanceProgress) (\(_,_val56) -> (case _val56 of {Types.TI64 _val61 -> _val61; _ -> error "wrong type"})) (Map.lookup (3) fields),
  shardMaintenanceProgress_last_updated_at = maybe (shardMaintenanceProgress_last_updated_at default_ShardMaintenanceProgress) (\(_,_val56) -> (case _val56 of {Types.TI64 _val62 -> _val62; _ -> error "wrong type"})) (Map.lookup (4) fields),
  shardMaintenanceProgress_associated_group_ids = maybe (shardMaintenanceProgress_associated_group_ids default_ShardMaintenanceProgress) (\(_,_val56) -> (case _val56 of {Types.TList _ _val63 -> (Vector.fromList $ map (\_v64 -> (case _v64 of {Types.TString _val65 -> Encoding.decodeUtf8 _val65; _ -> error "wrong type"})) _val63); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_ShardMaintenanceProgress _ = error "not a struct"
-- | Read a 'ShardMaintenanceProgress' struct with the given 'Thrift.Protocol'
read_ShardMaintenanceProgress :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardMaintenanceProgress
read_ShardMaintenanceProgress iprot = to_ShardMaintenanceProgress <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardMaintenanceProgress)
-- | Deserialize a 'ShardMaintenanceProgress' in pure code
decode_ShardMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardMaintenanceProgress
decode_ShardMaintenanceProgress iprot bs = to_ShardMaintenanceProgress $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardMaintenanceProgress) bs
-- | 'TypeMap' for the 'ShardMaintenanceProgress' struct
typemap_ShardMaintenanceProgress :: Types.TypeMap
typemap_ShardMaintenanceProgress = Map.fromList [("status",(1,Types.T_I32)),("target_states",(2,(Types.T_SET Types.T_I32))),("created_at",(3,Types.T_I64)),("last_updated_at",(4,Types.T_I64)),("associated_group_ids",(5,(Types.T_LIST Types.T_STRING)))]
-- | Default values for the 'ShardMaintenanceProgress' struct
default_ShardMaintenanceProgress :: ShardMaintenanceProgress
default_ShardMaintenanceProgress = ShardMaintenanceProgress{
  shardMaintenanceProgress_status = (toEnum 0),
  shardMaintenanceProgress_target_states = Set.empty,
  shardMaintenanceProgress_created_at = 0,
  shardMaintenanceProgress_last_updated_at = 0,
  shardMaintenanceProgress_associated_group_ids = Vector.empty}
-- | Definition of the SequencerMaintenanceProgress struct
data SequencerMaintenanceProgress = SequencerMaintenanceProgress
  { sequencerMaintenanceProgress_status :: Nodes_Types.MaintenanceStatus
    -- ^ status field of the SequencerMaintenanceProgress struct
  , sequencerMaintenanceProgress_target_state :: Nodes_Types.SequencingState
    -- ^ target_state field of the SequencerMaintenanceProgress struct
  , sequencerMaintenanceProgress_created_at :: Int.Int64
    -- ^ created_at field of the SequencerMaintenanceProgress struct
  , sequencerMaintenanceProgress_last_updated_at :: Int.Int64
    -- ^ last_updated_at field of the SequencerMaintenanceProgress struct
  , sequencerMaintenanceProgress_associated_group_ids :: (Vector.Vector LT.Text)
    -- ^ associated_group_ids field of the SequencerMaintenanceProgress struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SequencerMaintenanceProgress where
  encode = encode_SequencerMaintenanceProgress
  decode = decode_SequencerMaintenanceProgress
instance Hashable.Hashable SequencerMaintenanceProgress where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` sequencerMaintenanceProgress_status record   `Hashable.hashWithSalt` sequencerMaintenanceProgress_target_state record   `Hashable.hashWithSalt` sequencerMaintenanceProgress_created_at record   `Hashable.hashWithSalt` sequencerMaintenanceProgress_last_updated_at record   `Hashable.hashWithSalt` sequencerMaintenanceProgress_associated_group_ids record  
instance DeepSeq.NFData SequencerMaintenanceProgress where
  rnf _record66 =
    DeepSeq.rnf (sequencerMaintenanceProgress_status _record66) `seq`
    DeepSeq.rnf (sequencerMaintenanceProgress_target_state _record66) `seq`
    DeepSeq.rnf (sequencerMaintenanceProgress_created_at _record66) `seq`
    DeepSeq.rnf (sequencerMaintenanceProgress_last_updated_at _record66) `seq`
    DeepSeq.rnf (sequencerMaintenanceProgress_associated_group_ids _record66) `seq`
    ()
instance Arbitrary.Arbitrary SequencerMaintenanceProgress where 
  arbitrary = Monad.liftM SequencerMaintenanceProgress (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_SequencerMaintenanceProgress = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_status = sequencerMaintenanceProgress_status obj} then Nothing else Just $ default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_status = sequencerMaintenanceProgress_status obj}
    , if obj == default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_target_state = sequencerMaintenanceProgress_target_state obj} then Nothing else Just $ default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_target_state = sequencerMaintenanceProgress_target_state obj}
    , if obj == default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_created_at = sequencerMaintenanceProgress_created_at obj} then Nothing else Just $ default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_created_at = sequencerMaintenanceProgress_created_at obj}
    , if obj == default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_last_updated_at = sequencerMaintenanceProgress_last_updated_at obj} then Nothing else Just $ default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_last_updated_at = sequencerMaintenanceProgress_last_updated_at obj}
    , if obj == default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_associated_group_ids = sequencerMaintenanceProgress_associated_group_ids obj} then Nothing else Just $ default_SequencerMaintenanceProgress{sequencerMaintenanceProgress_associated_group_ids = sequencerMaintenanceProgress_associated_group_ids obj}
    ]
-- | Translate a 'SequencerMaintenanceProgress' to a 'Types.ThriftVal'
from_SequencerMaintenanceProgress :: SequencerMaintenanceProgress -> Types.ThriftVal
from_SequencerMaintenanceProgress record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v69 -> Just (1, ("status",Types.TI32 $ fromIntegral $ fromEnum _v69))) $ sequencerMaintenanceProgress_status record
  , (\_v69 -> Just (2, ("target_state",Types.TI32 $ fromIntegral $ fromEnum _v69))) $ sequencerMaintenanceProgress_target_state record
  , (\_v69 -> Just (3, ("created_at",Types.TI64 _v69))) $ sequencerMaintenanceProgress_created_at record
  , (\_v69 -> Just (4, ("last_updated_at",Types.TI64 _v69))) $ sequencerMaintenanceProgress_last_updated_at record
  , (\_v69 -> Just (5, ("associated_group_ids",Types.TList Types.T_STRING $ map (\_v71 -> Types.TString $ Encoding.encodeUtf8 _v71) $ Vector.toList _v69))) $ sequencerMaintenanceProgress_associated_group_ids record
  ]
-- | Write a 'SequencerMaintenanceProgress' with the given 'Thrift.Protocol'
write_SequencerMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerMaintenanceProgress -> IO ()
write_SequencerMaintenanceProgress oprot record = Thrift.writeVal oprot $ from_SequencerMaintenanceProgress record
-- | Serialize a 'SequencerMaintenanceProgress' in pure code
encode_SequencerMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerMaintenanceProgress -> BS.ByteString
encode_SequencerMaintenanceProgress oprot record = Thrift.serializeVal oprot $ from_SequencerMaintenanceProgress record
-- | Translate a 'Types.ThriftVal' to a 'SequencerMaintenanceProgress'
to_SequencerMaintenanceProgress :: Types.ThriftVal -> SequencerMaintenanceProgress
to_SequencerMaintenanceProgress (Types.TStruct fields) = SequencerMaintenanceProgress{
  sequencerMaintenanceProgress_status = maybe (sequencerMaintenanceProgress_status default_SequencerMaintenanceProgress) (\(_,_val73) -> (case _val73 of {Types.TI32 _val74 -> toEnum $ fromIntegral _val74; _ -> error "wrong type"})) (Map.lookup (1) fields),
  sequencerMaintenanceProgress_target_state = maybe (sequencerMaintenanceProgress_target_state default_SequencerMaintenanceProgress) (\(_,_val73) -> (case _val73 of {Types.TI32 _val75 -> toEnum $ fromIntegral _val75; _ -> error "wrong type"})) (Map.lookup (2) fields),
  sequencerMaintenanceProgress_created_at = maybe (sequencerMaintenanceProgress_created_at default_SequencerMaintenanceProgress) (\(_,_val73) -> (case _val73 of {Types.TI64 _val76 -> _val76; _ -> error "wrong type"})) (Map.lookup (3) fields),
  sequencerMaintenanceProgress_last_updated_at = maybe (sequencerMaintenanceProgress_last_updated_at default_SequencerMaintenanceProgress) (\(_,_val73) -> (case _val73 of {Types.TI64 _val77 -> _val77; _ -> error "wrong type"})) (Map.lookup (4) fields),
  sequencerMaintenanceProgress_associated_group_ids = maybe (sequencerMaintenanceProgress_associated_group_ids default_SequencerMaintenanceProgress) (\(_,_val73) -> (case _val73 of {Types.TList _ _val78 -> (Vector.fromList $ map (\_v79 -> (case _v79 of {Types.TString _val80 -> Encoding.decodeUtf8 _val80; _ -> error "wrong type"})) _val78); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_SequencerMaintenanceProgress _ = error "not a struct"
-- | Read a 'SequencerMaintenanceProgress' struct with the given 'Thrift.Protocol'
read_SequencerMaintenanceProgress :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SequencerMaintenanceProgress
read_SequencerMaintenanceProgress iprot = to_SequencerMaintenanceProgress <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SequencerMaintenanceProgress)
-- | Deserialize a 'SequencerMaintenanceProgress' in pure code
decode_SequencerMaintenanceProgress :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SequencerMaintenanceProgress
decode_SequencerMaintenanceProgress iprot bs = to_SequencerMaintenanceProgress $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SequencerMaintenanceProgress) bs
-- | 'TypeMap' for the 'SequencerMaintenanceProgress' struct
typemap_SequencerMaintenanceProgress :: Types.TypeMap
typemap_SequencerMaintenanceProgress = Map.fromList [("status",(1,Types.T_I32)),("target_state",(2,Types.T_I32)),("created_at",(3,Types.T_I64)),("last_updated_at",(4,Types.T_I64)),("associated_group_ids",(5,(Types.T_LIST Types.T_STRING)))]
-- | Default values for the 'SequencerMaintenanceProgress' struct
default_SequencerMaintenanceProgress :: SequencerMaintenanceProgress
default_SequencerMaintenanceProgress = SequencerMaintenanceProgress{
  sequencerMaintenanceProgress_status = (toEnum 0),
  sequencerMaintenanceProgress_target_state = (toEnum 0),
  sequencerMaintenanceProgress_created_at = 0,
  sequencerMaintenanceProgress_last_updated_at = 0,
  sequencerMaintenanceProgress_associated_group_ids = Vector.empty}
-- | Definition of the ShardState struct
data ShardState = ShardState
  { shardState_data_health :: Nodes_Types.ShardDataHealth
    -- ^ data_health field of the ShardState struct
  , shardState_current_operational_state :: Nodes_Types.ShardOperationalState
    -- ^ current_operational_state field of the ShardState struct
  , shardState_maintenance :: Maybe Nodes_Types.ShardMaintenanceProgress
    -- ^ maintenance field of the ShardState struct
  , shardState_storage_state :: Membership_Types.StorageState
    -- ^ storage_state field of the ShardState struct
  , shardState_metadata_state :: Membership_Types.MetaDataStorageState
    -- ^ metadata_state field of the ShardState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardState where
  encode = encode_ShardState
  decode = decode_ShardState
instance Hashable.Hashable ShardState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardState_data_health record   `Hashable.hashWithSalt` shardState_current_operational_state record   `Hashable.hashWithSalt` shardState_maintenance record   `Hashable.hashWithSalt` shardState_storage_state record   `Hashable.hashWithSalt` shardState_metadata_state record  
instance DeepSeq.NFData ShardState where
  rnf _record81 =
    DeepSeq.rnf (shardState_data_health _record81) `seq`
    DeepSeq.rnf (shardState_current_operational_state _record81) `seq`
    DeepSeq.rnf (shardState_maintenance _record81) `seq`
    DeepSeq.rnf (shardState_storage_state _record81) `seq`
    DeepSeq.rnf (shardState_metadata_state _record81) `seq`
    ()
instance Arbitrary.Arbitrary ShardState where 
  arbitrary = Monad.liftM ShardState (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardState{shardState_data_health = shardState_data_health obj} then Nothing else Just $ default_ShardState{shardState_data_health = shardState_data_health obj}
    , if obj == default_ShardState{shardState_current_operational_state = shardState_current_operational_state obj} then Nothing else Just $ default_ShardState{shardState_current_operational_state = shardState_current_operational_state obj}
    , if obj == default_ShardState{shardState_maintenance = shardState_maintenance obj} then Nothing else Just $ default_ShardState{shardState_maintenance = shardState_maintenance obj}
    , if obj == default_ShardState{shardState_storage_state = shardState_storage_state obj} then Nothing else Just $ default_ShardState{shardState_storage_state = shardState_storage_state obj}
    , if obj == default_ShardState{shardState_metadata_state = shardState_metadata_state obj} then Nothing else Just $ default_ShardState{shardState_metadata_state = shardState_metadata_state obj}
    ]
-- | Translate a 'ShardState' to a 'Types.ThriftVal'
from_ShardState :: ShardState -> Types.ThriftVal
from_ShardState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v84 -> Just (1, ("data_health",Types.TI32 $ fromIntegral $ fromEnum _v84))) $ shardState_data_health record
  , (\_v84 -> Just (3, ("current_operational_state",Types.TI32 $ fromIntegral $ fromEnum _v84))) $ shardState_current_operational_state record
  , (\_v84 -> (4, ("maintenance",Nodes_Types.from_ShardMaintenanceProgress _v84))) <$> shardState_maintenance record
  , (\_v84 -> Just (5, ("storage_state",Types.TI32 $ fromIntegral $ fromEnum _v84))) $ shardState_storage_state record
  , (\_v84 -> Just (6, ("metadata_state",Types.TI32 $ fromIntegral $ fromEnum _v84))) $ shardState_metadata_state record
  ]
-- | Write a 'ShardState' with the given 'Thrift.Protocol'
write_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardState -> IO ()
write_ShardState oprot record = Thrift.writeVal oprot $ from_ShardState record
-- | Serialize a 'ShardState' in pure code
encode_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardState -> BS.ByteString
encode_ShardState oprot record = Thrift.serializeVal oprot $ from_ShardState record
-- | Translate a 'Types.ThriftVal' to a 'ShardState'
to_ShardState :: Types.ThriftVal -> ShardState
to_ShardState (Types.TStruct fields) = ShardState{
  shardState_data_health = maybe (shardState_data_health default_ShardState) (\(_,_val86) -> (case _val86 of {Types.TI32 _val87 -> toEnum $ fromIntegral _val87; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardState_current_operational_state = maybe (shardState_current_operational_state default_ShardState) (\(_,_val86) -> (case _val86 of {Types.TI32 _val88 -> toEnum $ fromIntegral _val88; _ -> error "wrong type"})) (Map.lookup (3) fields),
  shardState_maintenance = maybe (Nothing) (\(_,_val86) -> Just (case _val86 of {Types.TStruct _val89 -> (Nodes_Types.to_ShardMaintenanceProgress (Types.TStruct _val89)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  shardState_storage_state = maybe (shardState_storage_state default_ShardState) (\(_,_val86) -> (case _val86 of {Types.TI32 _val90 -> toEnum $ fromIntegral _val90; _ -> error "wrong type"})) (Map.lookup (5) fields),
  shardState_metadata_state = maybe (shardState_metadata_state default_ShardState) (\(_,_val86) -> (case _val86 of {Types.TI32 _val91 -> toEnum $ fromIntegral _val91; _ -> error "wrong type"})) (Map.lookup (6) fields)
  }
to_ShardState _ = error "not a struct"
-- | Read a 'ShardState' struct with the given 'Thrift.Protocol'
read_ShardState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardState
read_ShardState iprot = to_ShardState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardState)
-- | Deserialize a 'ShardState' in pure code
decode_ShardState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardState
decode_ShardState iprot bs = to_ShardState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardState) bs
-- | 'TypeMap' for the 'ShardState' struct
typemap_ShardState :: Types.TypeMap
typemap_ShardState = Map.fromList [("data_health",(1,Types.T_I32)),("current_operational_state",(3,Types.T_I32)),("maintenance",(4,(Types.T_STRUCT Nodes_Types.typemap_ShardMaintenanceProgress))),("storage_state",(5,Types.T_I32)),("metadata_state",(6,Types.T_I32))]
-- | Default values for the 'ShardState' struct
default_ShardState :: ShardState
default_ShardState = ShardState{
  shardState_data_health = (toEnum 0),
  shardState_current_operational_state = (toEnum 0),
  shardState_maintenance = Nothing,
  shardState_storage_state = (toEnum 0),
  shardState_metadata_state = (toEnum 0)}
-- | Definition of the SequencerState struct
data SequencerState = SequencerState
  { sequencerState_state :: Nodes_Types.SequencingState
    -- ^ state field of the SequencerState struct
  , sequencerState_maintenance :: Maybe Nodes_Types.SequencerMaintenanceProgress
    -- ^ maintenance field of the SequencerState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SequencerState where
  encode = encode_SequencerState
  decode = decode_SequencerState
instance Hashable.Hashable SequencerState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` sequencerState_state record   `Hashable.hashWithSalt` sequencerState_maintenance record  
instance DeepSeq.NFData SequencerState where
  rnf _record92 =
    DeepSeq.rnf (sequencerState_state _record92) `seq`
    DeepSeq.rnf (sequencerState_maintenance _record92) `seq`
    ()
instance Arbitrary.Arbitrary SequencerState where 
  arbitrary = Monad.liftM SequencerState (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_SequencerState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SequencerState{sequencerState_state = sequencerState_state obj} then Nothing else Just $ default_SequencerState{sequencerState_state = sequencerState_state obj}
    , if obj == default_SequencerState{sequencerState_maintenance = sequencerState_maintenance obj} then Nothing else Just $ default_SequencerState{sequencerState_maintenance = sequencerState_maintenance obj}
    ]
-- | Translate a 'SequencerState' to a 'Types.ThriftVal'
from_SequencerState :: SequencerState -> Types.ThriftVal
from_SequencerState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v95 -> Just (1, ("state",Types.TI32 $ fromIntegral $ fromEnum _v95))) $ sequencerState_state record
  , (\_v95 -> (3, ("maintenance",Nodes_Types.from_SequencerMaintenanceProgress _v95))) <$> sequencerState_maintenance record
  ]
-- | Write a 'SequencerState' with the given 'Thrift.Protocol'
write_SequencerState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerState -> IO ()
write_SequencerState oprot record = Thrift.writeVal oprot $ from_SequencerState record
-- | Serialize a 'SequencerState' in pure code
encode_SequencerState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SequencerState -> BS.ByteString
encode_SequencerState oprot record = Thrift.serializeVal oprot $ from_SequencerState record
-- | Translate a 'Types.ThriftVal' to a 'SequencerState'
to_SequencerState :: Types.ThriftVal -> SequencerState
to_SequencerState (Types.TStruct fields) = SequencerState{
  sequencerState_state = maybe (sequencerState_state default_SequencerState) (\(_,_val97) -> (case _val97 of {Types.TI32 _val98 -> toEnum $ fromIntegral _val98; _ -> error "wrong type"})) (Map.lookup (1) fields),
  sequencerState_maintenance = maybe (Nothing) (\(_,_val97) -> Just (case _val97 of {Types.TStruct _val99 -> (Nodes_Types.to_SequencerMaintenanceProgress (Types.TStruct _val99)); _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_SequencerState _ = error "not a struct"
-- | Read a 'SequencerState' struct with the given 'Thrift.Protocol'
read_SequencerState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SequencerState
read_SequencerState iprot = to_SequencerState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SequencerState)
-- | Deserialize a 'SequencerState' in pure code
decode_SequencerState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SequencerState
decode_SequencerState iprot bs = to_SequencerState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SequencerState) bs
-- | 'TypeMap' for the 'SequencerState' struct
typemap_SequencerState :: Types.TypeMap
typemap_SequencerState = Map.fromList [("state",(1,Types.T_I32)),("maintenance",(3,(Types.T_STRUCT Nodes_Types.typemap_SequencerMaintenanceProgress)))]
-- | Default values for the 'SequencerState' struct
default_SequencerState :: SequencerState
default_SequencerState = SequencerState{
  sequencerState_state = (toEnum 0),
  sequencerState_maintenance = Nothing}
-- | Definition of the NodeState struct
data NodeState = NodeState
  { nodeState_node_index :: Int.Int16
    -- ^ node_index field of the NodeState struct
  , nodeState_daemon_state :: Nodes_Types.ServiceState
    -- ^ daemon_state field of the NodeState struct
  , nodeState_sequencer_state :: Maybe Nodes_Types.SequencerState
    -- ^ sequencer_state field of the NodeState struct
  , nodeState_shard_states :: Maybe (Vector.Vector Nodes_Types.ShardState)
    -- ^ shard_states field of the NodeState struct
  , nodeState_config :: Nodes_Types.NodeConfig
    -- ^ config field of the NodeState struct
  , nodeState_daemon_health_status :: Nodes_Types.ServiceHealthStatus
    -- ^ daemon_health_status field of the NodeState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodeState where
  encode = encode_NodeState
  decode = decode_NodeState
instance Hashable.Hashable NodeState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodeState_node_index record   `Hashable.hashWithSalt` nodeState_daemon_state record   `Hashable.hashWithSalt` nodeState_sequencer_state record   `Hashable.hashWithSalt` nodeState_shard_states record   `Hashable.hashWithSalt` nodeState_config record   `Hashable.hashWithSalt` nodeState_daemon_health_status record  
instance DeepSeq.NFData NodeState where
  rnf _record100 =
    DeepSeq.rnf (nodeState_node_index _record100) `seq`
    DeepSeq.rnf (nodeState_daemon_state _record100) `seq`
    DeepSeq.rnf (nodeState_sequencer_state _record100) `seq`
    DeepSeq.rnf (nodeState_shard_states _record100) `seq`
    DeepSeq.rnf (nodeState_config _record100) `seq`
    DeepSeq.rnf (nodeState_daemon_health_status _record100) `seq`
    ()
instance Arbitrary.Arbitrary NodeState where 
  arbitrary = Monad.liftM NodeState (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_NodeState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodeState{nodeState_node_index = nodeState_node_index obj} then Nothing else Just $ default_NodeState{nodeState_node_index = nodeState_node_index obj}
    , if obj == default_NodeState{nodeState_daemon_state = nodeState_daemon_state obj} then Nothing else Just $ default_NodeState{nodeState_daemon_state = nodeState_daemon_state obj}
    , if obj == default_NodeState{nodeState_sequencer_state = nodeState_sequencer_state obj} then Nothing else Just $ default_NodeState{nodeState_sequencer_state = nodeState_sequencer_state obj}
    , if obj == default_NodeState{nodeState_shard_states = nodeState_shard_states obj} then Nothing else Just $ default_NodeState{nodeState_shard_states = nodeState_shard_states obj}
    , if obj == default_NodeState{nodeState_config = nodeState_config obj} then Nothing else Just $ default_NodeState{nodeState_config = nodeState_config obj}
    , if obj == default_NodeState{nodeState_daemon_health_status = nodeState_daemon_health_status obj} then Nothing else Just $ default_NodeState{nodeState_daemon_health_status = nodeState_daemon_health_status obj}
    ]
-- | Translate a 'NodeState' to a 'Types.ThriftVal'
from_NodeState :: NodeState -> Types.ThriftVal
from_NodeState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v103 -> Just (1, ("node_index",Types.TI16 _v103))) $ nodeState_node_index record
  , (\_v103 -> Just (2, ("daemon_state",Types.TI32 $ fromIntegral $ fromEnum _v103))) $ nodeState_daemon_state record
  , (\_v103 -> (3, ("sequencer_state",Nodes_Types.from_SequencerState _v103))) <$> nodeState_sequencer_state record
  , (\_v103 -> (4, ("shard_states",Types.TList (Types.T_STRUCT Nodes_Types.typemap_ShardState) $ map (\_v105 -> Nodes_Types.from_ShardState _v105) $ Vector.toList _v103))) <$> nodeState_shard_states record
  , (\_v103 -> Just (5, ("config",Nodes_Types.from_NodeConfig _v103))) $ nodeState_config record
  , (\_v103 -> Just (6, ("daemon_health_status",Types.TI32 $ fromIntegral $ fromEnum _v103))) $ nodeState_daemon_health_status record
  ]
-- | Write a 'NodeState' with the given 'Thrift.Protocol'
write_NodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeState -> IO ()
write_NodeState oprot record = Thrift.writeVal oprot $ from_NodeState record
-- | Serialize a 'NodeState' in pure code
encode_NodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodeState -> BS.ByteString
encode_NodeState oprot record = Thrift.serializeVal oprot $ from_NodeState record
-- | Translate a 'Types.ThriftVal' to a 'NodeState'
to_NodeState :: Types.ThriftVal -> NodeState
to_NodeState (Types.TStruct fields) = NodeState{
  nodeState_node_index = maybe (nodeState_node_index default_NodeState) (\(_,_val107) -> (case _val107 of {Types.TI16 _val108 -> _val108; _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodeState_daemon_state = maybe (nodeState_daemon_state default_NodeState) (\(_,_val107) -> (case _val107 of {Types.TI32 _val109 -> toEnum $ fromIntegral _val109; _ -> error "wrong type"})) (Map.lookup (2) fields),
  nodeState_sequencer_state = maybe (Nothing) (\(_,_val107) -> Just (case _val107 of {Types.TStruct _val110 -> (Nodes_Types.to_SequencerState (Types.TStruct _val110)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  nodeState_shard_states = maybe (Nothing) (\(_,_val107) -> Just (case _val107 of {Types.TList _ _val111 -> (Vector.fromList $ map (\_v112 -> (case _v112 of {Types.TStruct _val113 -> (Nodes_Types.to_ShardState (Types.TStruct _val113)); _ -> error "wrong type"})) _val111); _ -> error "wrong type"})) (Map.lookup (4) fields),
  nodeState_config = maybe (nodeState_config default_NodeState) (\(_,_val107) -> (case _val107 of {Types.TStruct _val114 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val114)); _ -> error "wrong type"})) (Map.lookup (5) fields),
  nodeState_daemon_health_status = maybe (nodeState_daemon_health_status default_NodeState) (\(_,_val107) -> (case _val107 of {Types.TI32 _val115 -> toEnum $ fromIntegral _val115; _ -> error "wrong type"})) (Map.lookup (6) fields)
  }
to_NodeState _ = error "not a struct"
-- | Read a 'NodeState' struct with the given 'Thrift.Protocol'
read_NodeState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodeState
read_NodeState iprot = to_NodeState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodeState)
-- | Deserialize a 'NodeState' in pure code
decode_NodeState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodeState
decode_NodeState iprot bs = to_NodeState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodeState) bs
-- | 'TypeMap' for the 'NodeState' struct
typemap_NodeState :: Types.TypeMap
typemap_NodeState = Map.fromList [("node_index",(1,Types.T_I16)),("daemon_state",(2,Types.T_I32)),("sequencer_state",(3,(Types.T_STRUCT Nodes_Types.typemap_SequencerState))),("shard_states",(4,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_ShardState)))),("config",(5,(Types.T_STRUCT Nodes_Types.typemap_NodeConfig))),("daemon_health_status",(6,Types.T_I32))]
-- | Default values for the 'NodeState' struct
default_NodeState :: NodeState
default_NodeState = NodeState{
  nodeState_node_index = 0,
  nodeState_daemon_state = Nodes_Types.UNKNOWN,
  nodeState_sequencer_state = Nothing,
  nodeState_shard_states = Nothing,
  nodeState_config = Nodes_Types.default_NodeConfig,
  nodeState_daemon_health_status = Nodes_Types.UNKNOWN}
-- | Definition of the NodesFilter struct
data NodesFilter = NodesFilter
  { nodesFilter_node :: Maybe Common_Types.NodeID
    -- ^ node field of the NodesFilter struct
  , nodesFilter_role :: Maybe Common_Types.Role
    -- ^ role field of the NodesFilter struct
  , nodesFilter_location :: Maybe LT.Text
    -- ^ location field of the NodesFilter struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodesFilter where
  encode = encode_NodesFilter
  decode = decode_NodesFilter
instance Hashable.Hashable NodesFilter where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodesFilter_node record   `Hashable.hashWithSalt` nodesFilter_role record   `Hashable.hashWithSalt` nodesFilter_location record  
instance DeepSeq.NFData NodesFilter where
  rnf _record116 =
    DeepSeq.rnf (nodesFilter_node _record116) `seq`
    DeepSeq.rnf (nodesFilter_role _record116) `seq`
    DeepSeq.rnf (nodesFilter_location _record116) `seq`
    ()
instance Arbitrary.Arbitrary NodesFilter where 
  arbitrary = Monad.liftM NodesFilter (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_NodesFilter = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodesFilter{nodesFilter_node = nodesFilter_node obj} then Nothing else Just $ default_NodesFilter{nodesFilter_node = nodesFilter_node obj}
    , if obj == default_NodesFilter{nodesFilter_role = nodesFilter_role obj} then Nothing else Just $ default_NodesFilter{nodesFilter_role = nodesFilter_role obj}
    , if obj == default_NodesFilter{nodesFilter_location = nodesFilter_location obj} then Nothing else Just $ default_NodesFilter{nodesFilter_location = nodesFilter_location obj}
    ]
-- | Translate a 'NodesFilter' to a 'Types.ThriftVal'
from_NodesFilter :: NodesFilter -> Types.ThriftVal
from_NodesFilter record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v119 -> (1, ("node",Common_Types.from_NodeID _v119))) <$> nodesFilter_node record
  , (\_v119 -> (2, ("role",Types.TI32 $ fromIntegral $ fromEnum _v119))) <$> nodesFilter_role record
  , (\_v119 -> (3, ("location",Types.TString $ Encoding.encodeUtf8 _v119))) <$> nodesFilter_location record
  ]
-- | Write a 'NodesFilter' with the given 'Thrift.Protocol'
write_NodesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesFilter -> IO ()
write_NodesFilter oprot record = Thrift.writeVal oprot $ from_NodesFilter record
-- | Serialize a 'NodesFilter' in pure code
encode_NodesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesFilter -> BS.ByteString
encode_NodesFilter oprot record = Thrift.serializeVal oprot $ from_NodesFilter record
-- | Translate a 'Types.ThriftVal' to a 'NodesFilter'
to_NodesFilter :: Types.ThriftVal -> NodesFilter
to_NodesFilter (Types.TStruct fields) = NodesFilter{
  nodesFilter_node = maybe (Nothing) (\(_,_val121) -> Just (case _val121 of {Types.TStruct _val122 -> (Common_Types.to_NodeID (Types.TStruct _val122)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodesFilter_role = maybe (Nothing) (\(_,_val121) -> Just (case _val121 of {Types.TI32 _val123 -> toEnum $ fromIntegral _val123; _ -> error "wrong type"})) (Map.lookup (2) fields),
  nodesFilter_location = maybe (Nothing) (\(_,_val121) -> Just (case _val121 of {Types.TString _val124 -> Encoding.decodeUtf8 _val124; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_NodesFilter _ = error "not a struct"
-- | Read a 'NodesFilter' struct with the given 'Thrift.Protocol'
read_NodesFilter :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodesFilter
read_NodesFilter iprot = to_NodesFilter <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodesFilter)
-- | Deserialize a 'NodesFilter' in pure code
decode_NodesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodesFilter
decode_NodesFilter iprot bs = to_NodesFilter $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodesFilter) bs
-- | 'TypeMap' for the 'NodesFilter' struct
typemap_NodesFilter :: Types.TypeMap
typemap_NodesFilter = Map.fromList [("node",(1,(Types.T_STRUCT Common_Types.typemap_NodeID))),("role",(2,Types.T_I32)),("location",(3,Types.T_STRING))]
-- | Default values for the 'NodesFilter' struct
default_NodesFilter :: NodesFilter
default_NodesFilter = NodesFilter{
  nodesFilter_node = Nothing,
  nodesFilter_role = Nothing,
  nodesFilter_location = Nothing}
-- | Definition of the NodesConfigResponse struct
data NodesConfigResponse = NodesConfigResponse
  { nodesConfigResponse_nodes :: (Vector.Vector Nodes_Types.NodeConfig)
    -- ^ nodes field of the NodesConfigResponse struct
  , nodesConfigResponse_version :: Int.Int64
    -- ^ version field of the NodesConfigResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodesConfigResponse where
  encode = encode_NodesConfigResponse
  decode = decode_NodesConfigResponse
instance Hashable.Hashable NodesConfigResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodesConfigResponse_nodes record   `Hashable.hashWithSalt` nodesConfigResponse_version record  
instance DeepSeq.NFData NodesConfigResponse where
  rnf _record125 =
    DeepSeq.rnf (nodesConfigResponse_nodes _record125) `seq`
    DeepSeq.rnf (nodesConfigResponse_version _record125) `seq`
    ()
instance Arbitrary.Arbitrary NodesConfigResponse where 
  arbitrary = Monad.liftM NodesConfigResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_NodesConfigResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodesConfigResponse{nodesConfigResponse_nodes = nodesConfigResponse_nodes obj} then Nothing else Just $ default_NodesConfigResponse{nodesConfigResponse_nodes = nodesConfigResponse_nodes obj}
    , if obj == default_NodesConfigResponse{nodesConfigResponse_version = nodesConfigResponse_version obj} then Nothing else Just $ default_NodesConfigResponse{nodesConfigResponse_version = nodesConfigResponse_version obj}
    ]
-- | Translate a 'NodesConfigResponse' to a 'Types.ThriftVal'
from_NodesConfigResponse :: NodesConfigResponse -> Types.ThriftVal
from_NodesConfigResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v128 -> Just (1, ("nodes",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodeConfig) $ map (\_v130 -> Nodes_Types.from_NodeConfig _v130) $ Vector.toList _v128))) $ nodesConfigResponse_nodes record
  , (\_v128 -> Just (2, ("version",Types.TI64 _v128))) $ nodesConfigResponse_version record
  ]
-- | Write a 'NodesConfigResponse' with the given 'Thrift.Protocol'
write_NodesConfigResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesConfigResponse -> IO ()
write_NodesConfigResponse oprot record = Thrift.writeVal oprot $ from_NodesConfigResponse record
-- | Serialize a 'NodesConfigResponse' in pure code
encode_NodesConfigResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesConfigResponse -> BS.ByteString
encode_NodesConfigResponse oprot record = Thrift.serializeVal oprot $ from_NodesConfigResponse record
-- | Translate a 'Types.ThriftVal' to a 'NodesConfigResponse'
to_NodesConfigResponse :: Types.ThriftVal -> NodesConfigResponse
to_NodesConfigResponse (Types.TStruct fields) = NodesConfigResponse{
  nodesConfigResponse_nodes = maybe (nodesConfigResponse_nodes default_NodesConfigResponse) (\(_,_val132) -> (case _val132 of {Types.TList _ _val133 -> (Vector.fromList $ map (\_v134 -> (case _v134 of {Types.TStruct _val135 -> (Nodes_Types.to_NodeConfig (Types.TStruct _val135)); _ -> error "wrong type"})) _val133); _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodesConfigResponse_version = maybe (nodesConfigResponse_version default_NodesConfigResponse) (\(_,_val132) -> (case _val132 of {Types.TI64 _val136 -> _val136; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_NodesConfigResponse _ = error "not a struct"
-- | Read a 'NodesConfigResponse' struct with the given 'Thrift.Protocol'
read_NodesConfigResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodesConfigResponse
read_NodesConfigResponse iprot = to_NodesConfigResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodesConfigResponse)
-- | Deserialize a 'NodesConfigResponse' in pure code
decode_NodesConfigResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodesConfigResponse
decode_NodesConfigResponse iprot bs = to_NodesConfigResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodesConfigResponse) bs
-- | 'TypeMap' for the 'NodesConfigResponse' struct
typemap_NodesConfigResponse :: Types.TypeMap
typemap_NodesConfigResponse = Map.fromList [("nodes",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodeConfig)))),("version",(2,Types.T_I64))]
-- | Default values for the 'NodesConfigResponse' struct
default_NodesConfigResponse :: NodesConfigResponse
default_NodesConfigResponse = NodesConfigResponse{
  nodesConfigResponse_nodes = Vector.empty,
  nodesConfigResponse_version = 0}
-- | Definition of the NodesStateResponse struct
data NodesStateResponse = NodesStateResponse
  { nodesStateResponse_states :: (Vector.Vector Nodes_Types.NodeState)
    -- ^ states field of the NodesStateResponse struct
  , nodesStateResponse_version :: Int.Int64
    -- ^ version field of the NodesStateResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodesStateResponse where
  encode = encode_NodesStateResponse
  decode = decode_NodesStateResponse
instance Hashable.Hashable NodesStateResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodesStateResponse_states record   `Hashable.hashWithSalt` nodesStateResponse_version record  
instance DeepSeq.NFData NodesStateResponse where
  rnf _record137 =
    DeepSeq.rnf (nodesStateResponse_states _record137) `seq`
    DeepSeq.rnf (nodesStateResponse_version _record137) `seq`
    ()
instance Arbitrary.Arbitrary NodesStateResponse where 
  arbitrary = Monad.liftM NodesStateResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_NodesStateResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodesStateResponse{nodesStateResponse_states = nodesStateResponse_states obj} then Nothing else Just $ default_NodesStateResponse{nodesStateResponse_states = nodesStateResponse_states obj}
    , if obj == default_NodesStateResponse{nodesStateResponse_version = nodesStateResponse_version obj} then Nothing else Just $ default_NodesStateResponse{nodesStateResponse_version = nodesStateResponse_version obj}
    ]
-- | Translate a 'NodesStateResponse' to a 'Types.ThriftVal'
from_NodesStateResponse :: NodesStateResponse -> Types.ThriftVal
from_NodesStateResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v140 -> Just (1, ("states",Types.TList (Types.T_STRUCT Nodes_Types.typemap_NodeState) $ map (\_v142 -> Nodes_Types.from_NodeState _v142) $ Vector.toList _v140))) $ nodesStateResponse_states record
  , (\_v140 -> Just (2, ("version",Types.TI64 _v140))) $ nodesStateResponse_version record
  ]
-- | Write a 'NodesStateResponse' with the given 'Thrift.Protocol'
write_NodesStateResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesStateResponse -> IO ()
write_NodesStateResponse oprot record = Thrift.writeVal oprot $ from_NodesStateResponse record
-- | Serialize a 'NodesStateResponse' in pure code
encode_NodesStateResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesStateResponse -> BS.ByteString
encode_NodesStateResponse oprot record = Thrift.serializeVal oprot $ from_NodesStateResponse record
-- | Translate a 'Types.ThriftVal' to a 'NodesStateResponse'
to_NodesStateResponse :: Types.ThriftVal -> NodesStateResponse
to_NodesStateResponse (Types.TStruct fields) = NodesStateResponse{
  nodesStateResponse_states = maybe (nodesStateResponse_states default_NodesStateResponse) (\(_,_val144) -> (case _val144 of {Types.TList _ _val145 -> (Vector.fromList $ map (\_v146 -> (case _v146 of {Types.TStruct _val147 -> (Nodes_Types.to_NodeState (Types.TStruct _val147)); _ -> error "wrong type"})) _val145); _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodesStateResponse_version = maybe (nodesStateResponse_version default_NodesStateResponse) (\(_,_val144) -> (case _val144 of {Types.TI64 _val148 -> _val148; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_NodesStateResponse _ = error "not a struct"
-- | Read a 'NodesStateResponse' struct with the given 'Thrift.Protocol'
read_NodesStateResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodesStateResponse
read_NodesStateResponse iprot = to_NodesStateResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodesStateResponse)
-- | Deserialize a 'NodesStateResponse' in pure code
decode_NodesStateResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodesStateResponse
decode_NodesStateResponse iprot bs = to_NodesStateResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodesStateResponse) bs
-- | 'TypeMap' for the 'NodesStateResponse' struct
typemap_NodesStateResponse :: Types.TypeMap
typemap_NodesStateResponse = Map.fromList [("states",(1,(Types.T_LIST (Types.T_STRUCT Nodes_Types.typemap_NodeState)))),("version",(2,Types.T_I64))]
-- | Default values for the 'NodesStateResponse' struct
default_NodesStateResponse :: NodesStateResponse
default_NodesStateResponse = NodesStateResponse{
  nodesStateResponse_states = Vector.empty,
  nodesStateResponse_version = 0}
-- | Definition of the NodesStateRequest struct
data NodesStateRequest = NodesStateRequest
  { nodesStateRequest_filter :: Maybe Nodes_Types.NodesFilter
    -- ^ filter field of the NodesStateRequest struct
  , nodesStateRequest_force :: Maybe Bool
    -- ^ force field of the NodesStateRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable NodesStateRequest where
  encode = encode_NodesStateRequest
  decode = decode_NodesStateRequest
instance Hashable.Hashable NodesStateRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` nodesStateRequest_filter record   `Hashable.hashWithSalt` nodesStateRequest_force record  
instance DeepSeq.NFData NodesStateRequest where
  rnf _record149 =
    DeepSeq.rnf (nodesStateRequest_filter _record149) `seq`
    DeepSeq.rnf (nodesStateRequest_force _record149) `seq`
    ()
instance Arbitrary.Arbitrary NodesStateRequest where 
  arbitrary = Monad.liftM NodesStateRequest (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_NodesStateRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_NodesStateRequest{nodesStateRequest_filter = nodesStateRequest_filter obj} then Nothing else Just $ default_NodesStateRequest{nodesStateRequest_filter = nodesStateRequest_filter obj}
    , if obj == default_NodesStateRequest{nodesStateRequest_force = nodesStateRequest_force obj} then Nothing else Just $ default_NodesStateRequest{nodesStateRequest_force = nodesStateRequest_force obj}
    ]
-- | Translate a 'NodesStateRequest' to a 'Types.ThriftVal'
from_NodesStateRequest :: NodesStateRequest -> Types.ThriftVal
from_NodesStateRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v152 -> (1, ("filter",Nodes_Types.from_NodesFilter _v152))) <$> nodesStateRequest_filter record
  , (\_v152 -> (2, ("force",Types.TBool _v152))) <$> nodesStateRequest_force record
  ]
-- | Write a 'NodesStateRequest' with the given 'Thrift.Protocol'
write_NodesStateRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesStateRequest -> IO ()
write_NodesStateRequest oprot record = Thrift.writeVal oprot $ from_NodesStateRequest record
-- | Serialize a 'NodesStateRequest' in pure code
encode_NodesStateRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> NodesStateRequest -> BS.ByteString
encode_NodesStateRequest oprot record = Thrift.serializeVal oprot $ from_NodesStateRequest record
-- | Translate a 'Types.ThriftVal' to a 'NodesStateRequest'
to_NodesStateRequest :: Types.ThriftVal -> NodesStateRequest
to_NodesStateRequest (Types.TStruct fields) = NodesStateRequest{
  nodesStateRequest_filter = maybe (Nothing) (\(_,_val154) -> Just (case _val154 of {Types.TStruct _val155 -> (Nodes_Types.to_NodesFilter (Types.TStruct _val155)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  nodesStateRequest_force = maybe (Nothing) (\(_,_val154) -> Just (case _val154 of {Types.TBool _val156 -> _val156; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_NodesStateRequest _ = error "not a struct"
-- | Read a 'NodesStateRequest' struct with the given 'Thrift.Protocol'
read_NodesStateRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO NodesStateRequest
read_NodesStateRequest iprot = to_NodesStateRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_NodesStateRequest)
-- | Deserialize a 'NodesStateRequest' in pure code
decode_NodesStateRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> NodesStateRequest
decode_NodesStateRequest iprot bs = to_NodesStateRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_NodesStateRequest) bs
-- | 'TypeMap' for the 'NodesStateRequest' struct
typemap_NodesStateRequest :: Types.TypeMap
typemap_NodesStateRequest = Map.fromList [("filter",(1,(Types.T_STRUCT Nodes_Types.typemap_NodesFilter))),("force",(2,Types.T_BOOL))]
-- | Default values for the 'NodesStateRequest' struct
default_NodesStateRequest :: NodesStateRequest
default_NodesStateRequest = NodesStateRequest{
  nodesStateRequest_filter = Nothing,
  nodesStateRequest_force = Nothing}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Facebook.Logdevice.Thrift.LogTree.Logtree_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Facebook.Logdevice.Thrift.Common.Common_Types as Common_Types


data LogGroupOperation = APPENDS|READS|APPENDS_OUT  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum LogGroupOperation where
  fromEnum t = case t of
    APPENDS -> 0
    READS -> 1
    APPENDS_OUT -> 2
  toEnum t = case t of
    0 -> APPENDS
    1 -> READS
    2 -> APPENDS_OUT
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    APPENDS -> READS
    READS -> APPENDS_OUT
    APPENDS_OUT -> Exception.throw Thrift.ThriftException
  pred t = case t of
    APPENDS -> Exception.throw Thrift.ThriftException
    READS -> APPENDS
    APPENDS_OUT -> READS
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable LogGroupOperation where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData LogGroupOperation where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary LogGroupOperation where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
-- | Definition of the LogTreeInfo struct
data LogTreeInfo = LogTreeInfo
  { logTreeInfo_version :: LT.Text
    -- ^ version field of the LogTreeInfo struct
  , logTreeInfo_num_logs :: Int.Int64
    -- ^ num_logs field of the LogTreeInfo struct
  , logTreeInfo_max_backlog_seconds :: Int.Int64
    -- ^ max_backlog_seconds field of the LogTreeInfo struct
  , logTreeInfo_is_fully_loaded :: Bool
    -- ^ is_fully_loaded field of the LogTreeInfo struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogTreeInfo where
  encode = encode_LogTreeInfo
  decode = decode_LogTreeInfo
instance Hashable.Hashable LogTreeInfo where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logTreeInfo_version record   `Hashable.hashWithSalt` logTreeInfo_num_logs record   `Hashable.hashWithSalt` logTreeInfo_max_backlog_seconds record   `Hashable.hashWithSalt` logTreeInfo_is_fully_loaded record  
instance DeepSeq.NFData LogTreeInfo where
  rnf _record0 =
    DeepSeq.rnf (logTreeInfo_version _record0) `seq`
    DeepSeq.rnf (logTreeInfo_num_logs _record0) `seq`
    DeepSeq.rnf (logTreeInfo_max_backlog_seconds _record0) `seq`
    DeepSeq.rnf (logTreeInfo_is_fully_loaded _record0) `seq`
    ()
instance Arbitrary.Arbitrary LogTreeInfo where 
  arbitrary = Monad.liftM LogTreeInfo (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogTreeInfo = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogTreeInfo{logTreeInfo_version = logTreeInfo_version obj} then Nothing else Just $ default_LogTreeInfo{logTreeInfo_version = logTreeInfo_version obj}
    , if obj == default_LogTreeInfo{logTreeInfo_num_logs = logTreeInfo_num_logs obj} then Nothing else Just $ default_LogTreeInfo{logTreeInfo_num_logs = logTreeInfo_num_logs obj}
    , if obj == default_LogTreeInfo{logTreeInfo_max_backlog_seconds = logTreeInfo_max_backlog_seconds obj} then Nothing else Just $ default_LogTreeInfo{logTreeInfo_max_backlog_seconds = logTreeInfo_max_backlog_seconds obj}
    , if obj == default_LogTreeInfo{logTreeInfo_is_fully_loaded = logTreeInfo_is_fully_loaded obj} then Nothing else Just $ default_LogTreeInfo{logTreeInfo_is_fully_loaded = logTreeInfo_is_fully_loaded obj}
    ]
-- | Translate a 'LogTreeInfo' to a 'Types.ThriftVal'
from_LogTreeInfo :: LogTreeInfo -> Types.ThriftVal
from_LogTreeInfo record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("version",Types.TString $ Encoding.encodeUtf8 _v3))) $ logTreeInfo_version record
  , (\_v3 -> Just (2, ("num_logs",Types.TI64 _v3))) $ logTreeInfo_num_logs record
  , (\_v3 -> Just (3, ("max_backlog_seconds",Types.TI64 _v3))) $ logTreeInfo_max_backlog_seconds record
  , (\_v3 -> Just (4, ("is_fully_loaded",Types.TBool _v3))) $ logTreeInfo_is_fully_loaded record
  ]
-- | Write a 'LogTreeInfo' with the given 'Thrift.Protocol'
write_LogTreeInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogTreeInfo -> IO ()
write_LogTreeInfo oprot record = Thrift.writeVal oprot $ from_LogTreeInfo record
-- | Serialize a 'LogTreeInfo' in pure code
encode_LogTreeInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogTreeInfo -> BS.ByteString
encode_LogTreeInfo oprot record = Thrift.serializeVal oprot $ from_LogTreeInfo record
-- | Translate a 'Types.ThriftVal' to a 'LogTreeInfo'
to_LogTreeInfo :: Types.ThriftVal -> LogTreeInfo
to_LogTreeInfo (Types.TStruct fields) = LogTreeInfo{
  logTreeInfo_version = maybe (logTreeInfo_version default_LogTreeInfo) (\(_,_val5) -> (case _val5 of {Types.TString _val6 -> Encoding.decodeUtf8 _val6; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logTreeInfo_num_logs = maybe (logTreeInfo_num_logs default_LogTreeInfo) (\(_,_val5) -> (case _val5 of {Types.TI64 _val7 -> _val7; _ -> error "wrong type"})) (Map.lookup (2) fields),
  logTreeInfo_max_backlog_seconds = maybe (logTreeInfo_max_backlog_seconds default_LogTreeInfo) (\(_,_val5) -> (case _val5 of {Types.TI64 _val8 -> _val8; _ -> error "wrong type"})) (Map.lookup (3) fields),
  logTreeInfo_is_fully_loaded = maybe (logTreeInfo_is_fully_loaded default_LogTreeInfo) (\(_,_val5) -> (case _val5 of {Types.TBool _val9 -> _val9; _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_LogTreeInfo _ = error "not a struct"
-- | Read a 'LogTreeInfo' struct with the given 'Thrift.Protocol'
read_LogTreeInfo :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogTreeInfo
read_LogTreeInfo iprot = to_LogTreeInfo <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogTreeInfo)
-- | Deserialize a 'LogTreeInfo' in pure code
decode_LogTreeInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogTreeInfo
decode_LogTreeInfo iprot bs = to_LogTreeInfo $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogTreeInfo) bs
-- | 'TypeMap' for the 'LogTreeInfo' struct
typemap_LogTreeInfo :: Types.TypeMap
typemap_LogTreeInfo = Map.fromList [("version",(1,Types.T_STRING)),("num_logs",(2,Types.T_I64)),("max_backlog_seconds",(3,Types.T_I64)),("is_fully_loaded",(4,Types.T_BOOL))]
-- | Default values for the 'LogTreeInfo' struct
default_LogTreeInfo :: LogTreeInfo
default_LogTreeInfo = LogTreeInfo{
  logTreeInfo_version = "",
  logTreeInfo_num_logs = 0,
  logTreeInfo_max_backlog_seconds = 0,
  logTreeInfo_is_fully_loaded = False}
-- | Definition of the TolerableFailureDomain struct
data TolerableFailureDomain = TolerableFailureDomain
  { tolerableFailureDomain_domain_legacy :: LT.Text
    -- ^ domain_legacy field of the TolerableFailureDomain struct
  , tolerableFailureDomain_count :: Int.Int32
    -- ^ count field of the TolerableFailureDomain struct
  , tolerableFailureDomain_domain :: Common_Types.LocationScope
    -- ^ domain field of the TolerableFailureDomain struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TolerableFailureDomain where
  encode = encode_TolerableFailureDomain
  decode = decode_TolerableFailureDomain
instance Hashable.Hashable TolerableFailureDomain where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` tolerableFailureDomain_domain_legacy record   `Hashable.hashWithSalt` tolerableFailureDomain_count record   `Hashable.hashWithSalt` tolerableFailureDomain_domain record  
instance DeepSeq.NFData TolerableFailureDomain where
  rnf _record10 =
    DeepSeq.rnf (tolerableFailureDomain_domain_legacy _record10) `seq`
    DeepSeq.rnf (tolerableFailureDomain_count _record10) `seq`
    DeepSeq.rnf (tolerableFailureDomain_domain _record10) `seq`
    ()
instance Arbitrary.Arbitrary TolerableFailureDomain where 
  arbitrary = Monad.liftM TolerableFailureDomain (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_TolerableFailureDomain = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TolerableFailureDomain{tolerableFailureDomain_domain_legacy = tolerableFailureDomain_domain_legacy obj} then Nothing else Just $ default_TolerableFailureDomain{tolerableFailureDomain_domain_legacy = tolerableFailureDomain_domain_legacy obj}
    , if obj == default_TolerableFailureDomain{tolerableFailureDomain_count = tolerableFailureDomain_count obj} then Nothing else Just $ default_TolerableFailureDomain{tolerableFailureDomain_count = tolerableFailureDomain_count obj}
    , if obj == default_TolerableFailureDomain{tolerableFailureDomain_domain = tolerableFailureDomain_domain obj} then Nothing else Just $ default_TolerableFailureDomain{tolerableFailureDomain_domain = tolerableFailureDomain_domain obj}
    ]
-- | Translate a 'TolerableFailureDomain' to a 'Types.ThriftVal'
from_TolerableFailureDomain :: TolerableFailureDomain -> Types.ThriftVal
from_TolerableFailureDomain record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v13 -> Just (1, ("domain_legacy",Types.TString $ Encoding.encodeUtf8 _v13))) $ tolerableFailureDomain_domain_legacy record
  , (\_v13 -> Just (2, ("count",Types.TI32 _v13))) $ tolerableFailureDomain_count record
  , (\_v13 -> Just (3, ("domain",Types.TI32 $ fromIntegral $ fromEnum _v13))) $ tolerableFailureDomain_domain record
  ]
-- | Write a 'TolerableFailureDomain' with the given 'Thrift.Protocol'
write_TolerableFailureDomain :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TolerableFailureDomain -> IO ()
write_TolerableFailureDomain oprot record = Thrift.writeVal oprot $ from_TolerableFailureDomain record
-- | Serialize a 'TolerableFailureDomain' in pure code
encode_TolerableFailureDomain :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TolerableFailureDomain -> BS.ByteString
encode_TolerableFailureDomain oprot record = Thrift.serializeVal oprot $ from_TolerableFailureDomain record
-- | Translate a 'Types.ThriftVal' to a 'TolerableFailureDomain'
to_TolerableFailureDomain :: Types.ThriftVal -> TolerableFailureDomain
to_TolerableFailureDomain (Types.TStruct fields) = TolerableFailureDomain{
  tolerableFailureDomain_domain_legacy = maybe (tolerableFailureDomain_domain_legacy default_TolerableFailureDomain) (\(_,_val15) -> (case _val15 of {Types.TString _val16 -> Encoding.decodeUtf8 _val16; _ -> error "wrong type"})) (Map.lookup (1) fields),
  tolerableFailureDomain_count = maybe (tolerableFailureDomain_count default_TolerableFailureDomain) (\(_,_val15) -> (case _val15 of {Types.TI32 _val17 -> _val17; _ -> error "wrong type"})) (Map.lookup (2) fields),
  tolerableFailureDomain_domain = maybe (tolerableFailureDomain_domain default_TolerableFailureDomain) (\(_,_val15) -> (case _val15 of {Types.TI32 _val18 -> toEnum $ fromIntegral _val18; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_TolerableFailureDomain _ = error "not a struct"
-- | Read a 'TolerableFailureDomain' struct with the given 'Thrift.Protocol'
read_TolerableFailureDomain :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TolerableFailureDomain
read_TolerableFailureDomain iprot = to_TolerableFailureDomain <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TolerableFailureDomain)
-- | Deserialize a 'TolerableFailureDomain' in pure code
decode_TolerableFailureDomain :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TolerableFailureDomain
decode_TolerableFailureDomain iprot bs = to_TolerableFailureDomain $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TolerableFailureDomain) bs
-- | 'TypeMap' for the 'TolerableFailureDomain' struct
typemap_TolerableFailureDomain :: Types.TypeMap
typemap_TolerableFailureDomain = Map.fromList [("domain_legacy",(1,Types.T_STRING)),("count",(2,Types.T_I32)),("domain",(3,Types.T_I32))]
-- | Default values for the 'TolerableFailureDomain' struct
default_TolerableFailureDomain :: TolerableFailureDomain
default_TolerableFailureDomain = TolerableFailureDomain{
  tolerableFailureDomain_domain_legacy = "",
  tolerableFailureDomain_count = 0,
  tolerableFailureDomain_domain = (toEnum 0)}
-- | Definition of the ReplicationInfo struct
data ReplicationInfo = ReplicationInfo
  { replicationInfo_version :: LT.Text
    -- ^ version field of the ReplicationInfo struct
  , replicationInfo_narrowest_replication_legacy :: (Map.HashMap LT.Text Int.Int32)
    -- ^ narrowest_replication_legacy field of the ReplicationInfo struct
  , replicationInfo_smallest_replication_factor :: Int.Int32
    -- ^ smallest_replication_factor field of the ReplicationInfo struct
  , replicationInfo_tolerable_failure_domains :: Logtree_Types.TolerableFailureDomain
    -- ^ tolerable_failure_domains field of the ReplicationInfo struct
  , replicationInfo_narrowest_replication :: (Map.HashMap Common_Types.LocationScope Int.Int32)
    -- ^ narrowest_replication field of the ReplicationInfo struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ReplicationInfo where
  encode = encode_ReplicationInfo
  decode = decode_ReplicationInfo
instance Hashable.Hashable ReplicationInfo where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` replicationInfo_version record   `Hashable.hashWithSalt` replicationInfo_narrowest_replication_legacy record   `Hashable.hashWithSalt` replicationInfo_smallest_replication_factor record   `Hashable.hashWithSalt` replicationInfo_tolerable_failure_domains record   `Hashable.hashWithSalt` replicationInfo_narrowest_replication record  
instance DeepSeq.NFData ReplicationInfo where
  rnf _record19 =
    DeepSeq.rnf (replicationInfo_version _record19) `seq`
    DeepSeq.rnf (replicationInfo_narrowest_replication_legacy _record19) `seq`
    DeepSeq.rnf (replicationInfo_smallest_replication_factor _record19) `seq`
    DeepSeq.rnf (replicationInfo_tolerable_failure_domains _record19) `seq`
    DeepSeq.rnf (replicationInfo_narrowest_replication _record19) `seq`
    ()
instance Arbitrary.Arbitrary ReplicationInfo where 
  arbitrary = Monad.liftM ReplicationInfo (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ReplicationInfo = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ReplicationInfo{replicationInfo_version = replicationInfo_version obj} then Nothing else Just $ default_ReplicationInfo{replicationInfo_version = replicationInfo_version obj}
    , if obj == default_ReplicationInfo{replicationInfo_narrowest_replication_legacy = replicationInfo_narrowest_replication_legacy obj} then Nothing else Just $ default_ReplicationInfo{replicationInfo_narrowest_replication_legacy = replicationInfo_narrowest_replication_legacy obj}
    , if obj == default_ReplicationInfo{replicationInfo_smallest_replication_factor = replicationInfo_smallest_replication_factor obj} then Nothing else Just $ default_ReplicationInfo{replicationInfo_smallest_replication_factor = replicationInfo_smallest_replication_factor obj}
    , if obj == default_ReplicationInfo{replicationInfo_tolerable_failure_domains = replicationInfo_tolerable_failure_domains obj} then Nothing else Just $ default_ReplicationInfo{replicationInfo_tolerable_failure_domains = replicationInfo_tolerable_failure_domains obj}
    , if obj == default_ReplicationInfo{replicationInfo_narrowest_replication = replicationInfo_narrowest_replication obj} then Nothing else Just $ default_ReplicationInfo{replicationInfo_narrowest_replication = replicationInfo_narrowest_replication obj}
    ]
-- | Translate a 'ReplicationInfo' to a 'Types.ThriftVal'
from_ReplicationInfo :: ReplicationInfo -> Types.ThriftVal
from_ReplicationInfo record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v22 -> Just (1, ("version",Types.TString $ Encoding.encodeUtf8 _v22))) $ replicationInfo_version record
  , (\_v22 -> Just (2, ("narrowest_replication_legacy",Types.TMap Types.T_STRING Types.T_I32 $ map (\(_k23,_v24) -> (Types.TString $ Encoding.encodeUtf8 _k23, Types.TI32 _v24)) $ Map.toList _v22))) $ replicationInfo_narrowest_replication_legacy record
  , (\_v22 -> Just (3, ("smallest_replication_factor",Types.TI32 _v22))) $ replicationInfo_smallest_replication_factor record
  , (\_v22 -> Just (4, ("tolerable_failure_domains",Logtree_Types.from_TolerableFailureDomain _v22))) $ replicationInfo_tolerable_failure_domains record
  , (\_v22 -> Just (5, ("narrowest_replication",Types.TMap Types.T_I32 Types.T_I32 $ map (\(_k25,_v26) -> (Types.TI32 $ fromIntegral $ fromEnum _k25, Types.TI32 _v26)) $ Map.toList _v22))) $ replicationInfo_narrowest_replication record
  ]
-- | Write a 'ReplicationInfo' with the given 'Thrift.Protocol'
write_ReplicationInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ReplicationInfo -> IO ()
write_ReplicationInfo oprot record = Thrift.writeVal oprot $ from_ReplicationInfo record
-- | Serialize a 'ReplicationInfo' in pure code
encode_ReplicationInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ReplicationInfo -> BS.ByteString
encode_ReplicationInfo oprot record = Thrift.serializeVal oprot $ from_ReplicationInfo record
-- | Translate a 'Types.ThriftVal' to a 'ReplicationInfo'
to_ReplicationInfo :: Types.ThriftVal -> ReplicationInfo
to_ReplicationInfo (Types.TStruct fields) = ReplicationInfo{
  replicationInfo_version = maybe (replicationInfo_version default_ReplicationInfo) (\(_,_val28) -> (case _val28 of {Types.TString _val29 -> Encoding.decodeUtf8 _val29; _ -> error "wrong type"})) (Map.lookup (1) fields),
  replicationInfo_narrowest_replication_legacy = maybe (replicationInfo_narrowest_replication_legacy default_ReplicationInfo) (\(_,_val28) -> (case _val28 of {Types.TMap _ _ _val30 -> (Map.fromList $ map (\(_k32,_v31) -> ((case _k32 of {Types.TString _val33 -> Encoding.decodeUtf8 _val33; _ -> error "wrong type"}),(case _v31 of {Types.TI32 _val34 -> _val34; _ -> error "wrong type"}))) _val30); _ -> error "wrong type"})) (Map.lookup (2) fields),
  replicationInfo_smallest_replication_factor = maybe (replicationInfo_smallest_replication_factor default_ReplicationInfo) (\(_,_val28) -> (case _val28 of {Types.TI32 _val35 -> _val35; _ -> error "wrong type"})) (Map.lookup (3) fields),
  replicationInfo_tolerable_failure_domains = maybe (replicationInfo_tolerable_failure_domains default_ReplicationInfo) (\(_,_val28) -> (case _val28 of {Types.TStruct _val36 -> (Logtree_Types.to_TolerableFailureDomain (Types.TStruct _val36)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  replicationInfo_narrowest_replication = maybe (replicationInfo_narrowest_replication default_ReplicationInfo) (\(_,_val28) -> (case _val28 of {Types.TMap _ _ _val37 -> (Map.fromList $ map (\(_k39,_v38) -> ((case _k39 of {Types.TI32 _val40 -> toEnum $ fromIntegral _val40; _ -> error "wrong type"}),(case _v38 of {Types.TI32 _val41 -> _val41; _ -> error "wrong type"}))) _val37); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_ReplicationInfo _ = error "not a struct"
-- | Read a 'ReplicationInfo' struct with the given 'Thrift.Protocol'
read_ReplicationInfo :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ReplicationInfo
read_ReplicationInfo iprot = to_ReplicationInfo <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ReplicationInfo)
-- | Deserialize a 'ReplicationInfo' in pure code
decode_ReplicationInfo :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ReplicationInfo
decode_ReplicationInfo iprot bs = to_ReplicationInfo $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ReplicationInfo) bs
-- | 'TypeMap' for the 'ReplicationInfo' struct
typemap_ReplicationInfo :: Types.TypeMap
typemap_ReplicationInfo = Map.fromList [("version",(1,Types.T_STRING)),("narrowest_replication_legacy",(2,(Types.T_MAP Types.T_STRING Types.T_I32))),("smallest_replication_factor",(3,Types.T_I32)),("tolerable_failure_domains",(4,(Types.T_STRUCT Logtree_Types.typemap_TolerableFailureDomain))),("narrowest_replication",(5,(Types.T_MAP Types.T_I32 Types.T_I32)))]
-- | Default values for the 'ReplicationInfo' struct
default_ReplicationInfo :: ReplicationInfo
default_ReplicationInfo = ReplicationInfo{
  replicationInfo_version = "",
  replicationInfo_narrowest_replication_legacy = Map.empty,
  replicationInfo_smallest_replication_factor = 0,
  replicationInfo_tolerable_failure_domains = Logtree_Types.default_TolerableFailureDomain,
  replicationInfo_narrowest_replication = Map.empty}
-- | Definition of the LogGroupCustomCountersRequest struct
data LogGroupCustomCountersRequest = LogGroupCustomCountersRequest
  { logGroupCustomCountersRequest_time_period :: Int.Int32
    -- ^ time_period field of the LogGroupCustomCountersRequest struct
  , logGroupCustomCountersRequest_keys :: (Vector.Vector Int.Int16)
    -- ^ keys field of the LogGroupCustomCountersRequest struct
  , logGroupCustomCountersRequest_log_group_path :: LT.Text
    -- ^ log_group_path field of the LogGroupCustomCountersRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupCustomCountersRequest where
  encode = encode_LogGroupCustomCountersRequest
  decode = decode_LogGroupCustomCountersRequest
instance Hashable.Hashable LogGroupCustomCountersRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupCustomCountersRequest_time_period record   `Hashable.hashWithSalt` logGroupCustomCountersRequest_keys record   `Hashable.hashWithSalt` logGroupCustomCountersRequest_log_group_path record  
instance DeepSeq.NFData LogGroupCustomCountersRequest where
  rnf _record42 =
    DeepSeq.rnf (logGroupCustomCountersRequest_time_period _record42) `seq`
    DeepSeq.rnf (logGroupCustomCountersRequest_keys _record42) `seq`
    DeepSeq.rnf (logGroupCustomCountersRequest_log_group_path _record42) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupCustomCountersRequest where 
  arbitrary = Monad.liftM LogGroupCustomCountersRequest (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupCustomCountersRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_time_period = logGroupCustomCountersRequest_time_period obj} then Nothing else Just $ default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_time_period = logGroupCustomCountersRequest_time_period obj}
    , if obj == default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_keys = logGroupCustomCountersRequest_keys obj} then Nothing else Just $ default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_keys = logGroupCustomCountersRequest_keys obj}
    , if obj == default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_log_group_path = logGroupCustomCountersRequest_log_group_path obj} then Nothing else Just $ default_LogGroupCustomCountersRequest{logGroupCustomCountersRequest_log_group_path = logGroupCustomCountersRequest_log_group_path obj}
    ]
-- | Translate a 'LogGroupCustomCountersRequest' to a 'Types.ThriftVal'
from_LogGroupCustomCountersRequest :: LogGroupCustomCountersRequest -> Types.ThriftVal
from_LogGroupCustomCountersRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v45 -> Just (1, ("time_period",Types.TI32 _v45))) $ logGroupCustomCountersRequest_time_period record
  , (\_v45 -> Just (2, ("keys",Types.TList Types.T_I16 $ map (\_v47 -> Types.TI16 _v47) $ Vector.toList _v45))) $ logGroupCustomCountersRequest_keys record
  , (\_v45 -> Just (3, ("log_group_path",Types.TString $ Encoding.encodeUtf8 _v45))) $ logGroupCustomCountersRequest_log_group_path record
  ]
-- | Write a 'LogGroupCustomCountersRequest' with the given 'Thrift.Protocol'
write_LogGroupCustomCountersRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCountersRequest -> IO ()
write_LogGroupCustomCountersRequest oprot record = Thrift.writeVal oprot $ from_LogGroupCustomCountersRequest record
-- | Serialize a 'LogGroupCustomCountersRequest' in pure code
encode_LogGroupCustomCountersRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCountersRequest -> BS.ByteString
encode_LogGroupCustomCountersRequest oprot record = Thrift.serializeVal oprot $ from_LogGroupCustomCountersRequest record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupCustomCountersRequest'
to_LogGroupCustomCountersRequest :: Types.ThriftVal -> LogGroupCustomCountersRequest
to_LogGroupCustomCountersRequest (Types.TStruct fields) = LogGroupCustomCountersRequest{
  logGroupCustomCountersRequest_time_period = maybe (logGroupCustomCountersRequest_time_period default_LogGroupCustomCountersRequest) (\(_,_val49) -> (case _val49 of {Types.TI32 _val50 -> _val50; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logGroupCustomCountersRequest_keys = maybe (logGroupCustomCountersRequest_keys default_LogGroupCustomCountersRequest) (\(_,_val49) -> (case _val49 of {Types.TList _ _val51 -> (Vector.fromList $ map (\_v52 -> (case _v52 of {Types.TI16 _val53 -> _val53; _ -> error "wrong type"})) _val51); _ -> error "wrong type"})) (Map.lookup (2) fields),
  logGroupCustomCountersRequest_log_group_path = maybe (logGroupCustomCountersRequest_log_group_path default_LogGroupCustomCountersRequest) (\(_,_val49) -> (case _val49 of {Types.TString _val54 -> Encoding.decodeUtf8 _val54; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_LogGroupCustomCountersRequest _ = error "not a struct"
-- | Read a 'LogGroupCustomCountersRequest' struct with the given 'Thrift.Protocol'
read_LogGroupCustomCountersRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupCustomCountersRequest
read_LogGroupCustomCountersRequest iprot = to_LogGroupCustomCountersRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupCustomCountersRequest)
-- | Deserialize a 'LogGroupCustomCountersRequest' in pure code
decode_LogGroupCustomCountersRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupCustomCountersRequest
decode_LogGroupCustomCountersRequest iprot bs = to_LogGroupCustomCountersRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupCustomCountersRequest) bs
-- | 'TypeMap' for the 'LogGroupCustomCountersRequest' struct
typemap_LogGroupCustomCountersRequest :: Types.TypeMap
typemap_LogGroupCustomCountersRequest = Map.fromList [("time_period",(1,Types.T_I32)),("keys",(2,(Types.T_LIST Types.T_I16))),("log_group_path",(3,Types.T_STRING))]
-- | Default values for the 'LogGroupCustomCountersRequest' struct
default_LogGroupCustomCountersRequest :: LogGroupCustomCountersRequest
default_LogGroupCustomCountersRequest = LogGroupCustomCountersRequest{
  logGroupCustomCountersRequest_time_period = 0,
  logGroupCustomCountersRequest_keys = Vector.empty,
  logGroupCustomCountersRequest_log_group_path = ""}
-- | Definition of the LogGroupCustomCounter struct
data LogGroupCustomCounter = LogGroupCustomCounter
  { logGroupCustomCounter_key :: Int.Int16
    -- ^ key field of the LogGroupCustomCounter struct
  , logGroupCustomCounter_val :: Int.Int64
    -- ^ val field of the LogGroupCustomCounter struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupCustomCounter where
  encode = encode_LogGroupCustomCounter
  decode = decode_LogGroupCustomCounter
instance Hashable.Hashable LogGroupCustomCounter where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupCustomCounter_key record   `Hashable.hashWithSalt` logGroupCustomCounter_val record  
instance DeepSeq.NFData LogGroupCustomCounter where
  rnf _record55 =
    DeepSeq.rnf (logGroupCustomCounter_key _record55) `seq`
    DeepSeq.rnf (logGroupCustomCounter_val _record55) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupCustomCounter where 
  arbitrary = Monad.liftM LogGroupCustomCounter (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupCustomCounter = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupCustomCounter{logGroupCustomCounter_key = logGroupCustomCounter_key obj} then Nothing else Just $ default_LogGroupCustomCounter{logGroupCustomCounter_key = logGroupCustomCounter_key obj}
    , if obj == default_LogGroupCustomCounter{logGroupCustomCounter_val = logGroupCustomCounter_val obj} then Nothing else Just $ default_LogGroupCustomCounter{logGroupCustomCounter_val = logGroupCustomCounter_val obj}
    ]
-- | Translate a 'LogGroupCustomCounter' to a 'Types.ThriftVal'
from_LogGroupCustomCounter :: LogGroupCustomCounter -> Types.ThriftVal
from_LogGroupCustomCounter record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v58 -> Just (1, ("key",Types.TI16 _v58))) $ logGroupCustomCounter_key record
  , (\_v58 -> Just (2, ("val",Types.TI64 _v58))) $ logGroupCustomCounter_val record
  ]
-- | Write a 'LogGroupCustomCounter' with the given 'Thrift.Protocol'
write_LogGroupCustomCounter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCounter -> IO ()
write_LogGroupCustomCounter oprot record = Thrift.writeVal oprot $ from_LogGroupCustomCounter record
-- | Serialize a 'LogGroupCustomCounter' in pure code
encode_LogGroupCustomCounter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCounter -> BS.ByteString
encode_LogGroupCustomCounter oprot record = Thrift.serializeVal oprot $ from_LogGroupCustomCounter record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupCustomCounter'
to_LogGroupCustomCounter :: Types.ThriftVal -> LogGroupCustomCounter
to_LogGroupCustomCounter (Types.TStruct fields) = LogGroupCustomCounter{
  logGroupCustomCounter_key = maybe (logGroupCustomCounter_key default_LogGroupCustomCounter) (\(_,_val60) -> (case _val60 of {Types.TI16 _val61 -> _val61; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logGroupCustomCounter_val = maybe (logGroupCustomCounter_val default_LogGroupCustomCounter) (\(_,_val60) -> (case _val60 of {Types.TI64 _val62 -> _val62; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_LogGroupCustomCounter _ = error "not a struct"
-- | Read a 'LogGroupCustomCounter' struct with the given 'Thrift.Protocol'
read_LogGroupCustomCounter :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupCustomCounter
read_LogGroupCustomCounter iprot = to_LogGroupCustomCounter <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupCustomCounter)
-- | Deserialize a 'LogGroupCustomCounter' in pure code
decode_LogGroupCustomCounter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupCustomCounter
decode_LogGroupCustomCounter iprot bs = to_LogGroupCustomCounter $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupCustomCounter) bs
-- | 'TypeMap' for the 'LogGroupCustomCounter' struct
typemap_LogGroupCustomCounter :: Types.TypeMap
typemap_LogGroupCustomCounter = Map.fromList [("key",(1,Types.T_I16)),("val",(2,Types.T_I64))]
-- | Default values for the 'LogGroupCustomCounter' struct
default_LogGroupCustomCounter :: LogGroupCustomCounter
default_LogGroupCustomCounter = LogGroupCustomCounter{
  logGroupCustomCounter_key = 0,
  logGroupCustomCounter_val = 0}
-- | Definition of the LogGroupCustomCountersResponse struct
data LogGroupCustomCountersResponse = LogGroupCustomCountersResponse
  { logGroupCustomCountersResponse_counters :: (Map.HashMap LT.Text (Vector.Vector Logtree_Types.LogGroupCustomCounter))
    -- ^ counters field of the LogGroupCustomCountersResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupCustomCountersResponse where
  encode = encode_LogGroupCustomCountersResponse
  decode = decode_LogGroupCustomCountersResponse
instance Hashable.Hashable LogGroupCustomCountersResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupCustomCountersResponse_counters record  
instance DeepSeq.NFData LogGroupCustomCountersResponse where
  rnf _record63 =
    DeepSeq.rnf (logGroupCustomCountersResponse_counters _record63) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupCustomCountersResponse where 
  arbitrary = Monad.liftM LogGroupCustomCountersResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupCustomCountersResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupCustomCountersResponse{logGroupCustomCountersResponse_counters = logGroupCustomCountersResponse_counters obj} then Nothing else Just $ default_LogGroupCustomCountersResponse{logGroupCustomCountersResponse_counters = logGroupCustomCountersResponse_counters obj}
    ]
-- | Translate a 'LogGroupCustomCountersResponse' to a 'Types.ThriftVal'
from_LogGroupCustomCountersResponse :: LogGroupCustomCountersResponse -> Types.ThriftVal
from_LogGroupCustomCountersResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v66 -> Just (1, ("counters",Types.TMap Types.T_STRING (Types.T_LIST (Types.T_STRUCT Logtree_Types.typemap_LogGroupCustomCounter)) $ map (\(_k67,_v68) -> (Types.TString $ Encoding.encodeUtf8 _k67, Types.TList (Types.T_STRUCT Logtree_Types.typemap_LogGroupCustomCounter) $ map (\_v70 -> Logtree_Types.from_LogGroupCustomCounter _v70) $ Vector.toList _v68)) $ Map.toList _v66))) $ logGroupCustomCountersResponse_counters record
  ]
-- | Write a 'LogGroupCustomCountersResponse' with the given 'Thrift.Protocol'
write_LogGroupCustomCountersResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCountersResponse -> IO ()
write_LogGroupCustomCountersResponse oprot record = Thrift.writeVal oprot $ from_LogGroupCustomCountersResponse record
-- | Serialize a 'LogGroupCustomCountersResponse' in pure code
encode_LogGroupCustomCountersResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupCustomCountersResponse -> BS.ByteString
encode_LogGroupCustomCountersResponse oprot record = Thrift.serializeVal oprot $ from_LogGroupCustomCountersResponse record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupCustomCountersResponse'
to_LogGroupCustomCountersResponse :: Types.ThriftVal -> LogGroupCustomCountersResponse
to_LogGroupCustomCountersResponse (Types.TStruct fields) = LogGroupCustomCountersResponse{
  logGroupCustomCountersResponse_counters = maybe (logGroupCustomCountersResponse_counters default_LogGroupCustomCountersResponse) (\(_,_val72) -> (case _val72 of {Types.TMap _ _ _val73 -> (Map.fromList $ map (\(_k75,_v74) -> ((case _k75 of {Types.TString _val76 -> Encoding.decodeUtf8 _val76; _ -> error "wrong type"}),(case _v74 of {Types.TList _ _val77 -> (Vector.fromList $ map (\_v78 -> (case _v78 of {Types.TStruct _val79 -> (Logtree_Types.to_LogGroupCustomCounter (Types.TStruct _val79)); _ -> error "wrong type"})) _val77); _ -> error "wrong type"}))) _val73); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogGroupCustomCountersResponse _ = error "not a struct"
-- | Read a 'LogGroupCustomCountersResponse' struct with the given 'Thrift.Protocol'
read_LogGroupCustomCountersResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupCustomCountersResponse
read_LogGroupCustomCountersResponse iprot = to_LogGroupCustomCountersResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupCustomCountersResponse)
-- | Deserialize a 'LogGroupCustomCountersResponse' in pure code
decode_LogGroupCustomCountersResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupCustomCountersResponse
decode_LogGroupCustomCountersResponse iprot bs = to_LogGroupCustomCountersResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupCustomCountersResponse) bs
-- | 'TypeMap' for the 'LogGroupCustomCountersResponse' struct
typemap_LogGroupCustomCountersResponse :: Types.TypeMap
typemap_LogGroupCustomCountersResponse = Map.fromList [("counters",(1,(Types.T_MAP Types.T_STRING (Types.T_LIST (Types.T_STRUCT Logtree_Types.typemap_LogGroupCustomCounter)))))]
-- | Default values for the 'LogGroupCustomCountersResponse' struct
default_LogGroupCustomCountersResponse :: LogGroupCustomCountersResponse
default_LogGroupCustomCountersResponse = LogGroupCustomCountersResponse{
  logGroupCustomCountersResponse_counters = Map.empty}
-- | Definition of the LogGroupThroughput struct
data LogGroupThroughput = LogGroupThroughput
  { logGroupThroughput_operation :: Logtree_Types.LogGroupOperation
    -- ^ operation field of the LogGroupThroughput struct
  , logGroupThroughput_results :: (Vector.Vector Int.Int64)
    -- ^ results field of the LogGroupThroughput struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupThroughput where
  encode = encode_LogGroupThroughput
  decode = decode_LogGroupThroughput
instance Hashable.Hashable LogGroupThroughput where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupThroughput_operation record   `Hashable.hashWithSalt` logGroupThroughput_results record  
instance DeepSeq.NFData LogGroupThroughput where
  rnf _record80 =
    DeepSeq.rnf (logGroupThroughput_operation _record80) `seq`
    DeepSeq.rnf (logGroupThroughput_results _record80) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupThroughput where 
  arbitrary = Monad.liftM LogGroupThroughput (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupThroughput = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupThroughput{logGroupThroughput_operation = logGroupThroughput_operation obj} then Nothing else Just $ default_LogGroupThroughput{logGroupThroughput_operation = logGroupThroughput_operation obj}
    , if obj == default_LogGroupThroughput{logGroupThroughput_results = logGroupThroughput_results obj} then Nothing else Just $ default_LogGroupThroughput{logGroupThroughput_results = logGroupThroughput_results obj}
    ]
-- | Translate a 'LogGroupThroughput' to a 'Types.ThriftVal'
from_LogGroupThroughput :: LogGroupThroughput -> Types.ThriftVal
from_LogGroupThroughput record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v83 -> Just (1, ("operation",Types.TI32 $ fromIntegral $ fromEnum _v83))) $ logGroupThroughput_operation record
  , (\_v83 -> Just (2, ("results",Types.TList Types.T_I64 $ map (\_v85 -> Types.TI64 _v85) $ Vector.toList _v83))) $ logGroupThroughput_results record
  ]
-- | Write a 'LogGroupThroughput' with the given 'Thrift.Protocol'
write_LogGroupThroughput :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughput -> IO ()
write_LogGroupThroughput oprot record = Thrift.writeVal oprot $ from_LogGroupThroughput record
-- | Serialize a 'LogGroupThroughput' in pure code
encode_LogGroupThroughput :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughput -> BS.ByteString
encode_LogGroupThroughput oprot record = Thrift.serializeVal oprot $ from_LogGroupThroughput record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupThroughput'
to_LogGroupThroughput :: Types.ThriftVal -> LogGroupThroughput
to_LogGroupThroughput (Types.TStruct fields) = LogGroupThroughput{
  logGroupThroughput_operation = maybe (logGroupThroughput_operation default_LogGroupThroughput) (\(_,_val87) -> (case _val87 of {Types.TI32 _val88 -> toEnum $ fromIntegral _val88; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logGroupThroughput_results = maybe (logGroupThroughput_results default_LogGroupThroughput) (\(_,_val87) -> (case _val87 of {Types.TList _ _val89 -> (Vector.fromList $ map (\_v90 -> (case _v90 of {Types.TI64 _val91 -> _val91; _ -> error "wrong type"})) _val89); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_LogGroupThroughput _ = error "not a struct"
-- | Read a 'LogGroupThroughput' struct with the given 'Thrift.Protocol'
read_LogGroupThroughput :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupThroughput
read_LogGroupThroughput iprot = to_LogGroupThroughput <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupThroughput)
-- | Deserialize a 'LogGroupThroughput' in pure code
decode_LogGroupThroughput :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupThroughput
decode_LogGroupThroughput iprot bs = to_LogGroupThroughput $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupThroughput) bs
-- | 'TypeMap' for the 'LogGroupThroughput' struct
typemap_LogGroupThroughput :: Types.TypeMap
typemap_LogGroupThroughput = Map.fromList [("operation",(1,Types.T_I32)),("results",(2,(Types.T_LIST Types.T_I64)))]
-- | Default values for the 'LogGroupThroughput' struct
default_LogGroupThroughput :: LogGroupThroughput
default_LogGroupThroughput = LogGroupThroughput{
  logGroupThroughput_operation = (toEnum 0),
  logGroupThroughput_results = Vector.empty}
-- | Definition of the LogGroupThroughputRequest struct
data LogGroupThroughputRequest = LogGroupThroughputRequest
  { logGroupThroughputRequest_operation :: Maybe Logtree_Types.LogGroupOperation
    -- ^ operation field of the LogGroupThroughputRequest struct
  , logGroupThroughputRequest_time_period :: Maybe (Vector.Vector Int.Int32)
    -- ^ time_period field of the LogGroupThroughputRequest struct
  , logGroupThroughputRequest_log_group_name :: Maybe LT.Text
    -- ^ log_group_name field of the LogGroupThroughputRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupThroughputRequest where
  encode = encode_LogGroupThroughputRequest
  decode = decode_LogGroupThroughputRequest
instance Hashable.Hashable LogGroupThroughputRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupThroughputRequest_operation record   `Hashable.hashWithSalt` logGroupThroughputRequest_time_period record   `Hashable.hashWithSalt` logGroupThroughputRequest_log_group_name record  
instance DeepSeq.NFData LogGroupThroughputRequest where
  rnf _record92 =
    DeepSeq.rnf (logGroupThroughputRequest_operation _record92) `seq`
    DeepSeq.rnf (logGroupThroughputRequest_time_period _record92) `seq`
    DeepSeq.rnf (logGroupThroughputRequest_log_group_name _record92) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupThroughputRequest where 
  arbitrary = Monad.liftM LogGroupThroughputRequest (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupThroughputRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupThroughputRequest{logGroupThroughputRequest_operation = logGroupThroughputRequest_operation obj} then Nothing else Just $ default_LogGroupThroughputRequest{logGroupThroughputRequest_operation = logGroupThroughputRequest_operation obj}
    , if obj == default_LogGroupThroughputRequest{logGroupThroughputRequest_time_period = logGroupThroughputRequest_time_period obj} then Nothing else Just $ default_LogGroupThroughputRequest{logGroupThroughputRequest_time_period = logGroupThroughputRequest_time_period obj}
    , if obj == default_LogGroupThroughputRequest{logGroupThroughputRequest_log_group_name = logGroupThroughputRequest_log_group_name obj} then Nothing else Just $ default_LogGroupThroughputRequest{logGroupThroughputRequest_log_group_name = logGroupThroughputRequest_log_group_name obj}
    ]
-- | Translate a 'LogGroupThroughputRequest' to a 'Types.ThriftVal'
from_LogGroupThroughputRequest :: LogGroupThroughputRequest -> Types.ThriftVal
from_LogGroupThroughputRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v95 -> (1, ("operation",Types.TI32 $ fromIntegral $ fromEnum _v95))) <$> logGroupThroughputRequest_operation record
  , (\_v95 -> (2, ("time_period",Types.TList Types.T_I32 $ map (\_v97 -> Types.TI32 _v97) $ Vector.toList _v95))) <$> logGroupThroughputRequest_time_period record
  , (\_v95 -> (3, ("log_group_name",Types.TString $ Encoding.encodeUtf8 _v95))) <$> logGroupThroughputRequest_log_group_name record
  ]
-- | Write a 'LogGroupThroughputRequest' with the given 'Thrift.Protocol'
write_LogGroupThroughputRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughputRequest -> IO ()
write_LogGroupThroughputRequest oprot record = Thrift.writeVal oprot $ from_LogGroupThroughputRequest record
-- | Serialize a 'LogGroupThroughputRequest' in pure code
encode_LogGroupThroughputRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughputRequest -> BS.ByteString
encode_LogGroupThroughputRequest oprot record = Thrift.serializeVal oprot $ from_LogGroupThroughputRequest record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupThroughputRequest'
to_LogGroupThroughputRequest :: Types.ThriftVal -> LogGroupThroughputRequest
to_LogGroupThroughputRequest (Types.TStruct fields) = LogGroupThroughputRequest{
  logGroupThroughputRequest_operation = maybe (Nothing) (\(_,_val99) -> Just (case _val99 of {Types.TI32 _val100 -> toEnum $ fromIntegral _val100; _ -> error "wrong type"})) (Map.lookup (1) fields),
  logGroupThroughputRequest_time_period = maybe (Nothing) (\(_,_val99) -> Just (case _val99 of {Types.TList _ _val101 -> (Vector.fromList $ map (\_v102 -> (case _v102 of {Types.TI32 _val103 -> _val103; _ -> error "wrong type"})) _val101); _ -> error "wrong type"})) (Map.lookup (2) fields),
  logGroupThroughputRequest_log_group_name = maybe (Nothing) (\(_,_val99) -> Just (case _val99 of {Types.TString _val104 -> Encoding.decodeUtf8 _val104; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_LogGroupThroughputRequest _ = error "not a struct"
-- | Read a 'LogGroupThroughputRequest' struct with the given 'Thrift.Protocol'
read_LogGroupThroughputRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupThroughputRequest
read_LogGroupThroughputRequest iprot = to_LogGroupThroughputRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupThroughputRequest)
-- | Deserialize a 'LogGroupThroughputRequest' in pure code
decode_LogGroupThroughputRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupThroughputRequest
decode_LogGroupThroughputRequest iprot bs = to_LogGroupThroughputRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupThroughputRequest) bs
-- | 'TypeMap' for the 'LogGroupThroughputRequest' struct
typemap_LogGroupThroughputRequest :: Types.TypeMap
typemap_LogGroupThroughputRequest = Map.fromList [("operation",(1,Types.T_I32)),("time_period",(2,(Types.T_LIST Types.T_I32))),("log_group_name",(3,Types.T_STRING))]
-- | Default values for the 'LogGroupThroughputRequest' struct
default_LogGroupThroughputRequest :: LogGroupThroughputRequest
default_LogGroupThroughputRequest = LogGroupThroughputRequest{
  logGroupThroughputRequest_operation = Nothing,
  logGroupThroughputRequest_time_period = Nothing,
  logGroupThroughputRequest_log_group_name = Nothing}
-- | Definition of the LogGroupThroughputResponse struct
data LogGroupThroughputResponse = LogGroupThroughputResponse
  { logGroupThroughputResponse_throughput :: (Map.HashMap LT.Text Logtree_Types.LogGroupThroughput)
    -- ^ throughput field of the LogGroupThroughputResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable LogGroupThroughputResponse where
  encode = encode_LogGroupThroughputResponse
  decode = decode_LogGroupThroughputResponse
instance Hashable.Hashable LogGroupThroughputResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` logGroupThroughputResponse_throughput record  
instance DeepSeq.NFData LogGroupThroughputResponse where
  rnf _record105 =
    DeepSeq.rnf (logGroupThroughputResponse_throughput _record105) `seq`
    ()
instance Arbitrary.Arbitrary LogGroupThroughputResponse where 
  arbitrary = Monad.liftM LogGroupThroughputResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_LogGroupThroughputResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_LogGroupThroughputResponse{logGroupThroughputResponse_throughput = logGroupThroughputResponse_throughput obj} then Nothing else Just $ default_LogGroupThroughputResponse{logGroupThroughputResponse_throughput = logGroupThroughputResponse_throughput obj}
    ]
-- | Translate a 'LogGroupThroughputResponse' to a 'Types.ThriftVal'
from_LogGroupThroughputResponse :: LogGroupThroughputResponse -> Types.ThriftVal
from_LogGroupThroughputResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v108 -> Just (1, ("throughput",Types.TMap Types.T_STRING (Types.T_STRUCT Logtree_Types.typemap_LogGroupThroughput) $ map (\(_k109,_v110) -> (Types.TString $ Encoding.encodeUtf8 _k109, Logtree_Types.from_LogGroupThroughput _v110)) $ Map.toList _v108))) $ logGroupThroughputResponse_throughput record
  ]
-- | Write a 'LogGroupThroughputResponse' with the given 'Thrift.Protocol'
write_LogGroupThroughputResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughputResponse -> IO ()
write_LogGroupThroughputResponse oprot record = Thrift.writeVal oprot $ from_LogGroupThroughputResponse record
-- | Serialize a 'LogGroupThroughputResponse' in pure code
encode_LogGroupThroughputResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> LogGroupThroughputResponse -> BS.ByteString
encode_LogGroupThroughputResponse oprot record = Thrift.serializeVal oprot $ from_LogGroupThroughputResponse record
-- | Translate a 'Types.ThriftVal' to a 'LogGroupThroughputResponse'
to_LogGroupThroughputResponse :: Types.ThriftVal -> LogGroupThroughputResponse
to_LogGroupThroughputResponse (Types.TStruct fields) = LogGroupThroughputResponse{
  logGroupThroughputResponse_throughput = maybe (logGroupThroughputResponse_throughput default_LogGroupThroughputResponse) (\(_,_val112) -> (case _val112 of {Types.TMap _ _ _val113 -> (Map.fromList $ map (\(_k115,_v114) -> ((case _k115 of {Types.TString _val116 -> Encoding.decodeUtf8 _val116; _ -> error "wrong type"}),(case _v114 of {Types.TStruct _val117 -> (Logtree_Types.to_LogGroupThroughput (Types.TStruct _val117)); _ -> error "wrong type"}))) _val113); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogGroupThroughputResponse _ = error "not a struct"
-- | Read a 'LogGroupThroughputResponse' struct with the given 'Thrift.Protocol'
read_LogGroupThroughputResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO LogGroupThroughputResponse
read_LogGroupThroughputResponse iprot = to_LogGroupThroughputResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_LogGroupThroughputResponse)
-- | Deserialize a 'LogGroupThroughputResponse' in pure code
decode_LogGroupThroughputResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> LogGroupThroughputResponse
decode_LogGroupThroughputResponse iprot bs = to_LogGroupThroughputResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_LogGroupThroughputResponse) bs
-- | 'TypeMap' for the 'LogGroupThroughputResponse' struct
typemap_LogGroupThroughputResponse :: Types.TypeMap
typemap_LogGroupThroughputResponse = Map.fromList [("throughput",(1,(Types.T_MAP Types.T_STRING (Types.T_STRUCT Logtree_Types.typemap_LogGroupThroughput))))]
-- | Default values for the 'LogGroupThroughputResponse' struct
default_LogGroupThroughputResponse :: LogGroupThroughputResponse
default_LogGroupThroughputResponse = LogGroupThroughputResponse{
  logGroupThroughputResponse_throughput = Map.empty}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Facebook.Logdevice.Thrift.Admin.AdminAPI where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Facebook.FB303.Fb303_Types as Fb303_Types
import qualified Facebook.Logdevice.Thrift.Common.Common_Types as Common_Types
import qualified Facebook.Logdevice.Thrift.AdminCommand.Admin_commands_Types as Admin_commands_Types
import qualified Facebook.Logdevice.Thrift.ClusterMembership.Cluster_membership_Types as Cluster_membership_Types
import qualified Facebook.Logdevice.Thrift.Exceptions.Exceptions_Types as Exceptions_Types
import qualified Facebook.Logdevice.Thrift.LogTree.Logtree_Types as Logtree_Types
import qualified Facebook.Logdevice.Thrift.Maintenance.Maintenance_Types as Maintenance_Types
import qualified Facebook.Logdevice.Thrift.Nodes.Nodes_Types as Nodes_Types
import qualified Facebook.Logdevice.Thrift.Safety.Safety_Types as Safety_Types
import qualified Facebook.Logdevice.Thrift.Settings.Settings_Types as Settings_Types


import qualified Facebook.FB303.FacebookService
import qualified Facebook.Logdevice.Thrift.Admin.Admin_Types
import qualified Facebook.Logdevice.Thrift.Admin.AdminAPI_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

-- | Definition of the GetNodesConfig_args struct
data GetNodesConfig_args = GetNodesConfig_args
  { getNodesConfig_args_filter :: Nodes_Types.NodesFilter
    -- ^ filter field of the GetNodesConfig_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetNodesConfig_args where
  encode = encode_GetNodesConfig_args
  decode = decode_GetNodesConfig_args
instance Hashable.Hashable GetNodesConfig_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getNodesConfig_args_filter record  
instance DeepSeq.NFData GetNodesConfig_args where
  rnf _record0 =
    DeepSeq.rnf (getNodesConfig_args_filter _record0) `seq`
    ()
instance Arbitrary.Arbitrary GetNodesConfig_args where 
  arbitrary = Monad.liftM GetNodesConfig_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetNodesConfig_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetNodesConfig_args{getNodesConfig_args_filter = getNodesConfig_args_filter obj} then Nothing else Just $ default_GetNodesConfig_args{getNodesConfig_args_filter = getNodesConfig_args_filter obj}
    ]
-- | Translate a 'GetNodesConfig_args' to a 'Types.ThriftVal'
from_GetNodesConfig_args :: GetNodesConfig_args -> Types.ThriftVal
from_GetNodesConfig_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("filter",Nodes_Types.from_NodesFilter _v3))) $ getNodesConfig_args_filter record
  ]
-- | Write a 'GetNodesConfig_args' with the given 'Thrift.Protocol'
write_GetNodesConfig_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesConfig_args -> IO ()
write_GetNodesConfig_args oprot record = Thrift.writeVal oprot $ from_GetNodesConfig_args record
-- | Serialize a 'GetNodesConfig_args' in pure code
encode_GetNodesConfig_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesConfig_args -> BS.ByteString
encode_GetNodesConfig_args oprot record = Thrift.serializeVal oprot $ from_GetNodesConfig_args record
-- | Translate a 'Types.ThriftVal' to a 'GetNodesConfig_args'
to_GetNodesConfig_args :: Types.ThriftVal -> GetNodesConfig_args
to_GetNodesConfig_args (Types.TStruct fields) = GetNodesConfig_args{
  getNodesConfig_args_filter = maybe (getNodesConfig_args_filter default_GetNodesConfig_args) (\(_,_val5) -> (case _val5 of {Types.TStruct _val6 -> (Nodes_Types.to_NodesFilter (Types.TStruct _val6)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNodesConfig_args _ = error "not a struct"
-- | Read a 'GetNodesConfig_args' struct with the given 'Thrift.Protocol'
read_GetNodesConfig_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetNodesConfig_args
read_GetNodesConfig_args iprot = to_GetNodesConfig_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetNodesConfig_args)
-- | Deserialize a 'GetNodesConfig_args' in pure code
decode_GetNodesConfig_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetNodesConfig_args
decode_GetNodesConfig_args iprot bs = to_GetNodesConfig_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetNodesConfig_args) bs
-- | 'TypeMap' for the 'GetNodesConfig_args' struct
typemap_GetNodesConfig_args :: Types.TypeMap
typemap_GetNodesConfig_args = Map.fromList [("filter",(1,(Types.T_STRUCT Nodes_Types.typemap_NodesFilter)))]
-- | Default values for the 'GetNodesConfig_args' struct
default_GetNodesConfig_args :: GetNodesConfig_args
default_GetNodesConfig_args = GetNodesConfig_args{
  getNodesConfig_args_filter = Nodes_Types.default_NodesFilter}
-- | Definition of the GetNodesConfig_result struct
data GetNodesConfig_result = GetNodesConfig_result
  { getNodesConfig_result_success :: Nodes_Types.NodesConfigResponse
    -- ^ success field of the GetNodesConfig_result struct
  , getNodesConfig_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the GetNodesConfig_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetNodesConfig_result where
  encode = encode_GetNodesConfig_result
  decode = decode_GetNodesConfig_result
instance Hashable.Hashable GetNodesConfig_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getNodesConfig_result_success record   `Hashable.hashWithSalt` getNodesConfig_result_notready record  
instance DeepSeq.NFData GetNodesConfig_result where
  rnf _record7 =
    DeepSeq.rnf (getNodesConfig_result_success _record7) `seq`
    DeepSeq.rnf (getNodesConfig_result_notready _record7) `seq`
    ()
instance Arbitrary.Arbitrary GetNodesConfig_result where 
  arbitrary = Monad.liftM GetNodesConfig_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_GetNodesConfig_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetNodesConfig_result{getNodesConfig_result_success = getNodesConfig_result_success obj} then Nothing else Just $ default_GetNodesConfig_result{getNodesConfig_result_success = getNodesConfig_result_success obj}
    , if obj == default_GetNodesConfig_result{getNodesConfig_result_notready = getNodesConfig_result_notready obj} then Nothing else Just $ default_GetNodesConfig_result{getNodesConfig_result_notready = getNodesConfig_result_notready obj}
    ]
-- | Translate a 'GetNodesConfig_result' to a 'Types.ThriftVal'
from_GetNodesConfig_result :: GetNodesConfig_result -> Types.ThriftVal
from_GetNodesConfig_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v10 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v10))) <$> getNodesConfig_result_notready record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v10 -> Just (0, ("success",Nodes_Types.from_NodesConfigResponse _v10))) $ getNodesConfig_result_success record
    , (\_v10 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v10))) <$> getNodesConfig_result_notready record
    ]
    )
-- | Write a 'GetNodesConfig_result' with the given 'Thrift.Protocol'
write_GetNodesConfig_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesConfig_result -> IO ()
write_GetNodesConfig_result oprot record = Thrift.writeVal oprot $ from_GetNodesConfig_result record
-- | Serialize a 'GetNodesConfig_result' in pure code
encode_GetNodesConfig_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesConfig_result -> BS.ByteString
encode_GetNodesConfig_result oprot record = Thrift.serializeVal oprot $ from_GetNodesConfig_result record
-- | Translate a 'Types.ThriftVal' to a 'GetNodesConfig_result'
to_GetNodesConfig_result :: Types.ThriftVal -> GetNodesConfig_result
to_GetNodesConfig_result (Types.TStruct fields) = GetNodesConfig_result{
  getNodesConfig_result_success = maybe (getNodesConfig_result_success default_GetNodesConfig_result) (\(_,_val12) -> (case _val12 of {Types.TStruct _val13 -> (Nodes_Types.to_NodesConfigResponse (Types.TStruct _val13)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  getNodesConfig_result_notready = maybe (Nothing) (\(_,_val12) -> Just (case _val12 of {Types.TStruct _val14 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val14)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNodesConfig_result _ = error "not a struct"
-- | Read a 'GetNodesConfig_result' struct with the given 'Thrift.Protocol'
read_GetNodesConfig_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetNodesConfig_result
read_GetNodesConfig_result iprot = to_GetNodesConfig_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetNodesConfig_result)
-- | Deserialize a 'GetNodesConfig_result' in pure code
decode_GetNodesConfig_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetNodesConfig_result
decode_GetNodesConfig_result iprot bs = to_GetNodesConfig_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetNodesConfig_result) bs
-- | 'TypeMap' for the 'GetNodesConfig_result' struct
typemap_GetNodesConfig_result :: Types.TypeMap
typemap_GetNodesConfig_result = Map.fromList [("success",(0,(Types.T_STRUCT Nodes_Types.typemap_NodesConfigResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady)))]
-- | Default values for the 'GetNodesConfig_result' struct
default_GetNodesConfig_result :: GetNodesConfig_result
default_GetNodesConfig_result = GetNodesConfig_result{
  getNodesConfig_result_success = Nodes_Types.default_NodesConfigResponse,
  getNodesConfig_result_notready = Nothing}
-- | Definition of the GetNodesState_args struct
data GetNodesState_args = GetNodesState_args
  { getNodesState_args_request :: Nodes_Types.NodesStateRequest
    -- ^ request field of the GetNodesState_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetNodesState_args where
  encode = encode_GetNodesState_args
  decode = decode_GetNodesState_args
instance Hashable.Hashable GetNodesState_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getNodesState_args_request record  
instance DeepSeq.NFData GetNodesState_args where
  rnf _record15 =
    DeepSeq.rnf (getNodesState_args_request _record15) `seq`
    ()
instance Arbitrary.Arbitrary GetNodesState_args where 
  arbitrary = Monad.liftM GetNodesState_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetNodesState_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetNodesState_args{getNodesState_args_request = getNodesState_args_request obj} then Nothing else Just $ default_GetNodesState_args{getNodesState_args_request = getNodesState_args_request obj}
    ]
-- | Translate a 'GetNodesState_args' to a 'Types.ThriftVal'
from_GetNodesState_args :: GetNodesState_args -> Types.ThriftVal
from_GetNodesState_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v18 -> Just (1, ("request",Nodes_Types.from_NodesStateRequest _v18))) $ getNodesState_args_request record
  ]
-- | Write a 'GetNodesState_args' with the given 'Thrift.Protocol'
write_GetNodesState_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesState_args -> IO ()
write_GetNodesState_args oprot record = Thrift.writeVal oprot $ from_GetNodesState_args record
-- | Serialize a 'GetNodesState_args' in pure code
encode_GetNodesState_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesState_args -> BS.ByteString
encode_GetNodesState_args oprot record = Thrift.serializeVal oprot $ from_GetNodesState_args record
-- | Translate a 'Types.ThriftVal' to a 'GetNodesState_args'
to_GetNodesState_args :: Types.ThriftVal -> GetNodesState_args
to_GetNodesState_args (Types.TStruct fields) = GetNodesState_args{
  getNodesState_args_request = maybe (getNodesState_args_request default_GetNodesState_args) (\(_,_val20) -> (case _val20 of {Types.TStruct _val21 -> (Nodes_Types.to_NodesStateRequest (Types.TStruct _val21)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNodesState_args _ = error "not a struct"
-- | Read a 'GetNodesState_args' struct with the given 'Thrift.Protocol'
read_GetNodesState_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetNodesState_args
read_GetNodesState_args iprot = to_GetNodesState_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetNodesState_args)
-- | Deserialize a 'GetNodesState_args' in pure code
decode_GetNodesState_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetNodesState_args
decode_GetNodesState_args iprot bs = to_GetNodesState_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetNodesState_args) bs
-- | 'TypeMap' for the 'GetNodesState_args' struct
typemap_GetNodesState_args :: Types.TypeMap
typemap_GetNodesState_args = Map.fromList [("request",(1,(Types.T_STRUCT Nodes_Types.typemap_NodesStateRequest)))]
-- | Default values for the 'GetNodesState_args' struct
default_GetNodesState_args :: GetNodesState_args
default_GetNodesState_args = GetNodesState_args{
  getNodesState_args_request = Nodes_Types.default_NodesStateRequest}
-- | Definition of the GetNodesState_result struct
data GetNodesState_result = GetNodesState_result
  { getNodesState_result_success :: Nodes_Types.NodesStateResponse
    -- ^ success field of the GetNodesState_result struct
  , getNodesState_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the GetNodesState_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetNodesState_result where
  encode = encode_GetNodesState_result
  decode = decode_GetNodesState_result
instance Hashable.Hashable GetNodesState_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getNodesState_result_success record   `Hashable.hashWithSalt` getNodesState_result_notready record  
instance DeepSeq.NFData GetNodesState_result where
  rnf _record22 =
    DeepSeq.rnf (getNodesState_result_success _record22) `seq`
    DeepSeq.rnf (getNodesState_result_notready _record22) `seq`
    ()
instance Arbitrary.Arbitrary GetNodesState_result where 
  arbitrary = Monad.liftM GetNodesState_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_GetNodesState_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetNodesState_result{getNodesState_result_success = getNodesState_result_success obj} then Nothing else Just $ default_GetNodesState_result{getNodesState_result_success = getNodesState_result_success obj}
    , if obj == default_GetNodesState_result{getNodesState_result_notready = getNodesState_result_notready obj} then Nothing else Just $ default_GetNodesState_result{getNodesState_result_notready = getNodesState_result_notready obj}
    ]
-- | Translate a 'GetNodesState_result' to a 'Types.ThriftVal'
from_GetNodesState_result :: GetNodesState_result -> Types.ThriftVal
from_GetNodesState_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v25 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v25))) <$> getNodesState_result_notready record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v25 -> Just (0, ("success",Nodes_Types.from_NodesStateResponse _v25))) $ getNodesState_result_success record
    , (\_v25 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v25))) <$> getNodesState_result_notready record
    ]
    )
-- | Write a 'GetNodesState_result' with the given 'Thrift.Protocol'
write_GetNodesState_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesState_result -> IO ()
write_GetNodesState_result oprot record = Thrift.writeVal oprot $ from_GetNodesState_result record
-- | Serialize a 'GetNodesState_result' in pure code
encode_GetNodesState_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetNodesState_result -> BS.ByteString
encode_GetNodesState_result oprot record = Thrift.serializeVal oprot $ from_GetNodesState_result record
-- | Translate a 'Types.ThriftVal' to a 'GetNodesState_result'
to_GetNodesState_result :: Types.ThriftVal -> GetNodesState_result
to_GetNodesState_result (Types.TStruct fields) = GetNodesState_result{
  getNodesState_result_success = maybe (getNodesState_result_success default_GetNodesState_result) (\(_,_val27) -> (case _val27 of {Types.TStruct _val28 -> (Nodes_Types.to_NodesStateResponse (Types.TStruct _val28)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  getNodesState_result_notready = maybe (Nothing) (\(_,_val27) -> Just (case _val27 of {Types.TStruct _val29 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val29)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNodesState_result _ = error "not a struct"
-- | Read a 'GetNodesState_result' struct with the given 'Thrift.Protocol'
read_GetNodesState_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetNodesState_result
read_GetNodesState_result iprot = to_GetNodesState_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetNodesState_result)
-- | Deserialize a 'GetNodesState_result' in pure code
decode_GetNodesState_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetNodesState_result
decode_GetNodesState_result iprot bs = to_GetNodesState_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetNodesState_result) bs
-- | 'TypeMap' for the 'GetNodesState_result' struct
typemap_GetNodesState_result :: Types.TypeMap
typemap_GetNodesState_result = Map.fromList [("success",(0,(Types.T_STRUCT Nodes_Types.typemap_NodesStateResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady)))]
-- | Default values for the 'GetNodesState_result' struct
default_GetNodesState_result :: GetNodesState_result
default_GetNodesState_result = GetNodesState_result{
  getNodesState_result_success = Nodes_Types.default_NodesStateResponse,
  getNodesState_result_notready = Nothing}
-- | Definition of the AddNodes_args struct
data AddNodes_args = AddNodes_args
  { addNodes_args_request :: Cluster_membership_Types.AddNodesRequest
    -- ^ request field of the AddNodes_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable AddNodes_args where
  encode = encode_AddNodes_args
  decode = decode_AddNodes_args
instance Hashable.Hashable AddNodes_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` addNodes_args_request record  
instance DeepSeq.NFData AddNodes_args where
  rnf _record30 =
    DeepSeq.rnf (addNodes_args_request _record30) `seq`
    ()
instance Arbitrary.Arbitrary AddNodes_args where 
  arbitrary = Monad.liftM AddNodes_args (Arbitrary.arbitrary)
  shrink obj | obj == default_AddNodes_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_AddNodes_args{addNodes_args_request = addNodes_args_request obj} then Nothing else Just $ default_AddNodes_args{addNodes_args_request = addNodes_args_request obj}
    ]
-- | Translate a 'AddNodes_args' to a 'Types.ThriftVal'
from_AddNodes_args :: AddNodes_args -> Types.ThriftVal
from_AddNodes_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v33 -> Just (1, ("request",Cluster_membership_Types.from_AddNodesRequest _v33))) $ addNodes_args_request record
  ]
-- | Write a 'AddNodes_args' with the given 'Thrift.Protocol'
write_AddNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodes_args -> IO ()
write_AddNodes_args oprot record = Thrift.writeVal oprot $ from_AddNodes_args record
-- | Serialize a 'AddNodes_args' in pure code
encode_AddNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodes_args -> BS.ByteString
encode_AddNodes_args oprot record = Thrift.serializeVal oprot $ from_AddNodes_args record
-- | Translate a 'Types.ThriftVal' to a 'AddNodes_args'
to_AddNodes_args :: Types.ThriftVal -> AddNodes_args
to_AddNodes_args (Types.TStruct fields) = AddNodes_args{
  addNodes_args_request = maybe (addNodes_args_request default_AddNodes_args) (\(_,_val35) -> (case _val35 of {Types.TStruct _val36 -> (Cluster_membership_Types.to_AddNodesRequest (Types.TStruct _val36)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddNodes_args _ = error "not a struct"
-- | Read a 'AddNodes_args' struct with the given 'Thrift.Protocol'
read_AddNodes_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO AddNodes_args
read_AddNodes_args iprot = to_AddNodes_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_AddNodes_args)
-- | Deserialize a 'AddNodes_args' in pure code
decode_AddNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> AddNodes_args
decode_AddNodes_args iprot bs = to_AddNodes_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_AddNodes_args) bs
-- | 'TypeMap' for the 'AddNodes_args' struct
typemap_AddNodes_args :: Types.TypeMap
typemap_AddNodes_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_AddNodesRequest)))]
-- | Default values for the 'AddNodes_args' struct
default_AddNodes_args :: AddNodes_args
default_AddNodes_args = AddNodes_args{
  addNodes_args_request = Cluster_membership_Types.default_AddNodesRequest}
-- | Definition of the AddNodes_result struct
data AddNodes_result = AddNodes_result
  { addNodes_result_success :: Cluster_membership_Types.AddNodesResponse
    -- ^ success field of the AddNodes_result struct
  , addNodes_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the AddNodes_result struct
  , addNodes_result_failed_op :: Maybe Cluster_membership_Types.ClusterMembershipOperationFailed
    -- ^ failed_op field of the AddNodes_result struct
  , addNodes_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the AddNodes_result struct
  , addNodes_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the AddNodes_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable AddNodes_result where
  encode = encode_AddNodes_result
  decode = decode_AddNodes_result
instance Hashable.Hashable AddNodes_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` addNodes_result_success record   `Hashable.hashWithSalt` addNodes_result_notready record   `Hashable.hashWithSalt` addNodes_result_failed_op record   `Hashable.hashWithSalt` addNodes_result_ncm_error record   `Hashable.hashWithSalt` addNodes_result_not_supported record  
instance DeepSeq.NFData AddNodes_result where
  rnf _record37 =
    DeepSeq.rnf (addNodes_result_success _record37) `seq`
    DeepSeq.rnf (addNodes_result_notready _record37) `seq`
    DeepSeq.rnf (addNodes_result_failed_op _record37) `seq`
    DeepSeq.rnf (addNodes_result_ncm_error _record37) `seq`
    DeepSeq.rnf (addNodes_result_not_supported _record37) `seq`
    ()
instance Arbitrary.Arbitrary AddNodes_result where 
  arbitrary = Monad.liftM AddNodes_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_AddNodes_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_AddNodes_result{addNodes_result_success = addNodes_result_success obj} then Nothing else Just $ default_AddNodes_result{addNodes_result_success = addNodes_result_success obj}
    , if obj == default_AddNodes_result{addNodes_result_notready = addNodes_result_notready obj} then Nothing else Just $ default_AddNodes_result{addNodes_result_notready = addNodes_result_notready obj}
    , if obj == default_AddNodes_result{addNodes_result_failed_op = addNodes_result_failed_op obj} then Nothing else Just $ default_AddNodes_result{addNodes_result_failed_op = addNodes_result_failed_op obj}
    , if obj == default_AddNodes_result{addNodes_result_ncm_error = addNodes_result_ncm_error obj} then Nothing else Just $ default_AddNodes_result{addNodes_result_ncm_error = addNodes_result_ncm_error obj}
    , if obj == default_AddNodes_result{addNodes_result_not_supported = addNodes_result_not_supported obj} then Nothing else Just $ default_AddNodes_result{addNodes_result_not_supported = addNodes_result_not_supported obj}
    ]
-- | Translate a 'AddNodes_result' to a 'Types.ThriftVal'
from_AddNodes_result :: AddNodes_result -> Types.ThriftVal
from_AddNodes_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v40 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v40))) <$> addNodes_result_notready record, (\_v40 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v40))) <$> addNodes_result_failed_op record, (\_v40 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v40))) <$> addNodes_result_ncm_error record, (\_v40 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v40))) <$> addNodes_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v40 -> Just (0, ("success",Cluster_membership_Types.from_AddNodesResponse _v40))) $ addNodes_result_success record
    , (\_v40 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v40))) <$> addNodes_result_notready record
    , (\_v40 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v40))) <$> addNodes_result_failed_op record
    , (\_v40 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v40))) <$> addNodes_result_ncm_error record
    , (\_v40 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v40))) <$> addNodes_result_not_supported record
    ]
    )
-- | Write a 'AddNodes_result' with the given 'Thrift.Protocol'
write_AddNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodes_result -> IO ()
write_AddNodes_result oprot record = Thrift.writeVal oprot $ from_AddNodes_result record
-- | Serialize a 'AddNodes_result' in pure code
encode_AddNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> AddNodes_result -> BS.ByteString
encode_AddNodes_result oprot record = Thrift.serializeVal oprot $ from_AddNodes_result record
-- | Translate a 'Types.ThriftVal' to a 'AddNodes_result'
to_AddNodes_result :: Types.ThriftVal -> AddNodes_result
to_AddNodes_result (Types.TStruct fields) = AddNodes_result{
  addNodes_result_success = maybe (addNodes_result_success default_AddNodes_result) (\(_,_val42) -> (case _val42 of {Types.TStruct _val43 -> (Cluster_membership_Types.to_AddNodesResponse (Types.TStruct _val43)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  addNodes_result_notready = maybe (Nothing) (\(_,_val42) -> Just (case _val42 of {Types.TStruct _val44 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val44)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  addNodes_result_failed_op = maybe (Nothing) (\(_,_val42) -> Just (case _val42 of {Types.TStruct _val45 -> (Cluster_membership_Types.to_ClusterMembershipOperationFailed (Types.TStruct _val45)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  addNodes_result_ncm_error = maybe (Nothing) (\(_,_val42) -> Just (case _val42 of {Types.TStruct _val46 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val46)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  addNodes_result_not_supported = maybe (Nothing) (\(_,_val42) -> Just (case _val42 of {Types.TStruct _val47 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val47)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_AddNodes_result _ = error "not a struct"
-- | Read a 'AddNodes_result' struct with the given 'Thrift.Protocol'
read_AddNodes_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO AddNodes_result
read_AddNodes_result iprot = to_AddNodes_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_AddNodes_result)
-- | Deserialize a 'AddNodes_result' in pure code
decode_AddNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> AddNodes_result
decode_AddNodes_result iprot bs = to_AddNodes_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_AddNodes_result) bs
-- | 'TypeMap' for the 'AddNodes_result' struct
typemap_AddNodes_result :: Types.TypeMap
typemap_AddNodes_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_AddNodesResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("failed_op",(2,(Types.T_STRUCT Cluster_membership_Types.typemap_ClusterMembershipOperationFailed))),("ncm_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'AddNodes_result' struct
default_AddNodes_result :: AddNodes_result
default_AddNodes_result = AddNodes_result{
  addNodes_result_success = Cluster_membership_Types.default_AddNodesResponse,
  addNodes_result_notready = Nothing,
  addNodes_result_failed_op = Nothing,
  addNodes_result_ncm_error = Nothing,
  addNodes_result_not_supported = Nothing}
-- | Definition of the UpdateNodes_args struct
data UpdateNodes_args = UpdateNodes_args
  { updateNodes_args_request :: Cluster_membership_Types.UpdateNodesRequest
    -- ^ request field of the UpdateNodes_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable UpdateNodes_args where
  encode = encode_UpdateNodes_args
  decode = decode_UpdateNodes_args
instance Hashable.Hashable UpdateNodes_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` updateNodes_args_request record  
instance DeepSeq.NFData UpdateNodes_args where
  rnf _record48 =
    DeepSeq.rnf (updateNodes_args_request _record48) `seq`
    ()
instance Arbitrary.Arbitrary UpdateNodes_args where 
  arbitrary = Monad.liftM UpdateNodes_args (Arbitrary.arbitrary)
  shrink obj | obj == default_UpdateNodes_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_UpdateNodes_args{updateNodes_args_request = updateNodes_args_request obj} then Nothing else Just $ default_UpdateNodes_args{updateNodes_args_request = updateNodes_args_request obj}
    ]
-- | Translate a 'UpdateNodes_args' to a 'Types.ThriftVal'
from_UpdateNodes_args :: UpdateNodes_args -> Types.ThriftVal
from_UpdateNodes_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v51 -> Just (1, ("request",Cluster_membership_Types.from_UpdateNodesRequest _v51))) $ updateNodes_args_request record
  ]
-- | Write a 'UpdateNodes_args' with the given 'Thrift.Protocol'
write_UpdateNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodes_args -> IO ()
write_UpdateNodes_args oprot record = Thrift.writeVal oprot $ from_UpdateNodes_args record
-- | Serialize a 'UpdateNodes_args' in pure code
encode_UpdateNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodes_args -> BS.ByteString
encode_UpdateNodes_args oprot record = Thrift.serializeVal oprot $ from_UpdateNodes_args record
-- | Translate a 'Types.ThriftVal' to a 'UpdateNodes_args'
to_UpdateNodes_args :: Types.ThriftVal -> UpdateNodes_args
to_UpdateNodes_args (Types.TStruct fields) = UpdateNodes_args{
  updateNodes_args_request = maybe (updateNodes_args_request default_UpdateNodes_args) (\(_,_val53) -> (case _val53 of {Types.TStruct _val54 -> (Cluster_membership_Types.to_UpdateNodesRequest (Types.TStruct _val54)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNodes_args _ = error "not a struct"
-- | Read a 'UpdateNodes_args' struct with the given 'Thrift.Protocol'
read_UpdateNodes_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO UpdateNodes_args
read_UpdateNodes_args iprot = to_UpdateNodes_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_UpdateNodes_args)
-- | Deserialize a 'UpdateNodes_args' in pure code
decode_UpdateNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> UpdateNodes_args
decode_UpdateNodes_args iprot bs = to_UpdateNodes_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_UpdateNodes_args) bs
-- | 'TypeMap' for the 'UpdateNodes_args' struct
typemap_UpdateNodes_args :: Types.TypeMap
typemap_UpdateNodes_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_UpdateNodesRequest)))]
-- | Default values for the 'UpdateNodes_args' struct
default_UpdateNodes_args :: UpdateNodes_args
default_UpdateNodes_args = UpdateNodes_args{
  updateNodes_args_request = Cluster_membership_Types.default_UpdateNodesRequest}
-- | Definition of the UpdateNodes_result struct
data UpdateNodes_result = UpdateNodes_result
  { updateNodes_result_success :: Cluster_membership_Types.UpdateNodesResponse
    -- ^ success field of the UpdateNodes_result struct
  , updateNodes_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the UpdateNodes_result struct
  , updateNodes_result_failed_op :: Maybe Cluster_membership_Types.ClusterMembershipOperationFailed
    -- ^ failed_op field of the UpdateNodes_result struct
  , updateNodes_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the UpdateNodes_result struct
  , updateNodes_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the UpdateNodes_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable UpdateNodes_result where
  encode = encode_UpdateNodes_result
  decode = decode_UpdateNodes_result
instance Hashable.Hashable UpdateNodes_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` updateNodes_result_success record   `Hashable.hashWithSalt` updateNodes_result_notready record   `Hashable.hashWithSalt` updateNodes_result_failed_op record   `Hashable.hashWithSalt` updateNodes_result_ncm_error record   `Hashable.hashWithSalt` updateNodes_result_not_supported record  
instance DeepSeq.NFData UpdateNodes_result where
  rnf _record55 =
    DeepSeq.rnf (updateNodes_result_success _record55) `seq`
    DeepSeq.rnf (updateNodes_result_notready _record55) `seq`
    DeepSeq.rnf (updateNodes_result_failed_op _record55) `seq`
    DeepSeq.rnf (updateNodes_result_ncm_error _record55) `seq`
    DeepSeq.rnf (updateNodes_result_not_supported _record55) `seq`
    ()
instance Arbitrary.Arbitrary UpdateNodes_result where 
  arbitrary = Monad.liftM UpdateNodes_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_UpdateNodes_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_UpdateNodes_result{updateNodes_result_success = updateNodes_result_success obj} then Nothing else Just $ default_UpdateNodes_result{updateNodes_result_success = updateNodes_result_success obj}
    , if obj == default_UpdateNodes_result{updateNodes_result_notready = updateNodes_result_notready obj} then Nothing else Just $ default_UpdateNodes_result{updateNodes_result_notready = updateNodes_result_notready obj}
    , if obj == default_UpdateNodes_result{updateNodes_result_failed_op = updateNodes_result_failed_op obj} then Nothing else Just $ default_UpdateNodes_result{updateNodes_result_failed_op = updateNodes_result_failed_op obj}
    , if obj == default_UpdateNodes_result{updateNodes_result_ncm_error = updateNodes_result_ncm_error obj} then Nothing else Just $ default_UpdateNodes_result{updateNodes_result_ncm_error = updateNodes_result_ncm_error obj}
    , if obj == default_UpdateNodes_result{updateNodes_result_not_supported = updateNodes_result_not_supported obj} then Nothing else Just $ default_UpdateNodes_result{updateNodes_result_not_supported = updateNodes_result_not_supported obj}
    ]
-- | Translate a 'UpdateNodes_result' to a 'Types.ThriftVal'
from_UpdateNodes_result :: UpdateNodes_result -> Types.ThriftVal
from_UpdateNodes_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v58 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v58))) <$> updateNodes_result_notready record, (\_v58 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v58))) <$> updateNodes_result_failed_op record, (\_v58 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v58))) <$> updateNodes_result_ncm_error record, (\_v58 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v58))) <$> updateNodes_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v58 -> Just (0, ("success",Cluster_membership_Types.from_UpdateNodesResponse _v58))) $ updateNodes_result_success record
    , (\_v58 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v58))) <$> updateNodes_result_notready record
    , (\_v58 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v58))) <$> updateNodes_result_failed_op record
    , (\_v58 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v58))) <$> updateNodes_result_ncm_error record
    , (\_v58 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v58))) <$> updateNodes_result_not_supported record
    ]
    )
-- | Write a 'UpdateNodes_result' with the given 'Thrift.Protocol'
write_UpdateNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodes_result -> IO ()
write_UpdateNodes_result oprot record = Thrift.writeVal oprot $ from_UpdateNodes_result record
-- | Serialize a 'UpdateNodes_result' in pure code
encode_UpdateNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> UpdateNodes_result -> BS.ByteString
encode_UpdateNodes_result oprot record = Thrift.serializeVal oprot $ from_UpdateNodes_result record
-- | Translate a 'Types.ThriftVal' to a 'UpdateNodes_result'
to_UpdateNodes_result :: Types.ThriftVal -> UpdateNodes_result
to_UpdateNodes_result (Types.TStruct fields) = UpdateNodes_result{
  updateNodes_result_success = maybe (updateNodes_result_success default_UpdateNodes_result) (\(_,_val60) -> (case _val60 of {Types.TStruct _val61 -> (Cluster_membership_Types.to_UpdateNodesResponse (Types.TStruct _val61)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  updateNodes_result_notready = maybe (Nothing) (\(_,_val60) -> Just (case _val60 of {Types.TStruct _val62 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val62)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  updateNodes_result_failed_op = maybe (Nothing) (\(_,_val60) -> Just (case _val60 of {Types.TStruct _val63 -> (Cluster_membership_Types.to_ClusterMembershipOperationFailed (Types.TStruct _val63)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  updateNodes_result_ncm_error = maybe (Nothing) (\(_,_val60) -> Just (case _val60 of {Types.TStruct _val64 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val64)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  updateNodes_result_not_supported = maybe (Nothing) (\(_,_val60) -> Just (case _val60 of {Types.TStruct _val65 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val65)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_UpdateNodes_result _ = error "not a struct"
-- | Read a 'UpdateNodes_result' struct with the given 'Thrift.Protocol'
read_UpdateNodes_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO UpdateNodes_result
read_UpdateNodes_result iprot = to_UpdateNodes_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_UpdateNodes_result)
-- | Deserialize a 'UpdateNodes_result' in pure code
decode_UpdateNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> UpdateNodes_result
decode_UpdateNodes_result iprot bs = to_UpdateNodes_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_UpdateNodes_result) bs
-- | 'TypeMap' for the 'UpdateNodes_result' struct
typemap_UpdateNodes_result :: Types.TypeMap
typemap_UpdateNodes_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_UpdateNodesResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("failed_op",(2,(Types.T_STRUCT Cluster_membership_Types.typemap_ClusterMembershipOperationFailed))),("ncm_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'UpdateNodes_result' struct
default_UpdateNodes_result :: UpdateNodes_result
default_UpdateNodes_result = UpdateNodes_result{
  updateNodes_result_success = Cluster_membership_Types.default_UpdateNodesResponse,
  updateNodes_result_notready = Nothing,
  updateNodes_result_failed_op = Nothing,
  updateNodes_result_ncm_error = Nothing,
  updateNodes_result_not_supported = Nothing}
-- | Definition of the RemoveNodes_args struct
data RemoveNodes_args = RemoveNodes_args
  { removeNodes_args_request :: Cluster_membership_Types.RemoveNodesRequest
    -- ^ request field of the RemoveNodes_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveNodes_args where
  encode = encode_RemoveNodes_args
  decode = decode_RemoveNodes_args
instance Hashable.Hashable RemoveNodes_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeNodes_args_request record  
instance DeepSeq.NFData RemoveNodes_args where
  rnf _record66 =
    DeepSeq.rnf (removeNodes_args_request _record66) `seq`
    ()
instance Arbitrary.Arbitrary RemoveNodes_args where 
  arbitrary = Monad.liftM RemoveNodes_args (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveNodes_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveNodes_args{removeNodes_args_request = removeNodes_args_request obj} then Nothing else Just $ default_RemoveNodes_args{removeNodes_args_request = removeNodes_args_request obj}
    ]
-- | Translate a 'RemoveNodes_args' to a 'Types.ThriftVal'
from_RemoveNodes_args :: RemoveNodes_args -> Types.ThriftVal
from_RemoveNodes_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v69 -> Just (1, ("request",Cluster_membership_Types.from_RemoveNodesRequest _v69))) $ removeNodes_args_request record
  ]
-- | Write a 'RemoveNodes_args' with the given 'Thrift.Protocol'
write_RemoveNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodes_args -> IO ()
write_RemoveNodes_args oprot record = Thrift.writeVal oprot $ from_RemoveNodes_args record
-- | Serialize a 'RemoveNodes_args' in pure code
encode_RemoveNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodes_args -> BS.ByteString
encode_RemoveNodes_args oprot record = Thrift.serializeVal oprot $ from_RemoveNodes_args record
-- | Translate a 'Types.ThriftVal' to a 'RemoveNodes_args'
to_RemoveNodes_args :: Types.ThriftVal -> RemoveNodes_args
to_RemoveNodes_args (Types.TStruct fields) = RemoveNodes_args{
  removeNodes_args_request = maybe (removeNodes_args_request default_RemoveNodes_args) (\(_,_val71) -> (case _val71 of {Types.TStruct _val72 -> (Cluster_membership_Types.to_RemoveNodesRequest (Types.TStruct _val72)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveNodes_args _ = error "not a struct"
-- | Read a 'RemoveNodes_args' struct with the given 'Thrift.Protocol'
read_RemoveNodes_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveNodes_args
read_RemoveNodes_args iprot = to_RemoveNodes_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveNodes_args)
-- | Deserialize a 'RemoveNodes_args' in pure code
decode_RemoveNodes_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveNodes_args
decode_RemoveNodes_args iprot bs = to_RemoveNodes_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveNodes_args) bs
-- | 'TypeMap' for the 'RemoveNodes_args' struct
typemap_RemoveNodes_args :: Types.TypeMap
typemap_RemoveNodes_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_RemoveNodesRequest)))]
-- | Default values for the 'RemoveNodes_args' struct
default_RemoveNodes_args :: RemoveNodes_args
default_RemoveNodes_args = RemoveNodes_args{
  removeNodes_args_request = Cluster_membership_Types.default_RemoveNodesRequest}
-- | Definition of the RemoveNodes_result struct
data RemoveNodes_result = RemoveNodes_result
  { removeNodes_result_success :: Cluster_membership_Types.RemoveNodesResponse
    -- ^ success field of the RemoveNodes_result struct
  , removeNodes_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the RemoveNodes_result struct
  , removeNodes_result_failed_op :: Maybe Cluster_membership_Types.ClusterMembershipOperationFailed
    -- ^ failed_op field of the RemoveNodes_result struct
  , removeNodes_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the RemoveNodes_result struct
  , removeNodes_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the RemoveNodes_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveNodes_result where
  encode = encode_RemoveNodes_result
  decode = decode_RemoveNodes_result
instance Hashable.Hashable RemoveNodes_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeNodes_result_success record   `Hashable.hashWithSalt` removeNodes_result_notready record   `Hashable.hashWithSalt` removeNodes_result_failed_op record   `Hashable.hashWithSalt` removeNodes_result_ncm_error record   `Hashable.hashWithSalt` removeNodes_result_not_supported record  
instance DeepSeq.NFData RemoveNodes_result where
  rnf _record73 =
    DeepSeq.rnf (removeNodes_result_success _record73) `seq`
    DeepSeq.rnf (removeNodes_result_notready _record73) `seq`
    DeepSeq.rnf (removeNodes_result_failed_op _record73) `seq`
    DeepSeq.rnf (removeNodes_result_ncm_error _record73) `seq`
    DeepSeq.rnf (removeNodes_result_not_supported _record73) `seq`
    ()
instance Arbitrary.Arbitrary RemoveNodes_result where 
  arbitrary = Monad.liftM RemoveNodes_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveNodes_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveNodes_result{removeNodes_result_success = removeNodes_result_success obj} then Nothing else Just $ default_RemoveNodes_result{removeNodes_result_success = removeNodes_result_success obj}
    , if obj == default_RemoveNodes_result{removeNodes_result_notready = removeNodes_result_notready obj} then Nothing else Just $ default_RemoveNodes_result{removeNodes_result_notready = removeNodes_result_notready obj}
    , if obj == default_RemoveNodes_result{removeNodes_result_failed_op = removeNodes_result_failed_op obj} then Nothing else Just $ default_RemoveNodes_result{removeNodes_result_failed_op = removeNodes_result_failed_op obj}
    , if obj == default_RemoveNodes_result{removeNodes_result_ncm_error = removeNodes_result_ncm_error obj} then Nothing else Just $ default_RemoveNodes_result{removeNodes_result_ncm_error = removeNodes_result_ncm_error obj}
    , if obj == default_RemoveNodes_result{removeNodes_result_not_supported = removeNodes_result_not_supported obj} then Nothing else Just $ default_RemoveNodes_result{removeNodes_result_not_supported = removeNodes_result_not_supported obj}
    ]
-- | Translate a 'RemoveNodes_result' to a 'Types.ThriftVal'
from_RemoveNodes_result :: RemoveNodes_result -> Types.ThriftVal
from_RemoveNodes_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v76 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v76))) <$> removeNodes_result_notready record, (\_v76 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v76))) <$> removeNodes_result_failed_op record, (\_v76 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v76))) <$> removeNodes_result_ncm_error record, (\_v76 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v76))) <$> removeNodes_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v76 -> Just (0, ("success",Cluster_membership_Types.from_RemoveNodesResponse _v76))) $ removeNodes_result_success record
    , (\_v76 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v76))) <$> removeNodes_result_notready record
    , (\_v76 -> (2, ("failed_op",Cluster_membership_Types.from_ClusterMembershipOperationFailed _v76))) <$> removeNodes_result_failed_op record
    , (\_v76 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v76))) <$> removeNodes_result_ncm_error record
    , (\_v76 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v76))) <$> removeNodes_result_not_supported record
    ]
    )
-- | Write a 'RemoveNodes_result' with the given 'Thrift.Protocol'
write_RemoveNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodes_result -> IO ()
write_RemoveNodes_result oprot record = Thrift.writeVal oprot $ from_RemoveNodes_result record
-- | Serialize a 'RemoveNodes_result' in pure code
encode_RemoveNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveNodes_result -> BS.ByteString
encode_RemoveNodes_result oprot record = Thrift.serializeVal oprot $ from_RemoveNodes_result record
-- | Translate a 'Types.ThriftVal' to a 'RemoveNodes_result'
to_RemoveNodes_result :: Types.ThriftVal -> RemoveNodes_result
to_RemoveNodes_result (Types.TStruct fields) = RemoveNodes_result{
  removeNodes_result_success = maybe (removeNodes_result_success default_RemoveNodes_result) (\(_,_val78) -> (case _val78 of {Types.TStruct _val79 -> (Cluster_membership_Types.to_RemoveNodesResponse (Types.TStruct _val79)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  removeNodes_result_notready = maybe (Nothing) (\(_,_val78) -> Just (case _val78 of {Types.TStruct _val80 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val80)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  removeNodes_result_failed_op = maybe (Nothing) (\(_,_val78) -> Just (case _val78 of {Types.TStruct _val81 -> (Cluster_membership_Types.to_ClusterMembershipOperationFailed (Types.TStruct _val81)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  removeNodes_result_ncm_error = maybe (Nothing) (\(_,_val78) -> Just (case _val78 of {Types.TStruct _val82 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val82)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  removeNodes_result_not_supported = maybe (Nothing) (\(_,_val78) -> Just (case _val78 of {Types.TStruct _val83 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val83)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_RemoveNodes_result _ = error "not a struct"
-- | Read a 'RemoveNodes_result' struct with the given 'Thrift.Protocol'
read_RemoveNodes_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveNodes_result
read_RemoveNodes_result iprot = to_RemoveNodes_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveNodes_result)
-- | Deserialize a 'RemoveNodes_result' in pure code
decode_RemoveNodes_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveNodes_result
decode_RemoveNodes_result iprot bs = to_RemoveNodes_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveNodes_result) bs
-- | 'TypeMap' for the 'RemoveNodes_result' struct
typemap_RemoveNodes_result :: Types.TypeMap
typemap_RemoveNodes_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_RemoveNodesResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("failed_op",(2,(Types.T_STRUCT Cluster_membership_Types.typemap_ClusterMembershipOperationFailed))),("ncm_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'RemoveNodes_result' struct
default_RemoveNodes_result :: RemoveNodes_result
default_RemoveNodes_result = RemoveNodes_result{
  removeNodes_result_success = Cluster_membership_Types.default_RemoveNodesResponse,
  removeNodes_result_notready = Nothing,
  removeNodes_result_failed_op = Nothing,
  removeNodes_result_ncm_error = Nothing,
  removeNodes_result_not_supported = Nothing}
-- | Definition of the MarkShardsAsProvisioned_args struct
data MarkShardsAsProvisioned_args = MarkShardsAsProvisioned_args
  { markShardsAsProvisioned_args_request :: Cluster_membership_Types.MarkShardsAsProvisionedRequest
    -- ^ request field of the MarkShardsAsProvisioned_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkShardsAsProvisioned_args where
  encode = encode_MarkShardsAsProvisioned_args
  decode = decode_MarkShardsAsProvisioned_args
instance Hashable.Hashable MarkShardsAsProvisioned_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markShardsAsProvisioned_args_request record  
instance DeepSeq.NFData MarkShardsAsProvisioned_args where
  rnf _record84 =
    DeepSeq.rnf (markShardsAsProvisioned_args_request _record84) `seq`
    ()
instance Arbitrary.Arbitrary MarkShardsAsProvisioned_args where 
  arbitrary = Monad.liftM MarkShardsAsProvisioned_args (Arbitrary.arbitrary)
  shrink obj | obj == default_MarkShardsAsProvisioned_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkShardsAsProvisioned_args{markShardsAsProvisioned_args_request = markShardsAsProvisioned_args_request obj} then Nothing else Just $ default_MarkShardsAsProvisioned_args{markShardsAsProvisioned_args_request = markShardsAsProvisioned_args_request obj}
    ]
-- | Translate a 'MarkShardsAsProvisioned_args' to a 'Types.ThriftVal'
from_MarkShardsAsProvisioned_args :: MarkShardsAsProvisioned_args -> Types.ThriftVal
from_MarkShardsAsProvisioned_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v87 -> Just (1, ("request",Cluster_membership_Types.from_MarkShardsAsProvisionedRequest _v87))) $ markShardsAsProvisioned_args_request record
  ]
-- | Write a 'MarkShardsAsProvisioned_args' with the given 'Thrift.Protocol'
write_MarkShardsAsProvisioned_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisioned_args -> IO ()
write_MarkShardsAsProvisioned_args oprot record = Thrift.writeVal oprot $ from_MarkShardsAsProvisioned_args record
-- | Serialize a 'MarkShardsAsProvisioned_args' in pure code
encode_MarkShardsAsProvisioned_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisioned_args -> BS.ByteString
encode_MarkShardsAsProvisioned_args oprot record = Thrift.serializeVal oprot $ from_MarkShardsAsProvisioned_args record
-- | Translate a 'Types.ThriftVal' to a 'MarkShardsAsProvisioned_args'
to_MarkShardsAsProvisioned_args :: Types.ThriftVal -> MarkShardsAsProvisioned_args
to_MarkShardsAsProvisioned_args (Types.TStruct fields) = MarkShardsAsProvisioned_args{
  markShardsAsProvisioned_args_request = maybe (markShardsAsProvisioned_args_request default_MarkShardsAsProvisioned_args) (\(_,_val89) -> (case _val89 of {Types.TStruct _val90 -> (Cluster_membership_Types.to_MarkShardsAsProvisionedRequest (Types.TStruct _val90)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkShardsAsProvisioned_args _ = error "not a struct"
-- | Read a 'MarkShardsAsProvisioned_args' struct with the given 'Thrift.Protocol'
read_MarkShardsAsProvisioned_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkShardsAsProvisioned_args
read_MarkShardsAsProvisioned_args iprot = to_MarkShardsAsProvisioned_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisioned_args)
-- | Deserialize a 'MarkShardsAsProvisioned_args' in pure code
decode_MarkShardsAsProvisioned_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkShardsAsProvisioned_args
decode_MarkShardsAsProvisioned_args iprot bs = to_MarkShardsAsProvisioned_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisioned_args) bs
-- | 'TypeMap' for the 'MarkShardsAsProvisioned_args' struct
typemap_MarkShardsAsProvisioned_args :: Types.TypeMap
typemap_MarkShardsAsProvisioned_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_MarkShardsAsProvisionedRequest)))]
-- | Default values for the 'MarkShardsAsProvisioned_args' struct
default_MarkShardsAsProvisioned_args :: MarkShardsAsProvisioned_args
default_MarkShardsAsProvisioned_args = MarkShardsAsProvisioned_args{
  markShardsAsProvisioned_args_request = Cluster_membership_Types.default_MarkShardsAsProvisionedRequest}
-- | Definition of the MarkShardsAsProvisioned_result struct
data MarkShardsAsProvisioned_result = MarkShardsAsProvisioned_result
  { markShardsAsProvisioned_result_success :: Cluster_membership_Types.MarkShardsAsProvisionedResponse
    -- ^ success field of the MarkShardsAsProvisioned_result struct
  , markShardsAsProvisioned_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the MarkShardsAsProvisioned_result struct
  , markShardsAsProvisioned_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the MarkShardsAsProvisioned_result struct
  , markShardsAsProvisioned_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the MarkShardsAsProvisioned_result struct
  , markShardsAsProvisioned_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the MarkShardsAsProvisioned_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkShardsAsProvisioned_result where
  encode = encode_MarkShardsAsProvisioned_result
  decode = decode_MarkShardsAsProvisioned_result
instance Hashable.Hashable MarkShardsAsProvisioned_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markShardsAsProvisioned_result_success record   `Hashable.hashWithSalt` markShardsAsProvisioned_result_notready record   `Hashable.hashWithSalt` markShardsAsProvisioned_result_invalid_request record   `Hashable.hashWithSalt` markShardsAsProvisioned_result_ncm_error record   `Hashable.hashWithSalt` markShardsAsProvisioned_result_not_supported record  
instance DeepSeq.NFData MarkShardsAsProvisioned_result where
  rnf _record91 =
    DeepSeq.rnf (markShardsAsProvisioned_result_success _record91) `seq`
    DeepSeq.rnf (markShardsAsProvisioned_result_notready _record91) `seq`
    DeepSeq.rnf (markShardsAsProvisioned_result_invalid_request _record91) `seq`
    DeepSeq.rnf (markShardsAsProvisioned_result_ncm_error _record91) `seq`
    DeepSeq.rnf (markShardsAsProvisioned_result_not_supported _record91) `seq`
    ()
instance Arbitrary.Arbitrary MarkShardsAsProvisioned_result where 
  arbitrary = Monad.liftM MarkShardsAsProvisioned_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_MarkShardsAsProvisioned_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_success = markShardsAsProvisioned_result_success obj} then Nothing else Just $ default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_success = markShardsAsProvisioned_result_success obj}
    , if obj == default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_notready = markShardsAsProvisioned_result_notready obj} then Nothing else Just $ default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_notready = markShardsAsProvisioned_result_notready obj}
    , if obj == default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_invalid_request = markShardsAsProvisioned_result_invalid_request obj} then Nothing else Just $ default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_invalid_request = markShardsAsProvisioned_result_invalid_request obj}
    , if obj == default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_ncm_error = markShardsAsProvisioned_result_ncm_error obj} then Nothing else Just $ default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_ncm_error = markShardsAsProvisioned_result_ncm_error obj}
    , if obj == default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_not_supported = markShardsAsProvisioned_result_not_supported obj} then Nothing else Just $ default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_not_supported = markShardsAsProvisioned_result_not_supported obj}
    ]
-- | Translate a 'MarkShardsAsProvisioned_result' to a 'Types.ThriftVal'
from_MarkShardsAsProvisioned_result :: MarkShardsAsProvisioned_result -> Types.ThriftVal
from_MarkShardsAsProvisioned_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v94 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v94))) <$> markShardsAsProvisioned_result_notready record, (\_v94 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v94))) <$> markShardsAsProvisioned_result_invalid_request record, (\_v94 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v94))) <$> markShardsAsProvisioned_result_ncm_error record, (\_v94 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v94))) <$> markShardsAsProvisioned_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v94 -> Just (0, ("success",Cluster_membership_Types.from_MarkShardsAsProvisionedResponse _v94))) $ markShardsAsProvisioned_result_success record
    , (\_v94 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v94))) <$> markShardsAsProvisioned_result_notready record
    , (\_v94 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v94))) <$> markShardsAsProvisioned_result_invalid_request record
    , (\_v94 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v94))) <$> markShardsAsProvisioned_result_ncm_error record
    , (\_v94 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v94))) <$> markShardsAsProvisioned_result_not_supported record
    ]
    )
-- | Write a 'MarkShardsAsProvisioned_result' with the given 'Thrift.Protocol'
write_MarkShardsAsProvisioned_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisioned_result -> IO ()
write_MarkShardsAsProvisioned_result oprot record = Thrift.writeVal oprot $ from_MarkShardsAsProvisioned_result record
-- | Serialize a 'MarkShardsAsProvisioned_result' in pure code
encode_MarkShardsAsProvisioned_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkShardsAsProvisioned_result -> BS.ByteString
encode_MarkShardsAsProvisioned_result oprot record = Thrift.serializeVal oprot $ from_MarkShardsAsProvisioned_result record
-- | Translate a 'Types.ThriftVal' to a 'MarkShardsAsProvisioned_result'
to_MarkShardsAsProvisioned_result :: Types.ThriftVal -> MarkShardsAsProvisioned_result
to_MarkShardsAsProvisioned_result (Types.TStruct fields) = MarkShardsAsProvisioned_result{
  markShardsAsProvisioned_result_success = maybe (markShardsAsProvisioned_result_success default_MarkShardsAsProvisioned_result) (\(_,_val96) -> (case _val96 of {Types.TStruct _val97 -> (Cluster_membership_Types.to_MarkShardsAsProvisionedResponse (Types.TStruct _val97)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  markShardsAsProvisioned_result_notready = maybe (Nothing) (\(_,_val96) -> Just (case _val96 of {Types.TStruct _val98 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val98)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  markShardsAsProvisioned_result_invalid_request = maybe (Nothing) (\(_,_val96) -> Just (case _val96 of {Types.TStruct _val99 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val99)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  markShardsAsProvisioned_result_ncm_error = maybe (Nothing) (\(_,_val96) -> Just (case _val96 of {Types.TStruct _val100 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val100)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  markShardsAsProvisioned_result_not_supported = maybe (Nothing) (\(_,_val96) -> Just (case _val96 of {Types.TStruct _val101 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val101)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_MarkShardsAsProvisioned_result _ = error "not a struct"
-- | Read a 'MarkShardsAsProvisioned_result' struct with the given 'Thrift.Protocol'
read_MarkShardsAsProvisioned_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkShardsAsProvisioned_result
read_MarkShardsAsProvisioned_result iprot = to_MarkShardsAsProvisioned_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisioned_result)
-- | Deserialize a 'MarkShardsAsProvisioned_result' in pure code
decode_MarkShardsAsProvisioned_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkShardsAsProvisioned_result
decode_MarkShardsAsProvisioned_result iprot bs = to_MarkShardsAsProvisioned_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkShardsAsProvisioned_result) bs
-- | 'TypeMap' for the 'MarkShardsAsProvisioned_result' struct
typemap_MarkShardsAsProvisioned_result :: Types.TypeMap
typemap_MarkShardsAsProvisioned_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_MarkShardsAsProvisionedResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("ncm_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'MarkShardsAsProvisioned_result' struct
default_MarkShardsAsProvisioned_result :: MarkShardsAsProvisioned_result
default_MarkShardsAsProvisioned_result = MarkShardsAsProvisioned_result{
  markShardsAsProvisioned_result_success = Cluster_membership_Types.default_MarkShardsAsProvisionedResponse,
  markShardsAsProvisioned_result_notready = Nothing,
  markShardsAsProvisioned_result_invalid_request = Nothing,
  markShardsAsProvisioned_result_ncm_error = Nothing,
  markShardsAsProvisioned_result_not_supported = Nothing}
-- | Definition of the BumpNodeGeneration_args struct
data BumpNodeGeneration_args = BumpNodeGeneration_args
  { bumpNodeGeneration_args_request :: Cluster_membership_Types.BumpGenerationRequest
    -- ^ request field of the BumpNodeGeneration_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BumpNodeGeneration_args where
  encode = encode_BumpNodeGeneration_args
  decode = decode_BumpNodeGeneration_args
instance Hashable.Hashable BumpNodeGeneration_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bumpNodeGeneration_args_request record  
instance DeepSeq.NFData BumpNodeGeneration_args where
  rnf _record102 =
    DeepSeq.rnf (bumpNodeGeneration_args_request _record102) `seq`
    ()
instance Arbitrary.Arbitrary BumpNodeGeneration_args where 
  arbitrary = Monad.liftM BumpNodeGeneration_args (Arbitrary.arbitrary)
  shrink obj | obj == default_BumpNodeGeneration_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BumpNodeGeneration_args{bumpNodeGeneration_args_request = bumpNodeGeneration_args_request obj} then Nothing else Just $ default_BumpNodeGeneration_args{bumpNodeGeneration_args_request = bumpNodeGeneration_args_request obj}
    ]
-- | Translate a 'BumpNodeGeneration_args' to a 'Types.ThriftVal'
from_BumpNodeGeneration_args :: BumpNodeGeneration_args -> Types.ThriftVal
from_BumpNodeGeneration_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v105 -> Just (1, ("request",Cluster_membership_Types.from_BumpGenerationRequest _v105))) $ bumpNodeGeneration_args_request record
  ]
-- | Write a 'BumpNodeGeneration_args' with the given 'Thrift.Protocol'
write_BumpNodeGeneration_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpNodeGeneration_args -> IO ()
write_BumpNodeGeneration_args oprot record = Thrift.writeVal oprot $ from_BumpNodeGeneration_args record
-- | Serialize a 'BumpNodeGeneration_args' in pure code
encode_BumpNodeGeneration_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpNodeGeneration_args -> BS.ByteString
encode_BumpNodeGeneration_args oprot record = Thrift.serializeVal oprot $ from_BumpNodeGeneration_args record
-- | Translate a 'Types.ThriftVal' to a 'BumpNodeGeneration_args'
to_BumpNodeGeneration_args :: Types.ThriftVal -> BumpNodeGeneration_args
to_BumpNodeGeneration_args (Types.TStruct fields) = BumpNodeGeneration_args{
  bumpNodeGeneration_args_request = maybe (bumpNodeGeneration_args_request default_BumpNodeGeneration_args) (\(_,_val107) -> (case _val107 of {Types.TStruct _val108 -> (Cluster_membership_Types.to_BumpGenerationRequest (Types.TStruct _val108)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_BumpNodeGeneration_args _ = error "not a struct"
-- | Read a 'BumpNodeGeneration_args' struct with the given 'Thrift.Protocol'
read_BumpNodeGeneration_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BumpNodeGeneration_args
read_BumpNodeGeneration_args iprot = to_BumpNodeGeneration_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BumpNodeGeneration_args)
-- | Deserialize a 'BumpNodeGeneration_args' in pure code
decode_BumpNodeGeneration_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BumpNodeGeneration_args
decode_BumpNodeGeneration_args iprot bs = to_BumpNodeGeneration_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BumpNodeGeneration_args) bs
-- | 'TypeMap' for the 'BumpNodeGeneration_args' struct
typemap_BumpNodeGeneration_args :: Types.TypeMap
typemap_BumpNodeGeneration_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_BumpGenerationRequest)))]
-- | Default values for the 'BumpNodeGeneration_args' struct
default_BumpNodeGeneration_args :: BumpNodeGeneration_args
default_BumpNodeGeneration_args = BumpNodeGeneration_args{
  bumpNodeGeneration_args_request = Cluster_membership_Types.default_BumpGenerationRequest}
-- | Definition of the BumpNodeGeneration_result struct
data BumpNodeGeneration_result = BumpNodeGeneration_result
  { bumpNodeGeneration_result_success :: Cluster_membership_Types.BumpGenerationResponse
    -- ^ success field of the BumpNodeGeneration_result struct
  , bumpNodeGeneration_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the BumpNodeGeneration_result struct
  , bumpNodeGeneration_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the BumpNodeGeneration_result struct
  , bumpNodeGeneration_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the BumpNodeGeneration_result struct
  , bumpNodeGeneration_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the BumpNodeGeneration_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BumpNodeGeneration_result where
  encode = encode_BumpNodeGeneration_result
  decode = decode_BumpNodeGeneration_result
instance Hashable.Hashable BumpNodeGeneration_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bumpNodeGeneration_result_success record   `Hashable.hashWithSalt` bumpNodeGeneration_result_notready record   `Hashable.hashWithSalt` bumpNodeGeneration_result_invalid_request record   `Hashable.hashWithSalt` bumpNodeGeneration_result_ncm_error record   `Hashable.hashWithSalt` bumpNodeGeneration_result_not_supported record  
instance DeepSeq.NFData BumpNodeGeneration_result where
  rnf _record109 =
    DeepSeq.rnf (bumpNodeGeneration_result_success _record109) `seq`
    DeepSeq.rnf (bumpNodeGeneration_result_notready _record109) `seq`
    DeepSeq.rnf (bumpNodeGeneration_result_invalid_request _record109) `seq`
    DeepSeq.rnf (bumpNodeGeneration_result_ncm_error _record109) `seq`
    DeepSeq.rnf (bumpNodeGeneration_result_not_supported _record109) `seq`
    ()
instance Arbitrary.Arbitrary BumpNodeGeneration_result where 
  arbitrary = Monad.liftM BumpNodeGeneration_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_BumpNodeGeneration_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BumpNodeGeneration_result{bumpNodeGeneration_result_success = bumpNodeGeneration_result_success obj} then Nothing else Just $ default_BumpNodeGeneration_result{bumpNodeGeneration_result_success = bumpNodeGeneration_result_success obj}
    , if obj == default_BumpNodeGeneration_result{bumpNodeGeneration_result_notready = bumpNodeGeneration_result_notready obj} then Nothing else Just $ default_BumpNodeGeneration_result{bumpNodeGeneration_result_notready = bumpNodeGeneration_result_notready obj}
    , if obj == default_BumpNodeGeneration_result{bumpNodeGeneration_result_invalid_request = bumpNodeGeneration_result_invalid_request obj} then Nothing else Just $ default_BumpNodeGeneration_result{bumpNodeGeneration_result_invalid_request = bumpNodeGeneration_result_invalid_request obj}
    , if obj == default_BumpNodeGeneration_result{bumpNodeGeneration_result_ncm_error = bumpNodeGeneration_result_ncm_error obj} then Nothing else Just $ default_BumpNodeGeneration_result{bumpNodeGeneration_result_ncm_error = bumpNodeGeneration_result_ncm_error obj}
    , if obj == default_BumpNodeGeneration_result{bumpNodeGeneration_result_not_supported = bumpNodeGeneration_result_not_supported obj} then Nothing else Just $ default_BumpNodeGeneration_result{bumpNodeGeneration_result_not_supported = bumpNodeGeneration_result_not_supported obj}
    ]
-- | Translate a 'BumpNodeGeneration_result' to a 'Types.ThriftVal'
from_BumpNodeGeneration_result :: BumpNodeGeneration_result -> Types.ThriftVal
from_BumpNodeGeneration_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v112 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v112))) <$> bumpNodeGeneration_result_notready record, (\_v112 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v112))) <$> bumpNodeGeneration_result_invalid_request record, (\_v112 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v112))) <$> bumpNodeGeneration_result_ncm_error record, (\_v112 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v112))) <$> bumpNodeGeneration_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v112 -> Just (0, ("success",Cluster_membership_Types.from_BumpGenerationResponse _v112))) $ bumpNodeGeneration_result_success record
    , (\_v112 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v112))) <$> bumpNodeGeneration_result_notready record
    , (\_v112 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v112))) <$> bumpNodeGeneration_result_invalid_request record
    , (\_v112 -> (3, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v112))) <$> bumpNodeGeneration_result_ncm_error record
    , (\_v112 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v112))) <$> bumpNodeGeneration_result_not_supported record
    ]
    )
-- | Write a 'BumpNodeGeneration_result' with the given 'Thrift.Protocol'
write_BumpNodeGeneration_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpNodeGeneration_result -> IO ()
write_BumpNodeGeneration_result oprot record = Thrift.writeVal oprot $ from_BumpNodeGeneration_result record
-- | Serialize a 'BumpNodeGeneration_result' in pure code
encode_BumpNodeGeneration_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BumpNodeGeneration_result -> BS.ByteString
encode_BumpNodeGeneration_result oprot record = Thrift.serializeVal oprot $ from_BumpNodeGeneration_result record
-- | Translate a 'Types.ThriftVal' to a 'BumpNodeGeneration_result'
to_BumpNodeGeneration_result :: Types.ThriftVal -> BumpNodeGeneration_result
to_BumpNodeGeneration_result (Types.TStruct fields) = BumpNodeGeneration_result{
  bumpNodeGeneration_result_success = maybe (bumpNodeGeneration_result_success default_BumpNodeGeneration_result) (\(_,_val114) -> (case _val114 of {Types.TStruct _val115 -> (Cluster_membership_Types.to_BumpGenerationResponse (Types.TStruct _val115)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  bumpNodeGeneration_result_notready = maybe (Nothing) (\(_,_val114) -> Just (case _val114 of {Types.TStruct _val116 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val116)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  bumpNodeGeneration_result_invalid_request = maybe (Nothing) (\(_,_val114) -> Just (case _val114 of {Types.TStruct _val117 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val117)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  bumpNodeGeneration_result_ncm_error = maybe (Nothing) (\(_,_val114) -> Just (case _val114 of {Types.TStruct _val118 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val118)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  bumpNodeGeneration_result_not_supported = maybe (Nothing) (\(_,_val114) -> Just (case _val114 of {Types.TStruct _val119 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val119)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_BumpNodeGeneration_result _ = error "not a struct"
-- | Read a 'BumpNodeGeneration_result' struct with the given 'Thrift.Protocol'
read_BumpNodeGeneration_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BumpNodeGeneration_result
read_BumpNodeGeneration_result iprot = to_BumpNodeGeneration_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BumpNodeGeneration_result)
-- | Deserialize a 'BumpNodeGeneration_result' in pure code
decode_BumpNodeGeneration_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BumpNodeGeneration_result
decode_BumpNodeGeneration_result iprot bs = to_BumpNodeGeneration_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BumpNodeGeneration_result) bs
-- | 'TypeMap' for the 'BumpNodeGeneration_result' struct
typemap_BumpNodeGeneration_result :: Types.TypeMap
typemap_BumpNodeGeneration_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_BumpGenerationResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("ncm_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'BumpNodeGeneration_result' struct
default_BumpNodeGeneration_result :: BumpNodeGeneration_result
default_BumpNodeGeneration_result = BumpNodeGeneration_result{
  bumpNodeGeneration_result_success = Cluster_membership_Types.default_BumpGenerationResponse,
  bumpNodeGeneration_result_notready = Nothing,
  bumpNodeGeneration_result_invalid_request = Nothing,
  bumpNodeGeneration_result_ncm_error = Nothing,
  bumpNodeGeneration_result_not_supported = Nothing}
-- | Definition of the BootstrapCluster_args struct
data BootstrapCluster_args = BootstrapCluster_args
  { bootstrapCluster_args_request :: Cluster_membership_Types.BootstrapClusterRequest
    -- ^ request field of the BootstrapCluster_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BootstrapCluster_args where
  encode = encode_BootstrapCluster_args
  decode = decode_BootstrapCluster_args
instance Hashable.Hashable BootstrapCluster_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bootstrapCluster_args_request record  
instance DeepSeq.NFData BootstrapCluster_args where
  rnf _record120 =
    DeepSeq.rnf (bootstrapCluster_args_request _record120) `seq`
    ()
instance Arbitrary.Arbitrary BootstrapCluster_args where 
  arbitrary = Monad.liftM BootstrapCluster_args (Arbitrary.arbitrary)
  shrink obj | obj == default_BootstrapCluster_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BootstrapCluster_args{bootstrapCluster_args_request = bootstrapCluster_args_request obj} then Nothing else Just $ default_BootstrapCluster_args{bootstrapCluster_args_request = bootstrapCluster_args_request obj}
    ]
-- | Translate a 'BootstrapCluster_args' to a 'Types.ThriftVal'
from_BootstrapCluster_args :: BootstrapCluster_args -> Types.ThriftVal
from_BootstrapCluster_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v123 -> Just (1, ("request",Cluster_membership_Types.from_BootstrapClusterRequest _v123))) $ bootstrapCluster_args_request record
  ]
-- | Write a 'BootstrapCluster_args' with the given 'Thrift.Protocol'
write_BootstrapCluster_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapCluster_args -> IO ()
write_BootstrapCluster_args oprot record = Thrift.writeVal oprot $ from_BootstrapCluster_args record
-- | Serialize a 'BootstrapCluster_args' in pure code
encode_BootstrapCluster_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapCluster_args -> BS.ByteString
encode_BootstrapCluster_args oprot record = Thrift.serializeVal oprot $ from_BootstrapCluster_args record
-- | Translate a 'Types.ThriftVal' to a 'BootstrapCluster_args'
to_BootstrapCluster_args :: Types.ThriftVal -> BootstrapCluster_args
to_BootstrapCluster_args (Types.TStruct fields) = BootstrapCluster_args{
  bootstrapCluster_args_request = maybe (bootstrapCluster_args_request default_BootstrapCluster_args) (\(_,_val125) -> (case _val125 of {Types.TStruct _val126 -> (Cluster_membership_Types.to_BootstrapClusterRequest (Types.TStruct _val126)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_BootstrapCluster_args _ = error "not a struct"
-- | Read a 'BootstrapCluster_args' struct with the given 'Thrift.Protocol'
read_BootstrapCluster_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BootstrapCluster_args
read_BootstrapCluster_args iprot = to_BootstrapCluster_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BootstrapCluster_args)
-- | Deserialize a 'BootstrapCluster_args' in pure code
decode_BootstrapCluster_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BootstrapCluster_args
decode_BootstrapCluster_args iprot bs = to_BootstrapCluster_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BootstrapCluster_args) bs
-- | 'TypeMap' for the 'BootstrapCluster_args' struct
typemap_BootstrapCluster_args :: Types.TypeMap
typemap_BootstrapCluster_args = Map.fromList [("request",(1,(Types.T_STRUCT Cluster_membership_Types.typemap_BootstrapClusterRequest)))]
-- | Default values for the 'BootstrapCluster_args' struct
default_BootstrapCluster_args :: BootstrapCluster_args
default_BootstrapCluster_args = BootstrapCluster_args{
  bootstrapCluster_args_request = Cluster_membership_Types.default_BootstrapClusterRequest}
-- | Definition of the BootstrapCluster_result struct
data BootstrapCluster_result = BootstrapCluster_result
  { bootstrapCluster_result_success :: Cluster_membership_Types.BootstrapClusterResponse
    -- ^ success field of the BootstrapCluster_result struct
  , bootstrapCluster_result_error :: Maybe Exceptions_Types.OperationError
    -- ^ error field of the BootstrapCluster_result struct
  , bootstrapCluster_result_ncm_error :: Maybe Exceptions_Types.NodesConfigurationManagerError
    -- ^ ncm_error field of the BootstrapCluster_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BootstrapCluster_result where
  encode = encode_BootstrapCluster_result
  decode = decode_BootstrapCluster_result
instance Hashable.Hashable BootstrapCluster_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bootstrapCluster_result_success record   `Hashable.hashWithSalt` bootstrapCluster_result_error record   `Hashable.hashWithSalt` bootstrapCluster_result_ncm_error record  
instance DeepSeq.NFData BootstrapCluster_result where
  rnf _record127 =
    DeepSeq.rnf (bootstrapCluster_result_success _record127) `seq`
    DeepSeq.rnf (bootstrapCluster_result_error _record127) `seq`
    DeepSeq.rnf (bootstrapCluster_result_ncm_error _record127) `seq`
    ()
instance Arbitrary.Arbitrary BootstrapCluster_result where 
  arbitrary = Monad.liftM BootstrapCluster_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_BootstrapCluster_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BootstrapCluster_result{bootstrapCluster_result_success = bootstrapCluster_result_success obj} then Nothing else Just $ default_BootstrapCluster_result{bootstrapCluster_result_success = bootstrapCluster_result_success obj}
    , if obj == default_BootstrapCluster_result{bootstrapCluster_result_error = bootstrapCluster_result_error obj} then Nothing else Just $ default_BootstrapCluster_result{bootstrapCluster_result_error = bootstrapCluster_result_error obj}
    , if obj == default_BootstrapCluster_result{bootstrapCluster_result_ncm_error = bootstrapCluster_result_ncm_error obj} then Nothing else Just $ default_BootstrapCluster_result{bootstrapCluster_result_ncm_error = bootstrapCluster_result_ncm_error obj}
    ]
-- | Translate a 'BootstrapCluster_result' to a 'Types.ThriftVal'
from_BootstrapCluster_result :: BootstrapCluster_result -> Types.ThriftVal
from_BootstrapCluster_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v130 -> (1, ("error",Exceptions_Types.from_OperationError _v130))) <$> bootstrapCluster_result_error record, (\_v130 -> (2, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v130))) <$> bootstrapCluster_result_ncm_error record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v130 -> Just (0, ("success",Cluster_membership_Types.from_BootstrapClusterResponse _v130))) $ bootstrapCluster_result_success record
    , (\_v130 -> (1, ("error",Exceptions_Types.from_OperationError _v130))) <$> bootstrapCluster_result_error record
    , (\_v130 -> (2, ("ncm_error",Exceptions_Types.from_NodesConfigurationManagerError _v130))) <$> bootstrapCluster_result_ncm_error record
    ]
    )
-- | Write a 'BootstrapCluster_result' with the given 'Thrift.Protocol'
write_BootstrapCluster_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapCluster_result -> IO ()
write_BootstrapCluster_result oprot record = Thrift.writeVal oprot $ from_BootstrapCluster_result record
-- | Serialize a 'BootstrapCluster_result' in pure code
encode_BootstrapCluster_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BootstrapCluster_result -> BS.ByteString
encode_BootstrapCluster_result oprot record = Thrift.serializeVal oprot $ from_BootstrapCluster_result record
-- | Translate a 'Types.ThriftVal' to a 'BootstrapCluster_result'
to_BootstrapCluster_result :: Types.ThriftVal -> BootstrapCluster_result
to_BootstrapCluster_result (Types.TStruct fields) = BootstrapCluster_result{
  bootstrapCluster_result_success = maybe (bootstrapCluster_result_success default_BootstrapCluster_result) (\(_,_val132) -> (case _val132 of {Types.TStruct _val133 -> (Cluster_membership_Types.to_BootstrapClusterResponse (Types.TStruct _val133)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  bootstrapCluster_result_error = maybe (Nothing) (\(_,_val132) -> Just (case _val132 of {Types.TStruct _val134 -> (Exceptions_Types.to_OperationError (Types.TStruct _val134)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  bootstrapCluster_result_ncm_error = maybe (Nothing) (\(_,_val132) -> Just (case _val132 of {Types.TStruct _val135 -> (Exceptions_Types.to_NodesConfigurationManagerError (Types.TStruct _val135)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_BootstrapCluster_result _ = error "not a struct"
-- | Read a 'BootstrapCluster_result' struct with the given 'Thrift.Protocol'
read_BootstrapCluster_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BootstrapCluster_result
read_BootstrapCluster_result iprot = to_BootstrapCluster_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BootstrapCluster_result)
-- | Deserialize a 'BootstrapCluster_result' in pure code
decode_BootstrapCluster_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BootstrapCluster_result
decode_BootstrapCluster_result iprot bs = to_BootstrapCluster_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BootstrapCluster_result) bs
-- | 'TypeMap' for the 'BootstrapCluster_result' struct
typemap_BootstrapCluster_result :: Types.TypeMap
typemap_BootstrapCluster_result = Map.fromList [("success",(0,(Types.T_STRUCT Cluster_membership_Types.typemap_BootstrapClusterResponse))),("error",(1,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("ncm_error",(2,(Types.T_STRUCT Exceptions_Types.typemap_NodesConfigurationManagerError)))]
-- | Default values for the 'BootstrapCluster_result' struct
default_BootstrapCluster_result :: BootstrapCluster_result
default_BootstrapCluster_result = BootstrapCluster_result{
  bootstrapCluster_result_success = Cluster_membership_Types.default_BootstrapClusterResponse,
  bootstrapCluster_result_error = Nothing,
  bootstrapCluster_result_ncm_error = Nothing}
-- | Definition of the GetMaintenances_args struct
data GetMaintenances_args = GetMaintenances_args
  { getMaintenances_args_filter :: Maintenance_Types.MaintenancesFilter
    -- ^ filter field of the GetMaintenances_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetMaintenances_args where
  encode = encode_GetMaintenances_args
  decode = decode_GetMaintenances_args
instance Hashable.Hashable GetMaintenances_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getMaintenances_args_filter record  
instance DeepSeq.NFData GetMaintenances_args where
  rnf _record136 =
    DeepSeq.rnf (getMaintenances_args_filter _record136) `seq`
    ()
instance Arbitrary.Arbitrary GetMaintenances_args where 
  arbitrary = Monad.liftM GetMaintenances_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetMaintenances_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetMaintenances_args{getMaintenances_args_filter = getMaintenances_args_filter obj} then Nothing else Just $ default_GetMaintenances_args{getMaintenances_args_filter = getMaintenances_args_filter obj}
    ]
-- | Translate a 'GetMaintenances_args' to a 'Types.ThriftVal'
from_GetMaintenances_args :: GetMaintenances_args -> Types.ThriftVal
from_GetMaintenances_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v139 -> Just (1, ("filter",Maintenance_Types.from_MaintenancesFilter _v139))) $ getMaintenances_args_filter record
  ]
-- | Write a 'GetMaintenances_args' with the given 'Thrift.Protocol'
write_GetMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetMaintenances_args -> IO ()
write_GetMaintenances_args oprot record = Thrift.writeVal oprot $ from_GetMaintenances_args record
-- | Serialize a 'GetMaintenances_args' in pure code
encode_GetMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetMaintenances_args -> BS.ByteString
encode_GetMaintenances_args oprot record = Thrift.serializeVal oprot $ from_GetMaintenances_args record
-- | Translate a 'Types.ThriftVal' to a 'GetMaintenances_args'
to_GetMaintenances_args :: Types.ThriftVal -> GetMaintenances_args
to_GetMaintenances_args (Types.TStruct fields) = GetMaintenances_args{
  getMaintenances_args_filter = maybe (getMaintenances_args_filter default_GetMaintenances_args) (\(_,_val141) -> (case _val141 of {Types.TStruct _val142 -> (Maintenance_Types.to_MaintenancesFilter (Types.TStruct _val142)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMaintenances_args _ = error "not a struct"
-- | Read a 'GetMaintenances_args' struct with the given 'Thrift.Protocol'
read_GetMaintenances_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetMaintenances_args
read_GetMaintenances_args iprot = to_GetMaintenances_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetMaintenances_args)
-- | Deserialize a 'GetMaintenances_args' in pure code
decode_GetMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetMaintenances_args
decode_GetMaintenances_args iprot bs = to_GetMaintenances_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetMaintenances_args) bs
-- | 'TypeMap' for the 'GetMaintenances_args' struct
typemap_GetMaintenances_args :: Types.TypeMap
typemap_GetMaintenances_args = Map.fromList [("filter",(1,(Types.T_STRUCT Maintenance_Types.typemap_MaintenancesFilter)))]
-- | Default values for the 'GetMaintenances_args' struct
default_GetMaintenances_args :: GetMaintenances_args
default_GetMaintenances_args = GetMaintenances_args{
  getMaintenances_args_filter = Maintenance_Types.default_MaintenancesFilter}
-- | Definition of the GetMaintenances_result struct
data GetMaintenances_result = GetMaintenances_result
  { getMaintenances_result_success :: Maintenance_Types.MaintenanceDefinitionResponse
    -- ^ success field of the GetMaintenances_result struct
  , getMaintenances_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the GetMaintenances_result struct
  , getMaintenances_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the GetMaintenances_result struct
  , getMaintenances_result_error :: Maybe Exceptions_Types.OperationError
    -- ^ error field of the GetMaintenances_result struct
  , getMaintenances_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the GetMaintenances_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetMaintenances_result where
  encode = encode_GetMaintenances_result
  decode = decode_GetMaintenances_result
instance Hashable.Hashable GetMaintenances_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getMaintenances_result_success record   `Hashable.hashWithSalt` getMaintenances_result_notready record   `Hashable.hashWithSalt` getMaintenances_result_invalid_request record   `Hashable.hashWithSalt` getMaintenances_result_error record   `Hashable.hashWithSalt` getMaintenances_result_not_supported record  
instance DeepSeq.NFData GetMaintenances_result where
  rnf _record143 =
    DeepSeq.rnf (getMaintenances_result_success _record143) `seq`
    DeepSeq.rnf (getMaintenances_result_notready _record143) `seq`
    DeepSeq.rnf (getMaintenances_result_invalid_request _record143) `seq`
    DeepSeq.rnf (getMaintenances_result_error _record143) `seq`
    DeepSeq.rnf (getMaintenances_result_not_supported _record143) `seq`
    ()
instance Arbitrary.Arbitrary GetMaintenances_result where 
  arbitrary = Monad.liftM GetMaintenances_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_GetMaintenances_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetMaintenances_result{getMaintenances_result_success = getMaintenances_result_success obj} then Nothing else Just $ default_GetMaintenances_result{getMaintenances_result_success = getMaintenances_result_success obj}
    , if obj == default_GetMaintenances_result{getMaintenances_result_notready = getMaintenances_result_notready obj} then Nothing else Just $ default_GetMaintenances_result{getMaintenances_result_notready = getMaintenances_result_notready obj}
    , if obj == default_GetMaintenances_result{getMaintenances_result_invalid_request = getMaintenances_result_invalid_request obj} then Nothing else Just $ default_GetMaintenances_result{getMaintenances_result_invalid_request = getMaintenances_result_invalid_request obj}
    , if obj == default_GetMaintenances_result{getMaintenances_result_error = getMaintenances_result_error obj} then Nothing else Just $ default_GetMaintenances_result{getMaintenances_result_error = getMaintenances_result_error obj}
    , if obj == default_GetMaintenances_result{getMaintenances_result_not_supported = getMaintenances_result_not_supported obj} then Nothing else Just $ default_GetMaintenances_result{getMaintenances_result_not_supported = getMaintenances_result_not_supported obj}
    ]
-- | Translate a 'GetMaintenances_result' to a 'Types.ThriftVal'
from_GetMaintenances_result :: GetMaintenances_result -> Types.ThriftVal
from_GetMaintenances_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v146 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v146))) <$> getMaintenances_result_notready record, (\_v146 -> (3, ("invalid_request",Exceptions_Types.from_InvalidRequest _v146))) <$> getMaintenances_result_invalid_request record, (\_v146 -> (4, ("error",Exceptions_Types.from_OperationError _v146))) <$> getMaintenances_result_error record, (\_v146 -> (5, ("not_supported",Exceptions_Types.from_NotSupported _v146))) <$> getMaintenances_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v146 -> Just (0, ("success",Maintenance_Types.from_MaintenanceDefinitionResponse _v146))) $ getMaintenances_result_success record
    , (\_v146 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v146))) <$> getMaintenances_result_notready record
    , (\_v146 -> (3, ("invalid_request",Exceptions_Types.from_InvalidRequest _v146))) <$> getMaintenances_result_invalid_request record
    , (\_v146 -> (4, ("error",Exceptions_Types.from_OperationError _v146))) <$> getMaintenances_result_error record
    , (\_v146 -> (5, ("not_supported",Exceptions_Types.from_NotSupported _v146))) <$> getMaintenances_result_not_supported record
    ]
    )
-- | Write a 'GetMaintenances_result' with the given 'Thrift.Protocol'
write_GetMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetMaintenances_result -> IO ()
write_GetMaintenances_result oprot record = Thrift.writeVal oprot $ from_GetMaintenances_result record
-- | Serialize a 'GetMaintenances_result' in pure code
encode_GetMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetMaintenances_result -> BS.ByteString
encode_GetMaintenances_result oprot record = Thrift.serializeVal oprot $ from_GetMaintenances_result record
-- | Translate a 'Types.ThriftVal' to a 'GetMaintenances_result'
to_GetMaintenances_result :: Types.ThriftVal -> GetMaintenances_result
to_GetMaintenances_result (Types.TStruct fields) = GetMaintenances_result{
  getMaintenances_result_success = maybe (getMaintenances_result_success default_GetMaintenances_result) (\(_,_val148) -> (case _val148 of {Types.TStruct _val149 -> (Maintenance_Types.to_MaintenanceDefinitionResponse (Types.TStruct _val149)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  getMaintenances_result_notready = maybe (Nothing) (\(_,_val148) -> Just (case _val148 of {Types.TStruct _val150 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val150)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  getMaintenances_result_invalid_request = maybe (Nothing) (\(_,_val148) -> Just (case _val148 of {Types.TStruct _val151 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val151)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  getMaintenances_result_error = maybe (Nothing) (\(_,_val148) -> Just (case _val148 of {Types.TStruct _val152 -> (Exceptions_Types.to_OperationError (Types.TStruct _val152)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  getMaintenances_result_not_supported = maybe (Nothing) (\(_,_val148) -> Just (case _val148 of {Types.TStruct _val153 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val153)); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetMaintenances_result _ = error "not a struct"
-- | Read a 'GetMaintenances_result' struct with the given 'Thrift.Protocol'
read_GetMaintenances_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetMaintenances_result
read_GetMaintenances_result iprot = to_GetMaintenances_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetMaintenances_result)
-- | Deserialize a 'GetMaintenances_result' in pure code
decode_GetMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetMaintenances_result
decode_GetMaintenances_result iprot bs = to_GetMaintenances_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetMaintenances_result) bs
-- | 'TypeMap' for the 'GetMaintenances_result' struct
typemap_GetMaintenances_result :: Types.TypeMap
typemap_GetMaintenances_result = Map.fromList [("success",(0,(Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinitionResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(3,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("error",(4,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("not_supported",(5,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'GetMaintenances_result' struct
default_GetMaintenances_result :: GetMaintenances_result
default_GetMaintenances_result = GetMaintenances_result{
  getMaintenances_result_success = Maintenance_Types.default_MaintenanceDefinitionResponse,
  getMaintenances_result_notready = Nothing,
  getMaintenances_result_invalid_request = Nothing,
  getMaintenances_result_error = Nothing,
  getMaintenances_result_not_supported = Nothing}
-- | Definition of the ApplyMaintenance_args struct
data ApplyMaintenance_args = ApplyMaintenance_args
  { applyMaintenance_args_request :: Maintenance_Types.MaintenanceDefinition
    -- ^ request field of the ApplyMaintenance_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ApplyMaintenance_args where
  encode = encode_ApplyMaintenance_args
  decode = decode_ApplyMaintenance_args
instance Hashable.Hashable ApplyMaintenance_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` applyMaintenance_args_request record  
instance DeepSeq.NFData ApplyMaintenance_args where
  rnf _record154 =
    DeepSeq.rnf (applyMaintenance_args_request _record154) `seq`
    ()
instance Arbitrary.Arbitrary ApplyMaintenance_args where 
  arbitrary = Monad.liftM ApplyMaintenance_args (Arbitrary.arbitrary)
  shrink obj | obj == default_ApplyMaintenance_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ApplyMaintenance_args{applyMaintenance_args_request = applyMaintenance_args_request obj} then Nothing else Just $ default_ApplyMaintenance_args{applyMaintenance_args_request = applyMaintenance_args_request obj}
    ]
-- | Translate a 'ApplyMaintenance_args' to a 'Types.ThriftVal'
from_ApplyMaintenance_args :: ApplyMaintenance_args -> Types.ThriftVal
from_ApplyMaintenance_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v157 -> Just (1, ("request",Maintenance_Types.from_MaintenanceDefinition _v157))) $ applyMaintenance_args_request record
  ]
-- | Write a 'ApplyMaintenance_args' with the given 'Thrift.Protocol'
write_ApplyMaintenance_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplyMaintenance_args -> IO ()
write_ApplyMaintenance_args oprot record = Thrift.writeVal oprot $ from_ApplyMaintenance_args record
-- | Serialize a 'ApplyMaintenance_args' in pure code
encode_ApplyMaintenance_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplyMaintenance_args -> BS.ByteString
encode_ApplyMaintenance_args oprot record = Thrift.serializeVal oprot $ from_ApplyMaintenance_args record
-- | Translate a 'Types.ThriftVal' to a 'ApplyMaintenance_args'
to_ApplyMaintenance_args :: Types.ThriftVal -> ApplyMaintenance_args
to_ApplyMaintenance_args (Types.TStruct fields) = ApplyMaintenance_args{
  applyMaintenance_args_request = maybe (applyMaintenance_args_request default_ApplyMaintenance_args) (\(_,_val159) -> (case _val159 of {Types.TStruct _val160 -> (Maintenance_Types.to_MaintenanceDefinition (Types.TStruct _val160)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApplyMaintenance_args _ = error "not a struct"
-- | Read a 'ApplyMaintenance_args' struct with the given 'Thrift.Protocol'
read_ApplyMaintenance_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ApplyMaintenance_args
read_ApplyMaintenance_args iprot = to_ApplyMaintenance_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ApplyMaintenance_args)
-- | Deserialize a 'ApplyMaintenance_args' in pure code
decode_ApplyMaintenance_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ApplyMaintenance_args
decode_ApplyMaintenance_args iprot bs = to_ApplyMaintenance_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ApplyMaintenance_args) bs
-- | 'TypeMap' for the 'ApplyMaintenance_args' struct
typemap_ApplyMaintenance_args :: Types.TypeMap
typemap_ApplyMaintenance_args = Map.fromList [("request",(1,(Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition)))]
-- | Default values for the 'ApplyMaintenance_args' struct
default_ApplyMaintenance_args :: ApplyMaintenance_args
default_ApplyMaintenance_args = ApplyMaintenance_args{
  applyMaintenance_args_request = Maintenance_Types.default_MaintenanceDefinition}
-- | Definition of the ApplyMaintenance_result struct
data ApplyMaintenance_result = ApplyMaintenance_result
  { applyMaintenance_result_success :: Maintenance_Types.MaintenanceDefinitionResponse
    -- ^ success field of the ApplyMaintenance_result struct
  , applyMaintenance_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the ApplyMaintenance_result struct
  , applyMaintenance_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the ApplyMaintenance_result struct
  , applyMaintenance_result_clash :: Maybe Exceptions_Types.MaintenanceClash
    -- ^ clash field of the ApplyMaintenance_result struct
  , applyMaintenance_result_operation_error :: Maybe Exceptions_Types.OperationError
    -- ^ operation_error field of the ApplyMaintenance_result struct
  , applyMaintenance_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the ApplyMaintenance_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ApplyMaintenance_result where
  encode = encode_ApplyMaintenance_result
  decode = decode_ApplyMaintenance_result
instance Hashable.Hashable ApplyMaintenance_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` applyMaintenance_result_success record   `Hashable.hashWithSalt` applyMaintenance_result_notready record   `Hashable.hashWithSalt` applyMaintenance_result_invalid_request record   `Hashable.hashWithSalt` applyMaintenance_result_clash record   `Hashable.hashWithSalt` applyMaintenance_result_operation_error record   `Hashable.hashWithSalt` applyMaintenance_result_not_supported record  
instance DeepSeq.NFData ApplyMaintenance_result where
  rnf _record161 =
    DeepSeq.rnf (applyMaintenance_result_success _record161) `seq`
    DeepSeq.rnf (applyMaintenance_result_notready _record161) `seq`
    DeepSeq.rnf (applyMaintenance_result_invalid_request _record161) `seq`
    DeepSeq.rnf (applyMaintenance_result_clash _record161) `seq`
    DeepSeq.rnf (applyMaintenance_result_operation_error _record161) `seq`
    DeepSeq.rnf (applyMaintenance_result_not_supported _record161) `seq`
    ()
instance Arbitrary.Arbitrary ApplyMaintenance_result where 
  arbitrary = Monad.liftM ApplyMaintenance_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_ApplyMaintenance_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ApplyMaintenance_result{applyMaintenance_result_success = applyMaintenance_result_success obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_success = applyMaintenance_result_success obj}
    , if obj == default_ApplyMaintenance_result{applyMaintenance_result_notready = applyMaintenance_result_notready obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_notready = applyMaintenance_result_notready obj}
    , if obj == default_ApplyMaintenance_result{applyMaintenance_result_invalid_request = applyMaintenance_result_invalid_request obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_invalid_request = applyMaintenance_result_invalid_request obj}
    , if obj == default_ApplyMaintenance_result{applyMaintenance_result_clash = applyMaintenance_result_clash obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_clash = applyMaintenance_result_clash obj}
    , if obj == default_ApplyMaintenance_result{applyMaintenance_result_operation_error = applyMaintenance_result_operation_error obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_operation_error = applyMaintenance_result_operation_error obj}
    , if obj == default_ApplyMaintenance_result{applyMaintenance_result_not_supported = applyMaintenance_result_not_supported obj} then Nothing else Just $ default_ApplyMaintenance_result{applyMaintenance_result_not_supported = applyMaintenance_result_not_supported obj}
    ]
-- | Translate a 'ApplyMaintenance_result' to a 'Types.ThriftVal'
from_ApplyMaintenance_result :: ApplyMaintenance_result -> Types.ThriftVal
from_ApplyMaintenance_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v164 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v164))) <$> applyMaintenance_result_notready record, (\_v164 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v164))) <$> applyMaintenance_result_invalid_request record, (\_v164 -> (3, ("clash",Exceptions_Types.from_MaintenanceClash _v164))) <$> applyMaintenance_result_clash record, (\_v164 -> (4, ("operation_error",Exceptions_Types.from_OperationError _v164))) <$> applyMaintenance_result_operation_error record, (\_v164 -> (5, ("not_supported",Exceptions_Types.from_NotSupported _v164))) <$> applyMaintenance_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v164 -> Just (0, ("success",Maintenance_Types.from_MaintenanceDefinitionResponse _v164))) $ applyMaintenance_result_success record
    , (\_v164 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v164))) <$> applyMaintenance_result_notready record
    , (\_v164 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v164))) <$> applyMaintenance_result_invalid_request record
    , (\_v164 -> (3, ("clash",Exceptions_Types.from_MaintenanceClash _v164))) <$> applyMaintenance_result_clash record
    , (\_v164 -> (4, ("operation_error",Exceptions_Types.from_OperationError _v164))) <$> applyMaintenance_result_operation_error record
    , (\_v164 -> (5, ("not_supported",Exceptions_Types.from_NotSupported _v164))) <$> applyMaintenance_result_not_supported record
    ]
    )
-- | Write a 'ApplyMaintenance_result' with the given 'Thrift.Protocol'
write_ApplyMaintenance_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplyMaintenance_result -> IO ()
write_ApplyMaintenance_result oprot record = Thrift.writeVal oprot $ from_ApplyMaintenance_result record
-- | Serialize a 'ApplyMaintenance_result' in pure code
encode_ApplyMaintenance_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplyMaintenance_result -> BS.ByteString
encode_ApplyMaintenance_result oprot record = Thrift.serializeVal oprot $ from_ApplyMaintenance_result record
-- | Translate a 'Types.ThriftVal' to a 'ApplyMaintenance_result'
to_ApplyMaintenance_result :: Types.ThriftVal -> ApplyMaintenance_result
to_ApplyMaintenance_result (Types.TStruct fields) = ApplyMaintenance_result{
  applyMaintenance_result_success = maybe (applyMaintenance_result_success default_ApplyMaintenance_result) (\(_,_val166) -> (case _val166 of {Types.TStruct _val167 -> (Maintenance_Types.to_MaintenanceDefinitionResponse (Types.TStruct _val167)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  applyMaintenance_result_notready = maybe (Nothing) (\(_,_val166) -> Just (case _val166 of {Types.TStruct _val168 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val168)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  applyMaintenance_result_invalid_request = maybe (Nothing) (\(_,_val166) -> Just (case _val166 of {Types.TStruct _val169 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val169)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  applyMaintenance_result_clash = maybe (Nothing) (\(_,_val166) -> Just (case _val166 of {Types.TStruct _val170 -> (Exceptions_Types.to_MaintenanceClash (Types.TStruct _val170)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  applyMaintenance_result_operation_error = maybe (Nothing) (\(_,_val166) -> Just (case _val166 of {Types.TStruct _val171 -> (Exceptions_Types.to_OperationError (Types.TStruct _val171)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  applyMaintenance_result_not_supported = maybe (Nothing) (\(_,_val166) -> Just (case _val166 of {Types.TStruct _val172 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val172)); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_ApplyMaintenance_result _ = error "not a struct"
-- | Read a 'ApplyMaintenance_result' struct with the given 'Thrift.Protocol'
read_ApplyMaintenance_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ApplyMaintenance_result
read_ApplyMaintenance_result iprot = to_ApplyMaintenance_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ApplyMaintenance_result)
-- | Deserialize a 'ApplyMaintenance_result' in pure code
decode_ApplyMaintenance_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ApplyMaintenance_result
decode_ApplyMaintenance_result iprot bs = to_ApplyMaintenance_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ApplyMaintenance_result) bs
-- | 'TypeMap' for the 'ApplyMaintenance_result' struct
typemap_ApplyMaintenance_result :: Types.TypeMap
typemap_ApplyMaintenance_result = Map.fromList [("success",(0,(Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinitionResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("clash",(3,(Types.T_STRUCT Exceptions_Types.typemap_MaintenanceClash))),("operation_error",(4,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("not_supported",(5,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'ApplyMaintenance_result' struct
default_ApplyMaintenance_result :: ApplyMaintenance_result
default_ApplyMaintenance_result = ApplyMaintenance_result{
  applyMaintenance_result_success = Maintenance_Types.default_MaintenanceDefinitionResponse,
  applyMaintenance_result_notready = Nothing,
  applyMaintenance_result_invalid_request = Nothing,
  applyMaintenance_result_clash = Nothing,
  applyMaintenance_result_operation_error = Nothing,
  applyMaintenance_result_not_supported = Nothing}
-- | Definition of the RemoveMaintenances_args struct
data RemoveMaintenances_args = RemoveMaintenances_args
  { removeMaintenances_args_filter :: Maintenance_Types.RemoveMaintenancesRequest
    -- ^ filter field of the RemoveMaintenances_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveMaintenances_args where
  encode = encode_RemoveMaintenances_args
  decode = decode_RemoveMaintenances_args
instance Hashable.Hashable RemoveMaintenances_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeMaintenances_args_filter record  
instance DeepSeq.NFData RemoveMaintenances_args where
  rnf _record173 =
    DeepSeq.rnf (removeMaintenances_args_filter _record173) `seq`
    ()
instance Arbitrary.Arbitrary RemoveMaintenances_args where 
  arbitrary = Monad.liftM RemoveMaintenances_args (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveMaintenances_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveMaintenances_args{removeMaintenances_args_filter = removeMaintenances_args_filter obj} then Nothing else Just $ default_RemoveMaintenances_args{removeMaintenances_args_filter = removeMaintenances_args_filter obj}
    ]
-- | Translate a 'RemoveMaintenances_args' to a 'Types.ThriftVal'
from_RemoveMaintenances_args :: RemoveMaintenances_args -> Types.ThriftVal
from_RemoveMaintenances_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v176 -> Just (1, ("filter",Maintenance_Types.from_RemoveMaintenancesRequest _v176))) $ removeMaintenances_args_filter record
  ]
-- | Write a 'RemoveMaintenances_args' with the given 'Thrift.Protocol'
write_RemoveMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenances_args -> IO ()
write_RemoveMaintenances_args oprot record = Thrift.writeVal oprot $ from_RemoveMaintenances_args record
-- | Serialize a 'RemoveMaintenances_args' in pure code
encode_RemoveMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenances_args -> BS.ByteString
encode_RemoveMaintenances_args oprot record = Thrift.serializeVal oprot $ from_RemoveMaintenances_args record
-- | Translate a 'Types.ThriftVal' to a 'RemoveMaintenances_args'
to_RemoveMaintenances_args :: Types.ThriftVal -> RemoveMaintenances_args
to_RemoveMaintenances_args (Types.TStruct fields) = RemoveMaintenances_args{
  removeMaintenances_args_filter = maybe (removeMaintenances_args_filter default_RemoveMaintenances_args) (\(_,_val178) -> (case _val178 of {Types.TStruct _val179 -> (Maintenance_Types.to_RemoveMaintenancesRequest (Types.TStruct _val179)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMaintenances_args _ = error "not a struct"
-- | Read a 'RemoveMaintenances_args' struct with the given 'Thrift.Protocol'
read_RemoveMaintenances_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveMaintenances_args
read_RemoveMaintenances_args iprot = to_RemoveMaintenances_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveMaintenances_args)
-- | Deserialize a 'RemoveMaintenances_args' in pure code
decode_RemoveMaintenances_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveMaintenances_args
decode_RemoveMaintenances_args iprot bs = to_RemoveMaintenances_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveMaintenances_args) bs
-- | 'TypeMap' for the 'RemoveMaintenances_args' struct
typemap_RemoveMaintenances_args :: Types.TypeMap
typemap_RemoveMaintenances_args = Map.fromList [("filter",(1,(Types.T_STRUCT Maintenance_Types.typemap_RemoveMaintenancesRequest)))]
-- | Default values for the 'RemoveMaintenances_args' struct
default_RemoveMaintenances_args :: RemoveMaintenances_args
default_RemoveMaintenances_args = RemoveMaintenances_args{
  removeMaintenances_args_filter = Maintenance_Types.default_RemoveMaintenancesRequest}
-- | Definition of the RemoveMaintenances_result struct
data RemoveMaintenances_result = RemoveMaintenances_result
  { removeMaintenances_result_success :: Maintenance_Types.RemoveMaintenancesResponse
    -- ^ success field of the RemoveMaintenances_result struct
  , removeMaintenances_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the RemoveMaintenances_result struct
  , removeMaintenances_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the RemoveMaintenances_result struct
  , removeMaintenances_result_operation_error :: Maybe Exceptions_Types.OperationError
    -- ^ operation_error field of the RemoveMaintenances_result struct
  , removeMaintenances_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the RemoveMaintenances_result struct
  , removeMaintenances_result_not_found :: Maybe Exceptions_Types.MaintenanceMatchError
    -- ^ not_found field of the RemoveMaintenances_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveMaintenances_result where
  encode = encode_RemoveMaintenances_result
  decode = decode_RemoveMaintenances_result
instance Hashable.Hashable RemoveMaintenances_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeMaintenances_result_success record   `Hashable.hashWithSalt` removeMaintenances_result_notready record   `Hashable.hashWithSalt` removeMaintenances_result_invalid_request record   `Hashable.hashWithSalt` removeMaintenances_result_operation_error record   `Hashable.hashWithSalt` removeMaintenances_result_not_supported record   `Hashable.hashWithSalt` removeMaintenances_result_not_found record  
instance DeepSeq.NFData RemoveMaintenances_result where
  rnf _record180 =
    DeepSeq.rnf (removeMaintenances_result_success _record180) `seq`
    DeepSeq.rnf (removeMaintenances_result_notready _record180) `seq`
    DeepSeq.rnf (removeMaintenances_result_invalid_request _record180) `seq`
    DeepSeq.rnf (removeMaintenances_result_operation_error _record180) `seq`
    DeepSeq.rnf (removeMaintenances_result_not_supported _record180) `seq`
    DeepSeq.rnf (removeMaintenances_result_not_found _record180) `seq`
    ()
instance Arbitrary.Arbitrary RemoveMaintenances_result where 
  arbitrary = Monad.liftM RemoveMaintenances_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveMaintenances_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveMaintenances_result{removeMaintenances_result_success = removeMaintenances_result_success obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_success = removeMaintenances_result_success obj}
    , if obj == default_RemoveMaintenances_result{removeMaintenances_result_notready = removeMaintenances_result_notready obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_notready = removeMaintenances_result_notready obj}
    , if obj == default_RemoveMaintenances_result{removeMaintenances_result_invalid_request = removeMaintenances_result_invalid_request obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_invalid_request = removeMaintenances_result_invalid_request obj}
    , if obj == default_RemoveMaintenances_result{removeMaintenances_result_operation_error = removeMaintenances_result_operation_error obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_operation_error = removeMaintenances_result_operation_error obj}
    , if obj == default_RemoveMaintenances_result{removeMaintenances_result_not_supported = removeMaintenances_result_not_supported obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_not_supported = removeMaintenances_result_not_supported obj}
    , if obj == default_RemoveMaintenances_result{removeMaintenances_result_not_found = removeMaintenances_result_not_found obj} then Nothing else Just $ default_RemoveMaintenances_result{removeMaintenances_result_not_found = removeMaintenances_result_not_found obj}
    ]
-- | Translate a 'RemoveMaintenances_result' to a 'Types.ThriftVal'
from_RemoveMaintenances_result :: RemoveMaintenances_result -> Types.ThriftVal
from_RemoveMaintenances_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v183 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v183))) <$> removeMaintenances_result_notready record, (\_v183 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v183))) <$> removeMaintenances_result_invalid_request record, (\_v183 -> (3, ("operation_error",Exceptions_Types.from_OperationError _v183))) <$> removeMaintenances_result_operation_error record, (\_v183 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v183))) <$> removeMaintenances_result_not_supported record, (\_v183 -> (5, ("not_found",Exceptions_Types.from_MaintenanceMatchError _v183))) <$> removeMaintenances_result_not_found record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v183 -> Just (0, ("success",Maintenance_Types.from_RemoveMaintenancesResponse _v183))) $ removeMaintenances_result_success record
    , (\_v183 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v183))) <$> removeMaintenances_result_notready record
    , (\_v183 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v183))) <$> removeMaintenances_result_invalid_request record
    , (\_v183 -> (3, ("operation_error",Exceptions_Types.from_OperationError _v183))) <$> removeMaintenances_result_operation_error record
    , (\_v183 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v183))) <$> removeMaintenances_result_not_supported record
    , (\_v183 -> (5, ("not_found",Exceptions_Types.from_MaintenanceMatchError _v183))) <$> removeMaintenances_result_not_found record
    ]
    )
-- | Write a 'RemoveMaintenances_result' with the given 'Thrift.Protocol'
write_RemoveMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenances_result -> IO ()
write_RemoveMaintenances_result oprot record = Thrift.writeVal oprot $ from_RemoveMaintenances_result record
-- | Serialize a 'RemoveMaintenances_result' in pure code
encode_RemoveMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenances_result -> BS.ByteString
encode_RemoveMaintenances_result oprot record = Thrift.serializeVal oprot $ from_RemoveMaintenances_result record
-- | Translate a 'Types.ThriftVal' to a 'RemoveMaintenances_result'
to_RemoveMaintenances_result :: Types.ThriftVal -> RemoveMaintenances_result
to_RemoveMaintenances_result (Types.TStruct fields) = RemoveMaintenances_result{
  removeMaintenances_result_success = maybe (removeMaintenances_result_success default_RemoveMaintenances_result) (\(_,_val185) -> (case _val185 of {Types.TStruct _val186 -> (Maintenance_Types.to_RemoveMaintenancesResponse (Types.TStruct _val186)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  removeMaintenances_result_notready = maybe (Nothing) (\(_,_val185) -> Just (case _val185 of {Types.TStruct _val187 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val187)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  removeMaintenances_result_invalid_request = maybe (Nothing) (\(_,_val185) -> Just (case _val185 of {Types.TStruct _val188 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val188)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  removeMaintenances_result_operation_error = maybe (Nothing) (\(_,_val185) -> Just (case _val185 of {Types.TStruct _val189 -> (Exceptions_Types.to_OperationError (Types.TStruct _val189)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  removeMaintenances_result_not_supported = maybe (Nothing) (\(_,_val185) -> Just (case _val185 of {Types.TStruct _val190 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val190)); _ -> error "wrong type"})) (Map.lookup (4) fields),
  removeMaintenances_result_not_found = maybe (Nothing) (\(_,_val185) -> Just (case _val185 of {Types.TStruct _val191 -> (Exceptions_Types.to_MaintenanceMatchError (Types.TStruct _val191)); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_RemoveMaintenances_result _ = error "not a struct"
-- | Read a 'RemoveMaintenances_result' struct with the given 'Thrift.Protocol'
read_RemoveMaintenances_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveMaintenances_result
read_RemoveMaintenances_result iprot = to_RemoveMaintenances_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveMaintenances_result)
-- | Deserialize a 'RemoveMaintenances_result' in pure code
decode_RemoveMaintenances_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveMaintenances_result
decode_RemoveMaintenances_result iprot bs = to_RemoveMaintenances_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveMaintenances_result) bs
-- | 'TypeMap' for the 'RemoveMaintenances_result' struct
typemap_RemoveMaintenances_result :: Types.TypeMap
typemap_RemoveMaintenances_result = Map.fromList [("success",(0,(Types.T_STRUCT Maintenance_Types.typemap_RemoveMaintenancesResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("operation_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported))),("not_found",(5,(Types.T_STRUCT Exceptions_Types.typemap_MaintenanceMatchError)))]
-- | Default values for the 'RemoveMaintenances_result' struct
default_RemoveMaintenances_result :: RemoveMaintenances_result
default_RemoveMaintenances_result = RemoveMaintenances_result{
  removeMaintenances_result_success = Maintenance_Types.default_RemoveMaintenancesResponse,
  removeMaintenances_result_notready = Nothing,
  removeMaintenances_result_invalid_request = Nothing,
  removeMaintenances_result_operation_error = Nothing,
  removeMaintenances_result_not_supported = Nothing,
  removeMaintenances_result_not_found = Nothing}
-- | Definition of the MarkAllShardsUnrecoverable_args struct
data MarkAllShardsUnrecoverable_args = MarkAllShardsUnrecoverable_args
  { markAllShardsUnrecoverable_args_request :: Maintenance_Types.MarkAllShardsUnrecoverableRequest
    -- ^ request field of the MarkAllShardsUnrecoverable_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkAllShardsUnrecoverable_args where
  encode = encode_MarkAllShardsUnrecoverable_args
  decode = decode_MarkAllShardsUnrecoverable_args
instance Hashable.Hashable MarkAllShardsUnrecoverable_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markAllShardsUnrecoverable_args_request record  
instance DeepSeq.NFData MarkAllShardsUnrecoverable_args where
  rnf _record192 =
    DeepSeq.rnf (markAllShardsUnrecoverable_args_request _record192) `seq`
    ()
instance Arbitrary.Arbitrary MarkAllShardsUnrecoverable_args where 
  arbitrary = Monad.liftM MarkAllShardsUnrecoverable_args (Arbitrary.arbitrary)
  shrink obj | obj == default_MarkAllShardsUnrecoverable_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkAllShardsUnrecoverable_args{markAllShardsUnrecoverable_args_request = markAllShardsUnrecoverable_args_request obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_args{markAllShardsUnrecoverable_args_request = markAllShardsUnrecoverable_args_request obj}
    ]
-- | Translate a 'MarkAllShardsUnrecoverable_args' to a 'Types.ThriftVal'
from_MarkAllShardsUnrecoverable_args :: MarkAllShardsUnrecoverable_args -> Types.ThriftVal
from_MarkAllShardsUnrecoverable_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v195 -> Just (1, ("request",Maintenance_Types.from_MarkAllShardsUnrecoverableRequest _v195))) $ markAllShardsUnrecoverable_args_request record
  ]
-- | Write a 'MarkAllShardsUnrecoverable_args' with the given 'Thrift.Protocol'
write_MarkAllShardsUnrecoverable_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverable_args -> IO ()
write_MarkAllShardsUnrecoverable_args oprot record = Thrift.writeVal oprot $ from_MarkAllShardsUnrecoverable_args record
-- | Serialize a 'MarkAllShardsUnrecoverable_args' in pure code
encode_MarkAllShardsUnrecoverable_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverable_args -> BS.ByteString
encode_MarkAllShardsUnrecoverable_args oprot record = Thrift.serializeVal oprot $ from_MarkAllShardsUnrecoverable_args record
-- | Translate a 'Types.ThriftVal' to a 'MarkAllShardsUnrecoverable_args'
to_MarkAllShardsUnrecoverable_args :: Types.ThriftVal -> MarkAllShardsUnrecoverable_args
to_MarkAllShardsUnrecoverable_args (Types.TStruct fields) = MarkAllShardsUnrecoverable_args{
  markAllShardsUnrecoverable_args_request = maybe (markAllShardsUnrecoverable_args_request default_MarkAllShardsUnrecoverable_args) (\(_,_val197) -> (case _val197 of {Types.TStruct _val198 -> (Maintenance_Types.to_MarkAllShardsUnrecoverableRequest (Types.TStruct _val198)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkAllShardsUnrecoverable_args _ = error "not a struct"
-- | Read a 'MarkAllShardsUnrecoverable_args' struct with the given 'Thrift.Protocol'
read_MarkAllShardsUnrecoverable_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkAllShardsUnrecoverable_args
read_MarkAllShardsUnrecoverable_args iprot = to_MarkAllShardsUnrecoverable_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverable_args)
-- | Deserialize a 'MarkAllShardsUnrecoverable_args' in pure code
decode_MarkAllShardsUnrecoverable_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkAllShardsUnrecoverable_args
decode_MarkAllShardsUnrecoverable_args iprot bs = to_MarkAllShardsUnrecoverable_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverable_args) bs
-- | 'TypeMap' for the 'MarkAllShardsUnrecoverable_args' struct
typemap_MarkAllShardsUnrecoverable_args :: Types.TypeMap
typemap_MarkAllShardsUnrecoverable_args = Map.fromList [("request",(1,(Types.T_STRUCT Maintenance_Types.typemap_MarkAllShardsUnrecoverableRequest)))]
-- | Default values for the 'MarkAllShardsUnrecoverable_args' struct
default_MarkAllShardsUnrecoverable_args :: MarkAllShardsUnrecoverable_args
default_MarkAllShardsUnrecoverable_args = MarkAllShardsUnrecoverable_args{
  markAllShardsUnrecoverable_args_request = Maintenance_Types.default_MarkAllShardsUnrecoverableRequest}
-- | Definition of the MarkAllShardsUnrecoverable_result struct
data MarkAllShardsUnrecoverable_result = MarkAllShardsUnrecoverable_result
  { markAllShardsUnrecoverable_result_success :: Maintenance_Types.MarkAllShardsUnrecoverableResponse
    -- ^ success field of the MarkAllShardsUnrecoverable_result struct
  , markAllShardsUnrecoverable_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the MarkAllShardsUnrecoverable_result struct
  , markAllShardsUnrecoverable_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the MarkAllShardsUnrecoverable_result struct
  , markAllShardsUnrecoverable_result_operation_error :: Maybe Exceptions_Types.OperationError
    -- ^ operation_error field of the MarkAllShardsUnrecoverable_result struct
  , markAllShardsUnrecoverable_result_not_supported :: Maybe Exceptions_Types.NotSupported
    -- ^ not_supported field of the MarkAllShardsUnrecoverable_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkAllShardsUnrecoverable_result where
  encode = encode_MarkAllShardsUnrecoverable_result
  decode = decode_MarkAllShardsUnrecoverable_result
instance Hashable.Hashable MarkAllShardsUnrecoverable_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markAllShardsUnrecoverable_result_success record   `Hashable.hashWithSalt` markAllShardsUnrecoverable_result_notready record   `Hashable.hashWithSalt` markAllShardsUnrecoverable_result_invalid_request record   `Hashable.hashWithSalt` markAllShardsUnrecoverable_result_operation_error record   `Hashable.hashWithSalt` markAllShardsUnrecoverable_result_not_supported record  
instance DeepSeq.NFData MarkAllShardsUnrecoverable_result where
  rnf _record199 =
    DeepSeq.rnf (markAllShardsUnrecoverable_result_success _record199) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverable_result_notready _record199) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverable_result_invalid_request _record199) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverable_result_operation_error _record199) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverable_result_not_supported _record199) `seq`
    ()
instance Arbitrary.Arbitrary MarkAllShardsUnrecoverable_result where 
  arbitrary = Monad.liftM MarkAllShardsUnrecoverable_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_MarkAllShardsUnrecoverable_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_success = markAllShardsUnrecoverable_result_success obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_success = markAllShardsUnrecoverable_result_success obj}
    , if obj == default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_notready = markAllShardsUnrecoverable_result_notready obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_notready = markAllShardsUnrecoverable_result_notready obj}
    , if obj == default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_invalid_request = markAllShardsUnrecoverable_result_invalid_request obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_invalid_request = markAllShardsUnrecoverable_result_invalid_request obj}
    , if obj == default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_operation_error = markAllShardsUnrecoverable_result_operation_error obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_operation_error = markAllShardsUnrecoverable_result_operation_error obj}
    , if obj == default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_not_supported = markAllShardsUnrecoverable_result_not_supported obj} then Nothing else Just $ default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_not_supported = markAllShardsUnrecoverable_result_not_supported obj}
    ]
-- | Translate a 'MarkAllShardsUnrecoverable_result' to a 'Types.ThriftVal'
from_MarkAllShardsUnrecoverable_result :: MarkAllShardsUnrecoverable_result -> Types.ThriftVal
from_MarkAllShardsUnrecoverable_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v202 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v202))) <$> markAllShardsUnrecoverable_result_notready record, (\_v202 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v202))) <$> markAllShardsUnrecoverable_result_invalid_request record, (\_v202 -> (3, ("operation_error",Exceptions_Types.from_OperationError _v202))) <$> markAllShardsUnrecoverable_result_operation_error record, (\_v202 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v202))) <$> markAllShardsUnrecoverable_result_not_supported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v202 -> Just (0, ("success",Maintenance_Types.from_MarkAllShardsUnrecoverableResponse _v202))) $ markAllShardsUnrecoverable_result_success record
    , (\_v202 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v202))) <$> markAllShardsUnrecoverable_result_notready record
    , (\_v202 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v202))) <$> markAllShardsUnrecoverable_result_invalid_request record
    , (\_v202 -> (3, ("operation_error",Exceptions_Types.from_OperationError _v202))) <$> markAllShardsUnrecoverable_result_operation_error record
    , (\_v202 -> (4, ("not_supported",Exceptions_Types.from_NotSupported _v202))) <$> markAllShardsUnrecoverable_result_not_supported record
    ]
    )
-- | Write a 'MarkAllShardsUnrecoverable_result' with the given 'Thrift.Protocol'
write_MarkAllShardsUnrecoverable_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverable_result -> IO ()
write_MarkAllShardsUnrecoverable_result oprot record = Thrift.writeVal oprot $ from_MarkAllShardsUnrecoverable_result record
-- | Serialize a 'MarkAllShardsUnrecoverable_result' in pure code
encode_MarkAllShardsUnrecoverable_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverable_result -> BS.ByteString
encode_MarkAllShardsUnrecoverable_result oprot record = Thrift.serializeVal oprot $ from_MarkAllShardsUnrecoverable_result record
-- | Translate a 'Types.ThriftVal' to a 'MarkAllShardsUnrecoverable_result'
to_MarkAllShardsUnrecoverable_result :: Types.ThriftVal -> MarkAllShardsUnrecoverable_result
to_MarkAllShardsUnrecoverable_result (Types.TStruct fields) = MarkAllShardsUnrecoverable_result{
  markAllShardsUnrecoverable_result_success = maybe (markAllShardsUnrecoverable_result_success default_MarkAllShardsUnrecoverable_result) (\(_,_val204) -> (case _val204 of {Types.TStruct _val205 -> (Maintenance_Types.to_MarkAllShardsUnrecoverableResponse (Types.TStruct _val205)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  markAllShardsUnrecoverable_result_notready = maybe (Nothing) (\(_,_val204) -> Just (case _val204 of {Types.TStruct _val206 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val206)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  markAllShardsUnrecoverable_result_invalid_request = maybe (Nothing) (\(_,_val204) -> Just (case _val204 of {Types.TStruct _val207 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val207)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  markAllShardsUnrecoverable_result_operation_error = maybe (Nothing) (\(_,_val204) -> Just (case _val204 of {Types.TStruct _val208 -> (Exceptions_Types.to_OperationError (Types.TStruct _val208)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  markAllShardsUnrecoverable_result_not_supported = maybe (Nothing) (\(_,_val204) -> Just (case _val204 of {Types.TStruct _val209 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val209)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_MarkAllShardsUnrecoverable_result _ = error "not a struct"
-- | Read a 'MarkAllShardsUnrecoverable_result' struct with the given 'Thrift.Protocol'
read_MarkAllShardsUnrecoverable_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkAllShardsUnrecoverable_result
read_MarkAllShardsUnrecoverable_result iprot = to_MarkAllShardsUnrecoverable_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverable_result)
-- | Deserialize a 'MarkAllShardsUnrecoverable_result' in pure code
decode_MarkAllShardsUnrecoverable_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkAllShardsUnrecoverable_result
decode_MarkAllShardsUnrecoverable_result iprot bs = to_MarkAllShardsUnrecoverable_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverable_result) bs
-- | 'TypeMap' for the 'MarkAllShardsUnrecoverable_result' struct
typemap_MarkAllShardsUnrecoverable_result :: Types.TypeMap
typemap_MarkAllShardsUnrecoverable_result = Map.fromList [("success",(0,(Types.T_STRUCT Maintenance_Types.typemap_MarkAllShardsUnrecoverableResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("operation_error",(3,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("not_supported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'MarkAllShardsUnrecoverable_result' struct
default_MarkAllShardsUnrecoverable_result :: MarkAllShardsUnrecoverable_result
default_MarkAllShardsUnrecoverable_result = MarkAllShardsUnrecoverable_result{
  markAllShardsUnrecoverable_result_success = Maintenance_Types.default_MarkAllShardsUnrecoverableResponse,
  markAllShardsUnrecoverable_result_notready = Nothing,
  markAllShardsUnrecoverable_result_invalid_request = Nothing,
  markAllShardsUnrecoverable_result_operation_error = Nothing,
  markAllShardsUnrecoverable_result_not_supported = Nothing}
-- | Definition of the CheckImpact_args struct
data CheckImpact_args = CheckImpact_args
  { checkImpact_args_request :: Safety_Types.CheckImpactRequest
    -- ^ request field of the CheckImpact_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable CheckImpact_args where
  encode = encode_CheckImpact_args
  decode = decode_CheckImpact_args
instance Hashable.Hashable CheckImpact_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` checkImpact_args_request record  
instance DeepSeq.NFData CheckImpact_args where
  rnf _record210 =
    DeepSeq.rnf (checkImpact_args_request _record210) `seq`
    ()
instance Arbitrary.Arbitrary CheckImpact_args where 
  arbitrary = Monad.liftM CheckImpact_args (Arbitrary.arbitrary)
  shrink obj | obj == default_CheckImpact_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_CheckImpact_args{checkImpact_args_request = checkImpact_args_request obj} then Nothing else Just $ default_CheckImpact_args{checkImpact_args_request = checkImpact_args_request obj}
    ]
-- | Translate a 'CheckImpact_args' to a 'Types.ThriftVal'
from_CheckImpact_args :: CheckImpact_args -> Types.ThriftVal
from_CheckImpact_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v213 -> Just (1, ("request",Safety_Types.from_CheckImpactRequest _v213))) $ checkImpact_args_request record
  ]
-- | Write a 'CheckImpact_args' with the given 'Thrift.Protocol'
write_CheckImpact_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpact_args -> IO ()
write_CheckImpact_args oprot record = Thrift.writeVal oprot $ from_CheckImpact_args record
-- | Serialize a 'CheckImpact_args' in pure code
encode_CheckImpact_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpact_args -> BS.ByteString
encode_CheckImpact_args oprot record = Thrift.serializeVal oprot $ from_CheckImpact_args record
-- | Translate a 'Types.ThriftVal' to a 'CheckImpact_args'
to_CheckImpact_args :: Types.ThriftVal -> CheckImpact_args
to_CheckImpact_args (Types.TStruct fields) = CheckImpact_args{
  checkImpact_args_request = maybe (checkImpact_args_request default_CheckImpact_args) (\(_,_val215) -> (case _val215 of {Types.TStruct _val216 -> (Safety_Types.to_CheckImpactRequest (Types.TStruct _val216)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_CheckImpact_args _ = error "not a struct"
-- | Read a 'CheckImpact_args' struct with the given 'Thrift.Protocol'
read_CheckImpact_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO CheckImpact_args
read_CheckImpact_args iprot = to_CheckImpact_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_CheckImpact_args)
-- | Deserialize a 'CheckImpact_args' in pure code
decode_CheckImpact_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> CheckImpact_args
decode_CheckImpact_args iprot bs = to_CheckImpact_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_CheckImpact_args) bs
-- | 'TypeMap' for the 'CheckImpact_args' struct
typemap_CheckImpact_args :: Types.TypeMap
typemap_CheckImpact_args = Map.fromList [("request",(1,(Types.T_STRUCT Safety_Types.typemap_CheckImpactRequest)))]
-- | Default values for the 'CheckImpact_args' struct
default_CheckImpact_args :: CheckImpact_args
default_CheckImpact_args = CheckImpact_args{
  checkImpact_args_request = Safety_Types.default_CheckImpactRequest}
-- | Definition of the CheckImpact_result struct
data CheckImpact_result = CheckImpact_result
  { checkImpact_result_success :: Safety_Types.CheckImpactResponse
    -- ^ success field of the CheckImpact_result struct
  , checkImpact_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the CheckImpact_result struct
  , checkImpact_result_error :: Maybe Exceptions_Types.OperationError
    -- ^ error field of the CheckImpact_result struct
  , checkImpact_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the CheckImpact_result struct
  , checkImpact_result_notsupported :: Maybe Exceptions_Types.NotSupported
    -- ^ notsupported field of the CheckImpact_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable CheckImpact_result where
  encode = encode_CheckImpact_result
  decode = decode_CheckImpact_result
instance Hashable.Hashable CheckImpact_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` checkImpact_result_success record   `Hashable.hashWithSalt` checkImpact_result_notready record   `Hashable.hashWithSalt` checkImpact_result_error record   `Hashable.hashWithSalt` checkImpact_result_invalid_request record   `Hashable.hashWithSalt` checkImpact_result_notsupported record  
instance DeepSeq.NFData CheckImpact_result where
  rnf _record217 =
    DeepSeq.rnf (checkImpact_result_success _record217) `seq`
    DeepSeq.rnf (checkImpact_result_notready _record217) `seq`
    DeepSeq.rnf (checkImpact_result_error _record217) `seq`
    DeepSeq.rnf (checkImpact_result_invalid_request _record217) `seq`
    DeepSeq.rnf (checkImpact_result_notsupported _record217) `seq`
    ()
instance Arbitrary.Arbitrary CheckImpact_result where 
  arbitrary = Monad.liftM CheckImpact_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_CheckImpact_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_CheckImpact_result{checkImpact_result_success = checkImpact_result_success obj} then Nothing else Just $ default_CheckImpact_result{checkImpact_result_success = checkImpact_result_success obj}
    , if obj == default_CheckImpact_result{checkImpact_result_notready = checkImpact_result_notready obj} then Nothing else Just $ default_CheckImpact_result{checkImpact_result_notready = checkImpact_result_notready obj}
    , if obj == default_CheckImpact_result{checkImpact_result_error = checkImpact_result_error obj} then Nothing else Just $ default_CheckImpact_result{checkImpact_result_error = checkImpact_result_error obj}
    , if obj == default_CheckImpact_result{checkImpact_result_invalid_request = checkImpact_result_invalid_request obj} then Nothing else Just $ default_CheckImpact_result{checkImpact_result_invalid_request = checkImpact_result_invalid_request obj}
    , if obj == default_CheckImpact_result{checkImpact_result_notsupported = checkImpact_result_notsupported obj} then Nothing else Just $ default_CheckImpact_result{checkImpact_result_notsupported = checkImpact_result_notsupported obj}
    ]
-- | Translate a 'CheckImpact_result' to a 'Types.ThriftVal'
from_CheckImpact_result :: CheckImpact_result -> Types.ThriftVal
from_CheckImpact_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v220 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v220))) <$> checkImpact_result_notready record, (\_v220 -> (2, ("error",Exceptions_Types.from_OperationError _v220))) <$> checkImpact_result_error record, (\_v220 -> (3, ("invalid_request",Exceptions_Types.from_InvalidRequest _v220))) <$> checkImpact_result_invalid_request record, (\_v220 -> (4, ("notsupported",Exceptions_Types.from_NotSupported _v220))) <$> checkImpact_result_notsupported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v220 -> Just (0, ("success",Safety_Types.from_CheckImpactResponse _v220))) $ checkImpact_result_success record
    , (\_v220 -> (1, ("notready",Exceptions_Types.from_NodeNotReady _v220))) <$> checkImpact_result_notready record
    , (\_v220 -> (2, ("error",Exceptions_Types.from_OperationError _v220))) <$> checkImpact_result_error record
    , (\_v220 -> (3, ("invalid_request",Exceptions_Types.from_InvalidRequest _v220))) <$> checkImpact_result_invalid_request record
    , (\_v220 -> (4, ("notsupported",Exceptions_Types.from_NotSupported _v220))) <$> checkImpact_result_notsupported record
    ]
    )
-- | Write a 'CheckImpact_result' with the given 'Thrift.Protocol'
write_CheckImpact_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpact_result -> IO ()
write_CheckImpact_result oprot record = Thrift.writeVal oprot $ from_CheckImpact_result record
-- | Serialize a 'CheckImpact_result' in pure code
encode_CheckImpact_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpact_result -> BS.ByteString
encode_CheckImpact_result oprot record = Thrift.serializeVal oprot $ from_CheckImpact_result record
-- | Translate a 'Types.ThriftVal' to a 'CheckImpact_result'
to_CheckImpact_result :: Types.ThriftVal -> CheckImpact_result
to_CheckImpact_result (Types.TStruct fields) = CheckImpact_result{
  checkImpact_result_success = maybe (checkImpact_result_success default_CheckImpact_result) (\(_,_val222) -> (case _val222 of {Types.TStruct _val223 -> (Safety_Types.to_CheckImpactResponse (Types.TStruct _val223)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  checkImpact_result_notready = maybe (Nothing) (\(_,_val222) -> Just (case _val222 of {Types.TStruct _val224 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val224)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  checkImpact_result_error = maybe (Nothing) (\(_,_val222) -> Just (case _val222 of {Types.TStruct _val225 -> (Exceptions_Types.to_OperationError (Types.TStruct _val225)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  checkImpact_result_invalid_request = maybe (Nothing) (\(_,_val222) -> Just (case _val222 of {Types.TStruct _val226 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val226)); _ -> error "wrong type"})) (Map.lookup (3) fields),
  checkImpact_result_notsupported = maybe (Nothing) (\(_,_val222) -> Just (case _val222 of {Types.TStruct _val227 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val227)); _ -> error "wrong type"})) (Map.lookup (4) fields)
  }
to_CheckImpact_result _ = error "not a struct"
-- | Read a 'CheckImpact_result' struct with the given 'Thrift.Protocol'
read_CheckImpact_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO CheckImpact_result
read_CheckImpact_result iprot = to_CheckImpact_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_CheckImpact_result)
-- | Deserialize a 'CheckImpact_result' in pure code
decode_CheckImpact_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> CheckImpact_result
decode_CheckImpact_result iprot bs = to_CheckImpact_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_CheckImpact_result) bs
-- | 'TypeMap' for the 'CheckImpact_result' struct
typemap_CheckImpact_result :: Types.TypeMap
typemap_CheckImpact_result = Map.fromList [("success",(0,(Types.T_STRUCT Safety_Types.typemap_CheckImpactResponse))),("notready",(1,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("error",(2,(Types.T_STRUCT Exceptions_Types.typemap_OperationError))),("invalid_request",(3,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("notsupported",(4,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'CheckImpact_result' struct
default_CheckImpact_result :: CheckImpact_result
default_CheckImpact_result = CheckImpact_result{
  checkImpact_result_success = Safety_Types.default_CheckImpactResponse,
  checkImpact_result_notready = Nothing,
  checkImpact_result_error = Nothing,
  checkImpact_result_invalid_request = Nothing,
  checkImpact_result_notsupported = Nothing}
-- | Definition of the GetLogTreeInfo_args struct
data GetLogTreeInfo_args = GetLogTreeInfo_args
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogTreeInfo_args where
  encode = encode_GetLogTreeInfo_args
  decode = decode_GetLogTreeInfo_args
instance Hashable.Hashable GetLogTreeInfo_args where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData GetLogTreeInfo_args where
  rnf _record228 =
    ()
instance Arbitrary.Arbitrary GetLogTreeInfo_args where 
  arbitrary = QuickCheck.elements [GetLogTreeInfo_args]
-- | Translate a 'GetLogTreeInfo_args' to a 'Types.ThriftVal'
from_GetLogTreeInfo_args :: GetLogTreeInfo_args -> Types.ThriftVal
from_GetLogTreeInfo_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'GetLogTreeInfo_args' with the given 'Thrift.Protocol'
write_GetLogTreeInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogTreeInfo_args -> IO ()
write_GetLogTreeInfo_args oprot record = Thrift.writeVal oprot $ from_GetLogTreeInfo_args record
-- | Serialize a 'GetLogTreeInfo_args' in pure code
encode_GetLogTreeInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogTreeInfo_args -> BS.ByteString
encode_GetLogTreeInfo_args oprot record = Thrift.serializeVal oprot $ from_GetLogTreeInfo_args record
-- | Translate a 'Types.ThriftVal' to a 'GetLogTreeInfo_args'
to_GetLogTreeInfo_args :: Types.ThriftVal -> GetLogTreeInfo_args
to_GetLogTreeInfo_args (Types.TStruct fields) = GetLogTreeInfo_args{

  }
to_GetLogTreeInfo_args _ = error "not a struct"
-- | Read a 'GetLogTreeInfo_args' struct with the given 'Thrift.Protocol'
read_GetLogTreeInfo_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogTreeInfo_args
read_GetLogTreeInfo_args iprot = to_GetLogTreeInfo_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogTreeInfo_args)
-- | Deserialize a 'GetLogTreeInfo_args' in pure code
decode_GetLogTreeInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogTreeInfo_args
decode_GetLogTreeInfo_args iprot bs = to_GetLogTreeInfo_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogTreeInfo_args) bs
-- | 'TypeMap' for the 'GetLogTreeInfo_args' struct
typemap_GetLogTreeInfo_args :: Types.TypeMap
typemap_GetLogTreeInfo_args = Map.fromList []
-- | Default values for the 'GetLogTreeInfo_args' struct
default_GetLogTreeInfo_args :: GetLogTreeInfo_args
default_GetLogTreeInfo_args = GetLogTreeInfo_args{
}
-- | Definition of the GetLogTreeInfo_result struct
data GetLogTreeInfo_result = GetLogTreeInfo_result
  { getLogTreeInfo_result_success :: Logtree_Types.LogTreeInfo
    -- ^ success field of the GetLogTreeInfo_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogTreeInfo_result where
  encode = encode_GetLogTreeInfo_result
  decode = decode_GetLogTreeInfo_result
instance Hashable.Hashable GetLogTreeInfo_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getLogTreeInfo_result_success record  
instance DeepSeq.NFData GetLogTreeInfo_result where
  rnf _record234 =
    DeepSeq.rnf (getLogTreeInfo_result_success _record234) `seq`
    ()
instance Arbitrary.Arbitrary GetLogTreeInfo_result where 
  arbitrary = Monad.liftM GetLogTreeInfo_result (Arbitrary.arbitrary)
  shrink obj | obj == default_GetLogTreeInfo_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetLogTreeInfo_result{getLogTreeInfo_result_success = getLogTreeInfo_result_success obj} then Nothing else Just $ default_GetLogTreeInfo_result{getLogTreeInfo_result_success = getLogTreeInfo_result_success obj}
    ]
-- | Translate a 'GetLogTreeInfo_result' to a 'Types.ThriftVal'
from_GetLogTreeInfo_result :: GetLogTreeInfo_result -> Types.ThriftVal
from_GetLogTreeInfo_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v237 -> Just (0, ("success",Logtree_Types.from_LogTreeInfo _v237))) $ getLogTreeInfo_result_success record
  ]
-- | Write a 'GetLogTreeInfo_result' with the given 'Thrift.Protocol'
write_GetLogTreeInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogTreeInfo_result -> IO ()
write_GetLogTreeInfo_result oprot record = Thrift.writeVal oprot $ from_GetLogTreeInfo_result record
-- | Serialize a 'GetLogTreeInfo_result' in pure code
encode_GetLogTreeInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogTreeInfo_result -> BS.ByteString
encode_GetLogTreeInfo_result oprot record = Thrift.serializeVal oprot $ from_GetLogTreeInfo_result record
-- | Translate a 'Types.ThriftVal' to a 'GetLogTreeInfo_result'
to_GetLogTreeInfo_result :: Types.ThriftVal -> GetLogTreeInfo_result
to_GetLogTreeInfo_result (Types.TStruct fields) = GetLogTreeInfo_result{
  getLogTreeInfo_result_success = maybe (getLogTreeInfo_result_success default_GetLogTreeInfo_result) (\(_,_val239) -> (case _val239 of {Types.TStruct _val240 -> (Logtree_Types.to_LogTreeInfo (Types.TStruct _val240)); _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetLogTreeInfo_result _ = error "not a struct"
-- | Read a 'GetLogTreeInfo_result' struct with the given 'Thrift.Protocol'
read_GetLogTreeInfo_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogTreeInfo_result
read_GetLogTreeInfo_result iprot = to_GetLogTreeInfo_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogTreeInfo_result)
-- | Deserialize a 'GetLogTreeInfo_result' in pure code
decode_GetLogTreeInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogTreeInfo_result
decode_GetLogTreeInfo_result iprot bs = to_GetLogTreeInfo_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogTreeInfo_result) bs
-- | 'TypeMap' for the 'GetLogTreeInfo_result' struct
typemap_GetLogTreeInfo_result :: Types.TypeMap
typemap_GetLogTreeInfo_result = Map.fromList [("success",(0,(Types.T_STRUCT Logtree_Types.typemap_LogTreeInfo)))]
-- | Default values for the 'GetLogTreeInfo_result' struct
default_GetLogTreeInfo_result :: GetLogTreeInfo_result
default_GetLogTreeInfo_result = GetLogTreeInfo_result{
  getLogTreeInfo_result_success = Logtree_Types.default_LogTreeInfo}
-- | Definition of the GetReplicationInfo_args struct
data GetReplicationInfo_args = GetReplicationInfo_args
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetReplicationInfo_args where
  encode = encode_GetReplicationInfo_args
  decode = decode_GetReplicationInfo_args
instance Hashable.Hashable GetReplicationInfo_args where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData GetReplicationInfo_args where
  rnf _record241 =
    ()
instance Arbitrary.Arbitrary GetReplicationInfo_args where 
  arbitrary = QuickCheck.elements [GetReplicationInfo_args]
-- | Translate a 'GetReplicationInfo_args' to a 'Types.ThriftVal'
from_GetReplicationInfo_args :: GetReplicationInfo_args -> Types.ThriftVal
from_GetReplicationInfo_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'GetReplicationInfo_args' with the given 'Thrift.Protocol'
write_GetReplicationInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetReplicationInfo_args -> IO ()
write_GetReplicationInfo_args oprot record = Thrift.writeVal oprot $ from_GetReplicationInfo_args record
-- | Serialize a 'GetReplicationInfo_args' in pure code
encode_GetReplicationInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetReplicationInfo_args -> BS.ByteString
encode_GetReplicationInfo_args oprot record = Thrift.serializeVal oprot $ from_GetReplicationInfo_args record
-- | Translate a 'Types.ThriftVal' to a 'GetReplicationInfo_args'
to_GetReplicationInfo_args :: Types.ThriftVal -> GetReplicationInfo_args
to_GetReplicationInfo_args (Types.TStruct fields) = GetReplicationInfo_args{

  }
to_GetReplicationInfo_args _ = error "not a struct"
-- | Read a 'GetReplicationInfo_args' struct with the given 'Thrift.Protocol'
read_GetReplicationInfo_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetReplicationInfo_args
read_GetReplicationInfo_args iprot = to_GetReplicationInfo_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetReplicationInfo_args)
-- | Deserialize a 'GetReplicationInfo_args' in pure code
decode_GetReplicationInfo_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetReplicationInfo_args
decode_GetReplicationInfo_args iprot bs = to_GetReplicationInfo_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetReplicationInfo_args) bs
-- | 'TypeMap' for the 'GetReplicationInfo_args' struct
typemap_GetReplicationInfo_args :: Types.TypeMap
typemap_GetReplicationInfo_args = Map.fromList []
-- | Default values for the 'GetReplicationInfo_args' struct
default_GetReplicationInfo_args :: GetReplicationInfo_args
default_GetReplicationInfo_args = GetReplicationInfo_args{
}
-- | Definition of the GetReplicationInfo_result struct
data GetReplicationInfo_result = GetReplicationInfo_result
  { getReplicationInfo_result_success :: Logtree_Types.ReplicationInfo
    -- ^ success field of the GetReplicationInfo_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetReplicationInfo_result where
  encode = encode_GetReplicationInfo_result
  decode = decode_GetReplicationInfo_result
instance Hashable.Hashable GetReplicationInfo_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getReplicationInfo_result_success record  
instance DeepSeq.NFData GetReplicationInfo_result where
  rnf _record247 =
    DeepSeq.rnf (getReplicationInfo_result_success _record247) `seq`
    ()
instance Arbitrary.Arbitrary GetReplicationInfo_result where 
  arbitrary = Monad.liftM GetReplicationInfo_result (Arbitrary.arbitrary)
  shrink obj | obj == default_GetReplicationInfo_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetReplicationInfo_result{getReplicationInfo_result_success = getReplicationInfo_result_success obj} then Nothing else Just $ default_GetReplicationInfo_result{getReplicationInfo_result_success = getReplicationInfo_result_success obj}
    ]
-- | Translate a 'GetReplicationInfo_result' to a 'Types.ThriftVal'
from_GetReplicationInfo_result :: GetReplicationInfo_result -> Types.ThriftVal
from_GetReplicationInfo_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v250 -> Just (0, ("success",Logtree_Types.from_ReplicationInfo _v250))) $ getReplicationInfo_result_success record
  ]
-- | Write a 'GetReplicationInfo_result' with the given 'Thrift.Protocol'
write_GetReplicationInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetReplicationInfo_result -> IO ()
write_GetReplicationInfo_result oprot record = Thrift.writeVal oprot $ from_GetReplicationInfo_result record
-- | Serialize a 'GetReplicationInfo_result' in pure code
encode_GetReplicationInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetReplicationInfo_result -> BS.ByteString
encode_GetReplicationInfo_result oprot record = Thrift.serializeVal oprot $ from_GetReplicationInfo_result record
-- | Translate a 'Types.ThriftVal' to a 'GetReplicationInfo_result'
to_GetReplicationInfo_result :: Types.ThriftVal -> GetReplicationInfo_result
to_GetReplicationInfo_result (Types.TStruct fields) = GetReplicationInfo_result{
  getReplicationInfo_result_success = maybe (getReplicationInfo_result_success default_GetReplicationInfo_result) (\(_,_val252) -> (case _val252 of {Types.TStruct _val253 -> (Logtree_Types.to_ReplicationInfo (Types.TStruct _val253)); _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetReplicationInfo_result _ = error "not a struct"
-- | Read a 'GetReplicationInfo_result' struct with the given 'Thrift.Protocol'
read_GetReplicationInfo_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetReplicationInfo_result
read_GetReplicationInfo_result iprot = to_GetReplicationInfo_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetReplicationInfo_result)
-- | Deserialize a 'GetReplicationInfo_result' in pure code
decode_GetReplicationInfo_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetReplicationInfo_result
decode_GetReplicationInfo_result iprot bs = to_GetReplicationInfo_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetReplicationInfo_result) bs
-- | 'TypeMap' for the 'GetReplicationInfo_result' struct
typemap_GetReplicationInfo_result :: Types.TypeMap
typemap_GetReplicationInfo_result = Map.fromList [("success",(0,(Types.T_STRUCT Logtree_Types.typemap_ReplicationInfo)))]
-- | Default values for the 'GetReplicationInfo_result' struct
default_GetReplicationInfo_result :: GetReplicationInfo_result
default_GetReplicationInfo_result = GetReplicationInfo_result{
  getReplicationInfo_result_success = Logtree_Types.default_ReplicationInfo}
-- | Definition of the GetSettings_args struct
data GetSettings_args = GetSettings_args
  { getSettings_args_request :: Settings_Types.SettingsRequest
    -- ^ request field of the GetSettings_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetSettings_args where
  encode = encode_GetSettings_args
  decode = decode_GetSettings_args
instance Hashable.Hashable GetSettings_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getSettings_args_request record  
instance DeepSeq.NFData GetSettings_args where
  rnf _record254 =
    DeepSeq.rnf (getSettings_args_request _record254) `seq`
    ()
instance Arbitrary.Arbitrary GetSettings_args where 
  arbitrary = Monad.liftM GetSettings_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetSettings_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetSettings_args{getSettings_args_request = getSettings_args_request obj} then Nothing else Just $ default_GetSettings_args{getSettings_args_request = getSettings_args_request obj}
    ]
-- | Translate a 'GetSettings_args' to a 'Types.ThriftVal'
from_GetSettings_args :: GetSettings_args -> Types.ThriftVal
from_GetSettings_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v257 -> Just (1, ("request",Settings_Types.from_SettingsRequest _v257))) $ getSettings_args_request record
  ]
-- | Write a 'GetSettings_args' with the given 'Thrift.Protocol'
write_GetSettings_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetSettings_args -> IO ()
write_GetSettings_args oprot record = Thrift.writeVal oprot $ from_GetSettings_args record
-- | Serialize a 'GetSettings_args' in pure code
encode_GetSettings_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetSettings_args -> BS.ByteString
encode_GetSettings_args oprot record = Thrift.serializeVal oprot $ from_GetSettings_args record
-- | Translate a 'Types.ThriftVal' to a 'GetSettings_args'
to_GetSettings_args :: Types.ThriftVal -> GetSettings_args
to_GetSettings_args (Types.TStruct fields) = GetSettings_args{
  getSettings_args_request = maybe (getSettings_args_request default_GetSettings_args) (\(_,_val259) -> (case _val259 of {Types.TStruct _val260 -> (Settings_Types.to_SettingsRequest (Types.TStruct _val260)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSettings_args _ = error "not a struct"
-- | Read a 'GetSettings_args' struct with the given 'Thrift.Protocol'
read_GetSettings_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetSettings_args
read_GetSettings_args iprot = to_GetSettings_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetSettings_args)
-- | Deserialize a 'GetSettings_args' in pure code
decode_GetSettings_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetSettings_args
decode_GetSettings_args iprot bs = to_GetSettings_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetSettings_args) bs
-- | 'TypeMap' for the 'GetSettings_args' struct
typemap_GetSettings_args :: Types.TypeMap
typemap_GetSettings_args = Map.fromList [("request",(1,(Types.T_STRUCT Settings_Types.typemap_SettingsRequest)))]
-- | Default values for the 'GetSettings_args' struct
default_GetSettings_args :: GetSettings_args
default_GetSettings_args = GetSettings_args{
  getSettings_args_request = Settings_Types.default_SettingsRequest}
-- | Definition of the GetSettings_result struct
data GetSettings_result = GetSettings_result
  { getSettings_result_success :: Settings_Types.SettingsResponse
    -- ^ success field of the GetSettings_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetSettings_result where
  encode = encode_GetSettings_result
  decode = decode_GetSettings_result
instance Hashable.Hashable GetSettings_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getSettings_result_success record  
instance DeepSeq.NFData GetSettings_result where
  rnf _record261 =
    DeepSeq.rnf (getSettings_result_success _record261) `seq`
    ()
instance Arbitrary.Arbitrary GetSettings_result where 
  arbitrary = Monad.liftM GetSettings_result (Arbitrary.arbitrary)
  shrink obj | obj == default_GetSettings_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetSettings_result{getSettings_result_success = getSettings_result_success obj} then Nothing else Just $ default_GetSettings_result{getSettings_result_success = getSettings_result_success obj}
    ]
-- | Translate a 'GetSettings_result' to a 'Types.ThriftVal'
from_GetSettings_result :: GetSettings_result -> Types.ThriftVal
from_GetSettings_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v264 -> Just (0, ("success",Settings_Types.from_SettingsResponse _v264))) $ getSettings_result_success record
  ]
-- | Write a 'GetSettings_result' with the given 'Thrift.Protocol'
write_GetSettings_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetSettings_result -> IO ()
write_GetSettings_result oprot record = Thrift.writeVal oprot $ from_GetSettings_result record
-- | Serialize a 'GetSettings_result' in pure code
encode_GetSettings_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetSettings_result -> BS.ByteString
encode_GetSettings_result oprot record = Thrift.serializeVal oprot $ from_GetSettings_result record
-- | Translate a 'Types.ThriftVal' to a 'GetSettings_result'
to_GetSettings_result :: Types.ThriftVal -> GetSettings_result
to_GetSettings_result (Types.TStruct fields) = GetSettings_result{
  getSettings_result_success = maybe (getSettings_result_success default_GetSettings_result) (\(_,_val266) -> (case _val266 of {Types.TStruct _val267 -> (Settings_Types.to_SettingsResponse (Types.TStruct _val267)); _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetSettings_result _ = error "not a struct"
-- | Read a 'GetSettings_result' struct with the given 'Thrift.Protocol'
read_GetSettings_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetSettings_result
read_GetSettings_result iprot = to_GetSettings_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetSettings_result)
-- | Deserialize a 'GetSettings_result' in pure code
decode_GetSettings_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetSettings_result
decode_GetSettings_result iprot bs = to_GetSettings_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetSettings_result) bs
-- | 'TypeMap' for the 'GetSettings_result' struct
typemap_GetSettings_result :: Types.TypeMap
typemap_GetSettings_result = Map.fromList [("success",(0,(Types.T_STRUCT Settings_Types.typemap_SettingsResponse)))]
-- | Default values for the 'GetSettings_result' struct
default_GetSettings_result :: GetSettings_result
default_GetSettings_result = GetSettings_result{
  getSettings_result_success = Settings_Types.default_SettingsResponse}
-- | Definition of the ApplySettingOverride_args struct
data ApplySettingOverride_args = ApplySettingOverride_args
  { applySettingOverride_args_request :: Settings_Types.ApplySettingOverrideRequest
    -- ^ request field of the ApplySettingOverride_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ApplySettingOverride_args where
  encode = encode_ApplySettingOverride_args
  decode = decode_ApplySettingOverride_args
instance Hashable.Hashable ApplySettingOverride_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` applySettingOverride_args_request record  
instance DeepSeq.NFData ApplySettingOverride_args where
  rnf _record268 =
    DeepSeq.rnf (applySettingOverride_args_request _record268) `seq`
    ()
instance Arbitrary.Arbitrary ApplySettingOverride_args where 
  arbitrary = Monad.liftM ApplySettingOverride_args (Arbitrary.arbitrary)
  shrink obj | obj == default_ApplySettingOverride_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ApplySettingOverride_args{applySettingOverride_args_request = applySettingOverride_args_request obj} then Nothing else Just $ default_ApplySettingOverride_args{applySettingOverride_args_request = applySettingOverride_args_request obj}
    ]
-- | Translate a 'ApplySettingOverride_args' to a 'Types.ThriftVal'
from_ApplySettingOverride_args :: ApplySettingOverride_args -> Types.ThriftVal
from_ApplySettingOverride_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v271 -> Just (1, ("request",Settings_Types.from_ApplySettingOverrideRequest _v271))) $ applySettingOverride_args_request record
  ]
-- | Write a 'ApplySettingOverride_args' with the given 'Thrift.Protocol'
write_ApplySettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverride_args -> IO ()
write_ApplySettingOverride_args oprot record = Thrift.writeVal oprot $ from_ApplySettingOverride_args record
-- | Serialize a 'ApplySettingOverride_args' in pure code
encode_ApplySettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverride_args -> BS.ByteString
encode_ApplySettingOverride_args oprot record = Thrift.serializeVal oprot $ from_ApplySettingOverride_args record
-- | Translate a 'Types.ThriftVal' to a 'ApplySettingOverride_args'
to_ApplySettingOverride_args :: Types.ThriftVal -> ApplySettingOverride_args
to_ApplySettingOverride_args (Types.TStruct fields) = ApplySettingOverride_args{
  applySettingOverride_args_request = maybe (applySettingOverride_args_request default_ApplySettingOverride_args) (\(_,_val273) -> (case _val273 of {Types.TStruct _val274 -> (Settings_Types.to_ApplySettingOverrideRequest (Types.TStruct _val274)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApplySettingOverride_args _ = error "not a struct"
-- | Read a 'ApplySettingOverride_args' struct with the given 'Thrift.Protocol'
read_ApplySettingOverride_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ApplySettingOverride_args
read_ApplySettingOverride_args iprot = to_ApplySettingOverride_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ApplySettingOverride_args)
-- | Deserialize a 'ApplySettingOverride_args' in pure code
decode_ApplySettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ApplySettingOverride_args
decode_ApplySettingOverride_args iprot bs = to_ApplySettingOverride_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ApplySettingOverride_args) bs
-- | 'TypeMap' for the 'ApplySettingOverride_args' struct
typemap_ApplySettingOverride_args :: Types.TypeMap
typemap_ApplySettingOverride_args = Map.fromList [("request",(1,(Types.T_STRUCT Settings_Types.typemap_ApplySettingOverrideRequest)))]
-- | Default values for the 'ApplySettingOverride_args' struct
default_ApplySettingOverride_args :: ApplySettingOverride_args
default_ApplySettingOverride_args = ApplySettingOverride_args{
  applySettingOverride_args_request = Settings_Types.default_ApplySettingOverrideRequest}
-- | Definition of the ApplySettingOverride_result struct
data ApplySettingOverride_result = ApplySettingOverride_result
  { applySettingOverride_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the ApplySettingOverride_result struct
  , applySettingOverride_result_operation_error :: Maybe Exceptions_Types.OperationError
    -- ^ operation_error field of the ApplySettingOverride_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ApplySettingOverride_result where
  encode = encode_ApplySettingOverride_result
  decode = decode_ApplySettingOverride_result
instance Hashable.Hashable ApplySettingOverride_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` applySettingOverride_result_invalid_request record   `Hashable.hashWithSalt` applySettingOverride_result_operation_error record  
instance DeepSeq.NFData ApplySettingOverride_result where
  rnf _record275 =
    DeepSeq.rnf (applySettingOverride_result_invalid_request _record275) `seq`
    DeepSeq.rnf (applySettingOverride_result_operation_error _record275) `seq`
    ()
instance Arbitrary.Arbitrary ApplySettingOverride_result where 
  arbitrary = Monad.liftM ApplySettingOverride_result (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_ApplySettingOverride_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ApplySettingOverride_result{applySettingOverride_result_invalid_request = applySettingOverride_result_invalid_request obj} then Nothing else Just $ default_ApplySettingOverride_result{applySettingOverride_result_invalid_request = applySettingOverride_result_invalid_request obj}
    , if obj == default_ApplySettingOverride_result{applySettingOverride_result_operation_error = applySettingOverride_result_operation_error obj} then Nothing else Just $ default_ApplySettingOverride_result{applySettingOverride_result_operation_error = applySettingOverride_result_operation_error obj}
    ]
-- | Translate a 'ApplySettingOverride_result' to a 'Types.ThriftVal'
from_ApplySettingOverride_result :: ApplySettingOverride_result -> Types.ThriftVal
from_ApplySettingOverride_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v278 -> (1, ("invalid_request",Exceptions_Types.from_InvalidRequest _v278))) <$> applySettingOverride_result_invalid_request record, (\_v278 -> (2, ("operation_error",Exceptions_Types.from_OperationError _v278))) <$> applySettingOverride_result_operation_error record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v278 -> (1, ("invalid_request",Exceptions_Types.from_InvalidRequest _v278))) <$> applySettingOverride_result_invalid_request record
    , (\_v278 -> (2, ("operation_error",Exceptions_Types.from_OperationError _v278))) <$> applySettingOverride_result_operation_error record
    ]
    )
-- | Write a 'ApplySettingOverride_result' with the given 'Thrift.Protocol'
write_ApplySettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverride_result -> IO ()
write_ApplySettingOverride_result oprot record = Thrift.writeVal oprot $ from_ApplySettingOverride_result record
-- | Serialize a 'ApplySettingOverride_result' in pure code
encode_ApplySettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverride_result -> BS.ByteString
encode_ApplySettingOverride_result oprot record = Thrift.serializeVal oprot $ from_ApplySettingOverride_result record
-- | Translate a 'Types.ThriftVal' to a 'ApplySettingOverride_result'
to_ApplySettingOverride_result :: Types.ThriftVal -> ApplySettingOverride_result
to_ApplySettingOverride_result (Types.TStruct fields) = ApplySettingOverride_result{
  applySettingOverride_result_invalid_request = maybe (Nothing) (\(_,_val280) -> Just (case _val280 of {Types.TStruct _val281 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val281)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  applySettingOverride_result_operation_error = maybe (Nothing) (\(_,_val280) -> Just (case _val280 of {Types.TStruct _val282 -> (Exceptions_Types.to_OperationError (Types.TStruct _val282)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApplySettingOverride_result _ = error "not a struct"
-- | Read a 'ApplySettingOverride_result' struct with the given 'Thrift.Protocol'
read_ApplySettingOverride_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ApplySettingOverride_result
read_ApplySettingOverride_result iprot = to_ApplySettingOverride_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ApplySettingOverride_result)
-- | Deserialize a 'ApplySettingOverride_result' in pure code
decode_ApplySettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ApplySettingOverride_result
decode_ApplySettingOverride_result iprot bs = to_ApplySettingOverride_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ApplySettingOverride_result) bs
-- | 'TypeMap' for the 'ApplySettingOverride_result' struct
typemap_ApplySettingOverride_result :: Types.TypeMap
typemap_ApplySettingOverride_result = Map.fromList [("invalid_request",(1,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest))),("operation_error",(2,(Types.T_STRUCT Exceptions_Types.typemap_OperationError)))]
-- | Default values for the 'ApplySettingOverride_result' struct
default_ApplySettingOverride_result :: ApplySettingOverride_result
default_ApplySettingOverride_result = ApplySettingOverride_result{
  applySettingOverride_result_invalid_request = Nothing,
  applySettingOverride_result_operation_error = Nothing}
-- | Definition of the RemoveSettingOverride_args struct
data RemoveSettingOverride_args = RemoveSettingOverride_args
  { removeSettingOverride_args_request :: Settings_Types.RemoveSettingOverrideRequest
    -- ^ request field of the RemoveSettingOverride_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveSettingOverride_args where
  encode = encode_RemoveSettingOverride_args
  decode = decode_RemoveSettingOverride_args
instance Hashable.Hashable RemoveSettingOverride_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeSettingOverride_args_request record  
instance DeepSeq.NFData RemoveSettingOverride_args where
  rnf _record283 =
    DeepSeq.rnf (removeSettingOverride_args_request _record283) `seq`
    ()
instance Arbitrary.Arbitrary RemoveSettingOverride_args where 
  arbitrary = Monad.liftM RemoveSettingOverride_args (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveSettingOverride_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveSettingOverride_args{removeSettingOverride_args_request = removeSettingOverride_args_request obj} then Nothing else Just $ default_RemoveSettingOverride_args{removeSettingOverride_args_request = removeSettingOverride_args_request obj}
    ]
-- | Translate a 'RemoveSettingOverride_args' to a 'Types.ThriftVal'
from_RemoveSettingOverride_args :: RemoveSettingOverride_args -> Types.ThriftVal
from_RemoveSettingOverride_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v286 -> Just (1, ("request",Settings_Types.from_RemoveSettingOverrideRequest _v286))) $ removeSettingOverride_args_request record
  ]
-- | Write a 'RemoveSettingOverride_args' with the given 'Thrift.Protocol'
write_RemoveSettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverride_args -> IO ()
write_RemoveSettingOverride_args oprot record = Thrift.writeVal oprot $ from_RemoveSettingOverride_args record
-- | Serialize a 'RemoveSettingOverride_args' in pure code
encode_RemoveSettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverride_args -> BS.ByteString
encode_RemoveSettingOverride_args oprot record = Thrift.serializeVal oprot $ from_RemoveSettingOverride_args record
-- | Translate a 'Types.ThriftVal' to a 'RemoveSettingOverride_args'
to_RemoveSettingOverride_args :: Types.ThriftVal -> RemoveSettingOverride_args
to_RemoveSettingOverride_args (Types.TStruct fields) = RemoveSettingOverride_args{
  removeSettingOverride_args_request = maybe (removeSettingOverride_args_request default_RemoveSettingOverride_args) (\(_,_val288) -> (case _val288 of {Types.TStruct _val289 -> (Settings_Types.to_RemoveSettingOverrideRequest (Types.TStruct _val289)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSettingOverride_args _ = error "not a struct"
-- | Read a 'RemoveSettingOverride_args' struct with the given 'Thrift.Protocol'
read_RemoveSettingOverride_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveSettingOverride_args
read_RemoveSettingOverride_args iprot = to_RemoveSettingOverride_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveSettingOverride_args)
-- | Deserialize a 'RemoveSettingOverride_args' in pure code
decode_RemoveSettingOverride_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveSettingOverride_args
decode_RemoveSettingOverride_args iprot bs = to_RemoveSettingOverride_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveSettingOverride_args) bs
-- | 'TypeMap' for the 'RemoveSettingOverride_args' struct
typemap_RemoveSettingOverride_args :: Types.TypeMap
typemap_RemoveSettingOverride_args = Map.fromList [("request",(1,(Types.T_STRUCT Settings_Types.typemap_RemoveSettingOverrideRequest)))]
-- | Default values for the 'RemoveSettingOverride_args' struct
default_RemoveSettingOverride_args :: RemoveSettingOverride_args
default_RemoveSettingOverride_args = RemoveSettingOverride_args{
  removeSettingOverride_args_request = Settings_Types.default_RemoveSettingOverrideRequest}
-- | Definition of the RemoveSettingOverride_result struct
data RemoveSettingOverride_result = RemoveSettingOverride_result
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveSettingOverride_result where
  encode = encode_RemoveSettingOverride_result
  decode = decode_RemoveSettingOverride_result
instance Hashable.Hashable RemoveSettingOverride_result where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData RemoveSettingOverride_result where
  rnf _record290 =
    ()
instance Arbitrary.Arbitrary RemoveSettingOverride_result where 
  arbitrary = QuickCheck.elements [RemoveSettingOverride_result]
-- | Translate a 'RemoveSettingOverride_result' to a 'Types.ThriftVal'
from_RemoveSettingOverride_result :: RemoveSettingOverride_result -> Types.ThriftVal
from_RemoveSettingOverride_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'RemoveSettingOverride_result' with the given 'Thrift.Protocol'
write_RemoveSettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverride_result -> IO ()
write_RemoveSettingOverride_result oprot record = Thrift.writeVal oprot $ from_RemoveSettingOverride_result record
-- | Serialize a 'RemoveSettingOverride_result' in pure code
encode_RemoveSettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverride_result -> BS.ByteString
encode_RemoveSettingOverride_result oprot record = Thrift.serializeVal oprot $ from_RemoveSettingOverride_result record
-- | Translate a 'Types.ThriftVal' to a 'RemoveSettingOverride_result'
to_RemoveSettingOverride_result :: Types.ThriftVal -> RemoveSettingOverride_result
to_RemoveSettingOverride_result (Types.TStruct fields) = RemoveSettingOverride_result{

  }
to_RemoveSettingOverride_result _ = error "not a struct"
-- | Read a 'RemoveSettingOverride_result' struct with the given 'Thrift.Protocol'
read_RemoveSettingOverride_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveSettingOverride_result
read_RemoveSettingOverride_result iprot = to_RemoveSettingOverride_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveSettingOverride_result)
-- | Deserialize a 'RemoveSettingOverride_result' in pure code
decode_RemoveSettingOverride_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveSettingOverride_result
decode_RemoveSettingOverride_result iprot bs = to_RemoveSettingOverride_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveSettingOverride_result) bs
-- | 'TypeMap' for the 'RemoveSettingOverride_result' struct
typemap_RemoveSettingOverride_result :: Types.TypeMap
typemap_RemoveSettingOverride_result = Map.fromList []
-- | Default values for the 'RemoveSettingOverride_result' struct
default_RemoveSettingOverride_result :: RemoveSettingOverride_result
default_RemoveSettingOverride_result = RemoveSettingOverride_result{
}
-- | Definition of the TakeLogTreeSnapshot_args struct
data TakeLogTreeSnapshot_args = TakeLogTreeSnapshot_args
  { takeLogTreeSnapshot_args_min_version :: Int.Int64
    -- ^ min_version field of the TakeLogTreeSnapshot_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TakeLogTreeSnapshot_args where
  encode = encode_TakeLogTreeSnapshot_args
  decode = decode_TakeLogTreeSnapshot_args
instance Hashable.Hashable TakeLogTreeSnapshot_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` takeLogTreeSnapshot_args_min_version record  
instance DeepSeq.NFData TakeLogTreeSnapshot_args where
  rnf _record296 =
    DeepSeq.rnf (takeLogTreeSnapshot_args_min_version _record296) `seq`
    ()
instance Arbitrary.Arbitrary TakeLogTreeSnapshot_args where 
  arbitrary = Monad.liftM TakeLogTreeSnapshot_args (Arbitrary.arbitrary)
  shrink obj | obj == default_TakeLogTreeSnapshot_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TakeLogTreeSnapshot_args{takeLogTreeSnapshot_args_min_version = takeLogTreeSnapshot_args_min_version obj} then Nothing else Just $ default_TakeLogTreeSnapshot_args{takeLogTreeSnapshot_args_min_version = takeLogTreeSnapshot_args_min_version obj}
    ]
-- | Translate a 'TakeLogTreeSnapshot_args' to a 'Types.ThriftVal'
from_TakeLogTreeSnapshot_args :: TakeLogTreeSnapshot_args -> Types.ThriftVal
from_TakeLogTreeSnapshot_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v299 -> Just (1, ("min_version",Types.TI64 _v299))) $ takeLogTreeSnapshot_args_min_version record
  ]
-- | Write a 'TakeLogTreeSnapshot_args' with the given 'Thrift.Protocol'
write_TakeLogTreeSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeLogTreeSnapshot_args -> IO ()
write_TakeLogTreeSnapshot_args oprot record = Thrift.writeVal oprot $ from_TakeLogTreeSnapshot_args record
-- | Serialize a 'TakeLogTreeSnapshot_args' in pure code
encode_TakeLogTreeSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeLogTreeSnapshot_args -> BS.ByteString
encode_TakeLogTreeSnapshot_args oprot record = Thrift.serializeVal oprot $ from_TakeLogTreeSnapshot_args record
-- | Translate a 'Types.ThriftVal' to a 'TakeLogTreeSnapshot_args'
to_TakeLogTreeSnapshot_args :: Types.ThriftVal -> TakeLogTreeSnapshot_args
to_TakeLogTreeSnapshot_args (Types.TStruct fields) = TakeLogTreeSnapshot_args{
  takeLogTreeSnapshot_args_min_version = maybe (takeLogTreeSnapshot_args_min_version default_TakeLogTreeSnapshot_args) (\(_,_val301) -> (case _val301 of {Types.TI64 _val302 -> _val302; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_TakeLogTreeSnapshot_args _ = error "not a struct"
-- | Read a 'TakeLogTreeSnapshot_args' struct with the given 'Thrift.Protocol'
read_TakeLogTreeSnapshot_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TakeLogTreeSnapshot_args
read_TakeLogTreeSnapshot_args iprot = to_TakeLogTreeSnapshot_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TakeLogTreeSnapshot_args)
-- | Deserialize a 'TakeLogTreeSnapshot_args' in pure code
decode_TakeLogTreeSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TakeLogTreeSnapshot_args
decode_TakeLogTreeSnapshot_args iprot bs = to_TakeLogTreeSnapshot_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TakeLogTreeSnapshot_args) bs
-- | 'TypeMap' for the 'TakeLogTreeSnapshot_args' struct
typemap_TakeLogTreeSnapshot_args :: Types.TypeMap
typemap_TakeLogTreeSnapshot_args = Map.fromList [("min_version",(1,Types.T_I64))]
-- | Default values for the 'TakeLogTreeSnapshot_args' struct
default_TakeLogTreeSnapshot_args :: TakeLogTreeSnapshot_args
default_TakeLogTreeSnapshot_args = TakeLogTreeSnapshot_args{
  takeLogTreeSnapshot_args_min_version = 0}
-- | Definition of the TakeLogTreeSnapshot_result struct
data TakeLogTreeSnapshot_result = TakeLogTreeSnapshot_result
  { takeLogTreeSnapshot_result_stale :: Maybe Exceptions_Types.StaleVersion
    -- ^ stale field of the TakeLogTreeSnapshot_result struct
  , takeLogTreeSnapshot_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the TakeLogTreeSnapshot_result struct
  , takeLogTreeSnapshot_result_notsupported :: Maybe Exceptions_Types.NotSupported
    -- ^ notsupported field of the TakeLogTreeSnapshot_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TakeLogTreeSnapshot_result where
  encode = encode_TakeLogTreeSnapshot_result
  decode = decode_TakeLogTreeSnapshot_result
instance Hashable.Hashable TakeLogTreeSnapshot_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` takeLogTreeSnapshot_result_stale record   `Hashable.hashWithSalt` takeLogTreeSnapshot_result_notready record   `Hashable.hashWithSalt` takeLogTreeSnapshot_result_notsupported record  
instance DeepSeq.NFData TakeLogTreeSnapshot_result where
  rnf _record303 =
    DeepSeq.rnf (takeLogTreeSnapshot_result_stale _record303) `seq`
    DeepSeq.rnf (takeLogTreeSnapshot_result_notready _record303) `seq`
    DeepSeq.rnf (takeLogTreeSnapshot_result_notsupported _record303) `seq`
    ()
instance Arbitrary.Arbitrary TakeLogTreeSnapshot_result where 
  arbitrary = Monad.liftM TakeLogTreeSnapshot_result (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_TakeLogTreeSnapshot_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_stale = takeLogTreeSnapshot_result_stale obj} then Nothing else Just $ default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_stale = takeLogTreeSnapshot_result_stale obj}
    , if obj == default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notready = takeLogTreeSnapshot_result_notready obj} then Nothing else Just $ default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notready = takeLogTreeSnapshot_result_notready obj}
    , if obj == default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notsupported = takeLogTreeSnapshot_result_notsupported obj} then Nothing else Just $ default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notsupported = takeLogTreeSnapshot_result_notsupported obj}
    ]
-- | Translate a 'TakeLogTreeSnapshot_result' to a 'Types.ThriftVal'
from_TakeLogTreeSnapshot_result :: TakeLogTreeSnapshot_result -> Types.ThriftVal
from_TakeLogTreeSnapshot_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v306 -> (1, ("stale",Exceptions_Types.from_StaleVersion _v306))) <$> takeLogTreeSnapshot_result_stale record, (\_v306 -> (2, ("notready",Exceptions_Types.from_NodeNotReady _v306))) <$> takeLogTreeSnapshot_result_notready record, (\_v306 -> (3, ("notsupported",Exceptions_Types.from_NotSupported _v306))) <$> takeLogTreeSnapshot_result_notsupported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v306 -> (1, ("stale",Exceptions_Types.from_StaleVersion _v306))) <$> takeLogTreeSnapshot_result_stale record
    , (\_v306 -> (2, ("notready",Exceptions_Types.from_NodeNotReady _v306))) <$> takeLogTreeSnapshot_result_notready record
    , (\_v306 -> (3, ("notsupported",Exceptions_Types.from_NotSupported _v306))) <$> takeLogTreeSnapshot_result_notsupported record
    ]
    )
-- | Write a 'TakeLogTreeSnapshot_result' with the given 'Thrift.Protocol'
write_TakeLogTreeSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeLogTreeSnapshot_result -> IO ()
write_TakeLogTreeSnapshot_result oprot record = Thrift.writeVal oprot $ from_TakeLogTreeSnapshot_result record
-- | Serialize a 'TakeLogTreeSnapshot_result' in pure code
encode_TakeLogTreeSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeLogTreeSnapshot_result -> BS.ByteString
encode_TakeLogTreeSnapshot_result oprot record = Thrift.serializeVal oprot $ from_TakeLogTreeSnapshot_result record
-- | Translate a 'Types.ThriftVal' to a 'TakeLogTreeSnapshot_result'
to_TakeLogTreeSnapshot_result :: Types.ThriftVal -> TakeLogTreeSnapshot_result
to_TakeLogTreeSnapshot_result (Types.TStruct fields) = TakeLogTreeSnapshot_result{
  takeLogTreeSnapshot_result_stale = maybe (Nothing) (\(_,_val308) -> Just (case _val308 of {Types.TStruct _val309 -> (Exceptions_Types.to_StaleVersion (Types.TStruct _val309)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  takeLogTreeSnapshot_result_notready = maybe (Nothing) (\(_,_val308) -> Just (case _val308 of {Types.TStruct _val310 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val310)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  takeLogTreeSnapshot_result_notsupported = maybe (Nothing) (\(_,_val308) -> Just (case _val308 of {Types.TStruct _val311 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val311)); _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_TakeLogTreeSnapshot_result _ = error "not a struct"
-- | Read a 'TakeLogTreeSnapshot_result' struct with the given 'Thrift.Protocol'
read_TakeLogTreeSnapshot_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TakeLogTreeSnapshot_result
read_TakeLogTreeSnapshot_result iprot = to_TakeLogTreeSnapshot_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TakeLogTreeSnapshot_result)
-- | Deserialize a 'TakeLogTreeSnapshot_result' in pure code
decode_TakeLogTreeSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TakeLogTreeSnapshot_result
decode_TakeLogTreeSnapshot_result iprot bs = to_TakeLogTreeSnapshot_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TakeLogTreeSnapshot_result) bs
-- | 'TypeMap' for the 'TakeLogTreeSnapshot_result' struct
typemap_TakeLogTreeSnapshot_result :: Types.TypeMap
typemap_TakeLogTreeSnapshot_result = Map.fromList [("stale",(1,(Types.T_STRUCT Exceptions_Types.typemap_StaleVersion))),("notready",(2,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("notsupported",(3,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'TakeLogTreeSnapshot_result' struct
default_TakeLogTreeSnapshot_result :: TakeLogTreeSnapshot_result
default_TakeLogTreeSnapshot_result = TakeLogTreeSnapshot_result{
  takeLogTreeSnapshot_result_stale = Nothing,
  takeLogTreeSnapshot_result_notready = Nothing,
  takeLogTreeSnapshot_result_notsupported = Nothing}
-- | Definition of the TakeMaintenanceLogSnapshot_args struct
data TakeMaintenanceLogSnapshot_args = TakeMaintenanceLogSnapshot_args
  { takeMaintenanceLogSnapshot_args_min_version :: Int.Int64
    -- ^ min_version field of the TakeMaintenanceLogSnapshot_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TakeMaintenanceLogSnapshot_args where
  encode = encode_TakeMaintenanceLogSnapshot_args
  decode = decode_TakeMaintenanceLogSnapshot_args
instance Hashable.Hashable TakeMaintenanceLogSnapshot_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` takeMaintenanceLogSnapshot_args_min_version record  
instance DeepSeq.NFData TakeMaintenanceLogSnapshot_args where
  rnf _record312 =
    DeepSeq.rnf (takeMaintenanceLogSnapshot_args_min_version _record312) `seq`
    ()
instance Arbitrary.Arbitrary TakeMaintenanceLogSnapshot_args where 
  arbitrary = Monad.liftM TakeMaintenanceLogSnapshot_args (Arbitrary.arbitrary)
  shrink obj | obj == default_TakeMaintenanceLogSnapshot_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TakeMaintenanceLogSnapshot_args{takeMaintenanceLogSnapshot_args_min_version = takeMaintenanceLogSnapshot_args_min_version obj} then Nothing else Just $ default_TakeMaintenanceLogSnapshot_args{takeMaintenanceLogSnapshot_args_min_version = takeMaintenanceLogSnapshot_args_min_version obj}
    ]
-- | Translate a 'TakeMaintenanceLogSnapshot_args' to a 'Types.ThriftVal'
from_TakeMaintenanceLogSnapshot_args :: TakeMaintenanceLogSnapshot_args -> Types.ThriftVal
from_TakeMaintenanceLogSnapshot_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v315 -> Just (1, ("min_version",Types.TI64 _v315))) $ takeMaintenanceLogSnapshot_args_min_version record
  ]
-- | Write a 'TakeMaintenanceLogSnapshot_args' with the given 'Thrift.Protocol'
write_TakeMaintenanceLogSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeMaintenanceLogSnapshot_args -> IO ()
write_TakeMaintenanceLogSnapshot_args oprot record = Thrift.writeVal oprot $ from_TakeMaintenanceLogSnapshot_args record
-- | Serialize a 'TakeMaintenanceLogSnapshot_args' in pure code
encode_TakeMaintenanceLogSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeMaintenanceLogSnapshot_args -> BS.ByteString
encode_TakeMaintenanceLogSnapshot_args oprot record = Thrift.serializeVal oprot $ from_TakeMaintenanceLogSnapshot_args record
-- | Translate a 'Types.ThriftVal' to a 'TakeMaintenanceLogSnapshot_args'
to_TakeMaintenanceLogSnapshot_args :: Types.ThriftVal -> TakeMaintenanceLogSnapshot_args
to_TakeMaintenanceLogSnapshot_args (Types.TStruct fields) = TakeMaintenanceLogSnapshot_args{
  takeMaintenanceLogSnapshot_args_min_version = maybe (takeMaintenanceLogSnapshot_args_min_version default_TakeMaintenanceLogSnapshot_args) (\(_,_val317) -> (case _val317 of {Types.TI64 _val318 -> _val318; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_TakeMaintenanceLogSnapshot_args _ = error "not a struct"
-- | Read a 'TakeMaintenanceLogSnapshot_args' struct with the given 'Thrift.Protocol'
read_TakeMaintenanceLogSnapshot_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TakeMaintenanceLogSnapshot_args
read_TakeMaintenanceLogSnapshot_args iprot = to_TakeMaintenanceLogSnapshot_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TakeMaintenanceLogSnapshot_args)
-- | Deserialize a 'TakeMaintenanceLogSnapshot_args' in pure code
decode_TakeMaintenanceLogSnapshot_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TakeMaintenanceLogSnapshot_args
decode_TakeMaintenanceLogSnapshot_args iprot bs = to_TakeMaintenanceLogSnapshot_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TakeMaintenanceLogSnapshot_args) bs
-- | 'TypeMap' for the 'TakeMaintenanceLogSnapshot_args' struct
typemap_TakeMaintenanceLogSnapshot_args :: Types.TypeMap
typemap_TakeMaintenanceLogSnapshot_args = Map.fromList [("min_version",(1,Types.T_I64))]
-- | Default values for the 'TakeMaintenanceLogSnapshot_args' struct
default_TakeMaintenanceLogSnapshot_args :: TakeMaintenanceLogSnapshot_args
default_TakeMaintenanceLogSnapshot_args = TakeMaintenanceLogSnapshot_args{
  takeMaintenanceLogSnapshot_args_min_version = 0}
-- | Definition of the TakeMaintenanceLogSnapshot_result struct
data TakeMaintenanceLogSnapshot_result = TakeMaintenanceLogSnapshot_result
  { takeMaintenanceLogSnapshot_result_stale :: Maybe Exceptions_Types.StaleVersion
    -- ^ stale field of the TakeMaintenanceLogSnapshot_result struct
  , takeMaintenanceLogSnapshot_result_notready :: Maybe Exceptions_Types.NodeNotReady
    -- ^ notready field of the TakeMaintenanceLogSnapshot_result struct
  , takeMaintenanceLogSnapshot_result_notsupported :: Maybe Exceptions_Types.NotSupported
    -- ^ notsupported field of the TakeMaintenanceLogSnapshot_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable TakeMaintenanceLogSnapshot_result where
  encode = encode_TakeMaintenanceLogSnapshot_result
  decode = decode_TakeMaintenanceLogSnapshot_result
instance Hashable.Hashable TakeMaintenanceLogSnapshot_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` takeMaintenanceLogSnapshot_result_stale record   `Hashable.hashWithSalt` takeMaintenanceLogSnapshot_result_notready record   `Hashable.hashWithSalt` takeMaintenanceLogSnapshot_result_notsupported record  
instance DeepSeq.NFData TakeMaintenanceLogSnapshot_result where
  rnf _record319 =
    DeepSeq.rnf (takeMaintenanceLogSnapshot_result_stale _record319) `seq`
    DeepSeq.rnf (takeMaintenanceLogSnapshot_result_notready _record319) `seq`
    DeepSeq.rnf (takeMaintenanceLogSnapshot_result_notsupported _record319) `seq`
    ()
instance Arbitrary.Arbitrary TakeMaintenanceLogSnapshot_result where 
  arbitrary = Monad.liftM TakeMaintenanceLogSnapshot_result (Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_TakeMaintenanceLogSnapshot_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_stale = takeMaintenanceLogSnapshot_result_stale obj} then Nothing else Just $ default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_stale = takeMaintenanceLogSnapshot_result_stale obj}
    , if obj == default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notready = takeMaintenanceLogSnapshot_result_notready obj} then Nothing else Just $ default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notready = takeMaintenanceLogSnapshot_result_notready obj}
    , if obj == default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notsupported = takeMaintenanceLogSnapshot_result_notsupported obj} then Nothing else Just $ default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notsupported = takeMaintenanceLogSnapshot_result_notsupported obj}
    ]
-- | Translate a 'TakeMaintenanceLogSnapshot_result' to a 'Types.ThriftVal'
from_TakeMaintenanceLogSnapshot_result :: TakeMaintenanceLogSnapshot_result -> Types.ThriftVal
from_TakeMaintenanceLogSnapshot_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v322 -> (1, ("stale",Exceptions_Types.from_StaleVersion _v322))) <$> takeMaintenanceLogSnapshot_result_stale record, (\_v322 -> (2, ("notready",Exceptions_Types.from_NodeNotReady _v322))) <$> takeMaintenanceLogSnapshot_result_notready record, (\_v322 -> (3, ("notsupported",Exceptions_Types.from_NotSupported _v322))) <$> takeMaintenanceLogSnapshot_result_notsupported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v322 -> (1, ("stale",Exceptions_Types.from_StaleVersion _v322))) <$> takeMaintenanceLogSnapshot_result_stale record
    , (\_v322 -> (2, ("notready",Exceptions_Types.from_NodeNotReady _v322))) <$> takeMaintenanceLogSnapshot_result_notready record
    , (\_v322 -> (3, ("notsupported",Exceptions_Types.from_NotSupported _v322))) <$> takeMaintenanceLogSnapshot_result_notsupported record
    ]
    )
-- | Write a 'TakeMaintenanceLogSnapshot_result' with the given 'Thrift.Protocol'
write_TakeMaintenanceLogSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeMaintenanceLogSnapshot_result -> IO ()
write_TakeMaintenanceLogSnapshot_result oprot record = Thrift.writeVal oprot $ from_TakeMaintenanceLogSnapshot_result record
-- | Serialize a 'TakeMaintenanceLogSnapshot_result' in pure code
encode_TakeMaintenanceLogSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> TakeMaintenanceLogSnapshot_result -> BS.ByteString
encode_TakeMaintenanceLogSnapshot_result oprot record = Thrift.serializeVal oprot $ from_TakeMaintenanceLogSnapshot_result record
-- | Translate a 'Types.ThriftVal' to a 'TakeMaintenanceLogSnapshot_result'
to_TakeMaintenanceLogSnapshot_result :: Types.ThriftVal -> TakeMaintenanceLogSnapshot_result
to_TakeMaintenanceLogSnapshot_result (Types.TStruct fields) = TakeMaintenanceLogSnapshot_result{
  takeMaintenanceLogSnapshot_result_stale = maybe (Nothing) (\(_,_val324) -> Just (case _val324 of {Types.TStruct _val325 -> (Exceptions_Types.to_StaleVersion (Types.TStruct _val325)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  takeMaintenanceLogSnapshot_result_notready = maybe (Nothing) (\(_,_val324) -> Just (case _val324 of {Types.TStruct _val326 -> (Exceptions_Types.to_NodeNotReady (Types.TStruct _val326)); _ -> error "wrong type"})) (Map.lookup (2) fields),
  takeMaintenanceLogSnapshot_result_notsupported = maybe (Nothing) (\(_,_val324) -> Just (case _val324 of {Types.TStruct _val327 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val327)); _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_TakeMaintenanceLogSnapshot_result _ = error "not a struct"
-- | Read a 'TakeMaintenanceLogSnapshot_result' struct with the given 'Thrift.Protocol'
read_TakeMaintenanceLogSnapshot_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO TakeMaintenanceLogSnapshot_result
read_TakeMaintenanceLogSnapshot_result iprot = to_TakeMaintenanceLogSnapshot_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_TakeMaintenanceLogSnapshot_result)
-- | Deserialize a 'TakeMaintenanceLogSnapshot_result' in pure code
decode_TakeMaintenanceLogSnapshot_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> TakeMaintenanceLogSnapshot_result
decode_TakeMaintenanceLogSnapshot_result iprot bs = to_TakeMaintenanceLogSnapshot_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_TakeMaintenanceLogSnapshot_result) bs
-- | 'TypeMap' for the 'TakeMaintenanceLogSnapshot_result' struct
typemap_TakeMaintenanceLogSnapshot_result :: Types.TypeMap
typemap_TakeMaintenanceLogSnapshot_result = Map.fromList [("stale",(1,(Types.T_STRUCT Exceptions_Types.typemap_StaleVersion))),("notready",(2,(Types.T_STRUCT Exceptions_Types.typemap_NodeNotReady))),("notsupported",(3,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'TakeMaintenanceLogSnapshot_result' struct
default_TakeMaintenanceLogSnapshot_result :: TakeMaintenanceLogSnapshot_result
default_TakeMaintenanceLogSnapshot_result = TakeMaintenanceLogSnapshot_result{
  takeMaintenanceLogSnapshot_result_stale = Nothing,
  takeMaintenanceLogSnapshot_result_notready = Nothing,
  takeMaintenanceLogSnapshot_result_notsupported = Nothing}
-- | Definition of the GetLogGroupThroughput_args struct
data GetLogGroupThroughput_args = GetLogGroupThroughput_args
  { getLogGroupThroughput_args_request :: Logtree_Types.LogGroupThroughputRequest
    -- ^ request field of the GetLogGroupThroughput_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogGroupThroughput_args where
  encode = encode_GetLogGroupThroughput_args
  decode = decode_GetLogGroupThroughput_args
instance Hashable.Hashable GetLogGroupThroughput_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getLogGroupThroughput_args_request record  
instance DeepSeq.NFData GetLogGroupThroughput_args where
  rnf _record328 =
    DeepSeq.rnf (getLogGroupThroughput_args_request _record328) `seq`
    ()
instance Arbitrary.Arbitrary GetLogGroupThroughput_args where 
  arbitrary = Monad.liftM GetLogGroupThroughput_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetLogGroupThroughput_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetLogGroupThroughput_args{getLogGroupThroughput_args_request = getLogGroupThroughput_args_request obj} then Nothing else Just $ default_GetLogGroupThroughput_args{getLogGroupThroughput_args_request = getLogGroupThroughput_args_request obj}
    ]
-- | Translate a 'GetLogGroupThroughput_args' to a 'Types.ThriftVal'
from_GetLogGroupThroughput_args :: GetLogGroupThroughput_args -> Types.ThriftVal
from_GetLogGroupThroughput_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v331 -> Just (1, ("request",Logtree_Types.from_LogGroupThroughputRequest _v331))) $ getLogGroupThroughput_args_request record
  ]
-- | Write a 'GetLogGroupThroughput_args' with the given 'Thrift.Protocol'
write_GetLogGroupThroughput_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupThroughput_args -> IO ()
write_GetLogGroupThroughput_args oprot record = Thrift.writeVal oprot $ from_GetLogGroupThroughput_args record
-- | Serialize a 'GetLogGroupThroughput_args' in pure code
encode_GetLogGroupThroughput_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupThroughput_args -> BS.ByteString
encode_GetLogGroupThroughput_args oprot record = Thrift.serializeVal oprot $ from_GetLogGroupThroughput_args record
-- | Translate a 'Types.ThriftVal' to a 'GetLogGroupThroughput_args'
to_GetLogGroupThroughput_args :: Types.ThriftVal -> GetLogGroupThroughput_args
to_GetLogGroupThroughput_args (Types.TStruct fields) = GetLogGroupThroughput_args{
  getLogGroupThroughput_args_request = maybe (getLogGroupThroughput_args_request default_GetLogGroupThroughput_args) (\(_,_val333) -> (case _val333 of {Types.TStruct _val334 -> (Logtree_Types.to_LogGroupThroughputRequest (Types.TStruct _val334)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLogGroupThroughput_args _ = error "not a struct"
-- | Read a 'GetLogGroupThroughput_args' struct with the given 'Thrift.Protocol'
read_GetLogGroupThroughput_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogGroupThroughput_args
read_GetLogGroupThroughput_args iprot = to_GetLogGroupThroughput_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogGroupThroughput_args)
-- | Deserialize a 'GetLogGroupThroughput_args' in pure code
decode_GetLogGroupThroughput_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogGroupThroughput_args
decode_GetLogGroupThroughput_args iprot bs = to_GetLogGroupThroughput_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogGroupThroughput_args) bs
-- | 'TypeMap' for the 'GetLogGroupThroughput_args' struct
typemap_GetLogGroupThroughput_args :: Types.TypeMap
typemap_GetLogGroupThroughput_args = Map.fromList [("request",(1,(Types.T_STRUCT Logtree_Types.typemap_LogGroupThroughputRequest)))]
-- | Default values for the 'GetLogGroupThroughput_args' struct
default_GetLogGroupThroughput_args :: GetLogGroupThroughput_args
default_GetLogGroupThroughput_args = GetLogGroupThroughput_args{
  getLogGroupThroughput_args_request = Logtree_Types.default_LogGroupThroughputRequest}
-- | Definition of the GetLogGroupThroughput_result struct
data GetLogGroupThroughput_result = GetLogGroupThroughput_result
  { getLogGroupThroughput_result_success :: Logtree_Types.LogGroupThroughputResponse
    -- ^ success field of the GetLogGroupThroughput_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogGroupThroughput_result where
  encode = encode_GetLogGroupThroughput_result
  decode = decode_GetLogGroupThroughput_result
instance Hashable.Hashable GetLogGroupThroughput_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getLogGroupThroughput_result_success record  
instance DeepSeq.NFData GetLogGroupThroughput_result where
  rnf _record335 =
    DeepSeq.rnf (getLogGroupThroughput_result_success _record335) `seq`
    ()
instance Arbitrary.Arbitrary GetLogGroupThroughput_result where 
  arbitrary = Monad.liftM GetLogGroupThroughput_result (Arbitrary.arbitrary)
  shrink obj | obj == default_GetLogGroupThroughput_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetLogGroupThroughput_result{getLogGroupThroughput_result_success = getLogGroupThroughput_result_success obj} then Nothing else Just $ default_GetLogGroupThroughput_result{getLogGroupThroughput_result_success = getLogGroupThroughput_result_success obj}
    ]
-- | Translate a 'GetLogGroupThroughput_result' to a 'Types.ThriftVal'
from_GetLogGroupThroughput_result :: GetLogGroupThroughput_result -> Types.ThriftVal
from_GetLogGroupThroughput_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v338 -> Just (0, ("success",Logtree_Types.from_LogGroupThroughputResponse _v338))) $ getLogGroupThroughput_result_success record
  ]
-- | Write a 'GetLogGroupThroughput_result' with the given 'Thrift.Protocol'
write_GetLogGroupThroughput_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupThroughput_result -> IO ()
write_GetLogGroupThroughput_result oprot record = Thrift.writeVal oprot $ from_GetLogGroupThroughput_result record
-- | Serialize a 'GetLogGroupThroughput_result' in pure code
encode_GetLogGroupThroughput_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupThroughput_result -> BS.ByteString
encode_GetLogGroupThroughput_result oprot record = Thrift.serializeVal oprot $ from_GetLogGroupThroughput_result record
-- | Translate a 'Types.ThriftVal' to a 'GetLogGroupThroughput_result'
to_GetLogGroupThroughput_result :: Types.ThriftVal -> GetLogGroupThroughput_result
to_GetLogGroupThroughput_result (Types.TStruct fields) = GetLogGroupThroughput_result{
  getLogGroupThroughput_result_success = maybe (getLogGroupThroughput_result_success default_GetLogGroupThroughput_result) (\(_,_val340) -> (case _val340 of {Types.TStruct _val341 -> (Logtree_Types.to_LogGroupThroughputResponse (Types.TStruct _val341)); _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetLogGroupThroughput_result _ = error "not a struct"
-- | Read a 'GetLogGroupThroughput_result' struct with the given 'Thrift.Protocol'
read_GetLogGroupThroughput_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogGroupThroughput_result
read_GetLogGroupThroughput_result iprot = to_GetLogGroupThroughput_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogGroupThroughput_result)
-- | Deserialize a 'GetLogGroupThroughput_result' in pure code
decode_GetLogGroupThroughput_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogGroupThroughput_result
decode_GetLogGroupThroughput_result iprot bs = to_GetLogGroupThroughput_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogGroupThroughput_result) bs
-- | 'TypeMap' for the 'GetLogGroupThroughput_result' struct
typemap_GetLogGroupThroughput_result :: Types.TypeMap
typemap_GetLogGroupThroughput_result = Map.fromList [("success",(0,(Types.T_STRUCT Logtree_Types.typemap_LogGroupThroughputResponse)))]
-- | Default values for the 'GetLogGroupThroughput_result' struct
default_GetLogGroupThroughput_result :: GetLogGroupThroughput_result
default_GetLogGroupThroughput_result = GetLogGroupThroughput_result{
  getLogGroupThroughput_result_success = Logtree_Types.default_LogGroupThroughputResponse}
-- | Definition of the GetLogGroupCustomCounters_args struct
data GetLogGroupCustomCounters_args = GetLogGroupCustomCounters_args
  { getLogGroupCustomCounters_args_request :: Logtree_Types.LogGroupCustomCountersRequest
    -- ^ request field of the GetLogGroupCustomCounters_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogGroupCustomCounters_args where
  encode = encode_GetLogGroupCustomCounters_args
  decode = decode_GetLogGroupCustomCounters_args
instance Hashable.Hashable GetLogGroupCustomCounters_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getLogGroupCustomCounters_args_request record  
instance DeepSeq.NFData GetLogGroupCustomCounters_args where
  rnf _record342 =
    DeepSeq.rnf (getLogGroupCustomCounters_args_request _record342) `seq`
    ()
instance Arbitrary.Arbitrary GetLogGroupCustomCounters_args where 
  arbitrary = Monad.liftM GetLogGroupCustomCounters_args (Arbitrary.arbitrary)
  shrink obj | obj == default_GetLogGroupCustomCounters_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetLogGroupCustomCounters_args{getLogGroupCustomCounters_args_request = getLogGroupCustomCounters_args_request obj} then Nothing else Just $ default_GetLogGroupCustomCounters_args{getLogGroupCustomCounters_args_request = getLogGroupCustomCounters_args_request obj}
    ]
-- | Translate a 'GetLogGroupCustomCounters_args' to a 'Types.ThriftVal'
from_GetLogGroupCustomCounters_args :: GetLogGroupCustomCounters_args -> Types.ThriftVal
from_GetLogGroupCustomCounters_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v345 -> Just (1, ("request",Logtree_Types.from_LogGroupCustomCountersRequest _v345))) $ getLogGroupCustomCounters_args_request record
  ]
-- | Write a 'GetLogGroupCustomCounters_args' with the given 'Thrift.Protocol'
write_GetLogGroupCustomCounters_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupCustomCounters_args -> IO ()
write_GetLogGroupCustomCounters_args oprot record = Thrift.writeVal oprot $ from_GetLogGroupCustomCounters_args record
-- | Serialize a 'GetLogGroupCustomCounters_args' in pure code
encode_GetLogGroupCustomCounters_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupCustomCounters_args -> BS.ByteString
encode_GetLogGroupCustomCounters_args oprot record = Thrift.serializeVal oprot $ from_GetLogGroupCustomCounters_args record
-- | Translate a 'Types.ThriftVal' to a 'GetLogGroupCustomCounters_args'
to_GetLogGroupCustomCounters_args :: Types.ThriftVal -> GetLogGroupCustomCounters_args
to_GetLogGroupCustomCounters_args (Types.TStruct fields) = GetLogGroupCustomCounters_args{
  getLogGroupCustomCounters_args_request = maybe (getLogGroupCustomCounters_args_request default_GetLogGroupCustomCounters_args) (\(_,_val347) -> (case _val347 of {Types.TStruct _val348 -> (Logtree_Types.to_LogGroupCustomCountersRequest (Types.TStruct _val348)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLogGroupCustomCounters_args _ = error "not a struct"
-- | Read a 'GetLogGroupCustomCounters_args' struct with the given 'Thrift.Protocol'
read_GetLogGroupCustomCounters_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogGroupCustomCounters_args
read_GetLogGroupCustomCounters_args iprot = to_GetLogGroupCustomCounters_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogGroupCustomCounters_args)
-- | Deserialize a 'GetLogGroupCustomCounters_args' in pure code
decode_GetLogGroupCustomCounters_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogGroupCustomCounters_args
decode_GetLogGroupCustomCounters_args iprot bs = to_GetLogGroupCustomCounters_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogGroupCustomCounters_args) bs
-- | 'TypeMap' for the 'GetLogGroupCustomCounters_args' struct
typemap_GetLogGroupCustomCounters_args :: Types.TypeMap
typemap_GetLogGroupCustomCounters_args = Map.fromList [("request",(1,(Types.T_STRUCT Logtree_Types.typemap_LogGroupCustomCountersRequest)))]
-- | Default values for the 'GetLogGroupCustomCounters_args' struct
default_GetLogGroupCustomCounters_args :: GetLogGroupCustomCounters_args
default_GetLogGroupCustomCounters_args = GetLogGroupCustomCounters_args{
  getLogGroupCustomCounters_args_request = Logtree_Types.default_LogGroupCustomCountersRequest}
-- | Definition of the GetLogGroupCustomCounters_result struct
data GetLogGroupCustomCounters_result = GetLogGroupCustomCounters_result
  { getLogGroupCustomCounters_result_success :: Logtree_Types.LogGroupCustomCountersResponse
    -- ^ success field of the GetLogGroupCustomCounters_result struct
  , getLogGroupCustomCounters_result_notsupported :: Maybe Exceptions_Types.NotSupported
    -- ^ notsupported field of the GetLogGroupCustomCounters_result struct
  , getLogGroupCustomCounters_result_invalid_request :: Maybe Exceptions_Types.InvalidRequest
    -- ^ invalid_request field of the GetLogGroupCustomCounters_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetLogGroupCustomCounters_result where
  encode = encode_GetLogGroupCustomCounters_result
  decode = decode_GetLogGroupCustomCounters_result
instance Hashable.Hashable GetLogGroupCustomCounters_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getLogGroupCustomCounters_result_success record   `Hashable.hashWithSalt` getLogGroupCustomCounters_result_notsupported record   `Hashable.hashWithSalt` getLogGroupCustomCounters_result_invalid_request record  
instance DeepSeq.NFData GetLogGroupCustomCounters_result where
  rnf _record349 =
    DeepSeq.rnf (getLogGroupCustomCounters_result_success _record349) `seq`
    DeepSeq.rnf (getLogGroupCustomCounters_result_notsupported _record349) `seq`
    DeepSeq.rnf (getLogGroupCustomCounters_result_invalid_request _record349) `seq`
    ()
instance Arbitrary.Arbitrary GetLogGroupCustomCounters_result where 
  arbitrary = Monad.liftM GetLogGroupCustomCounters_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_GetLogGroupCustomCounters_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_success = getLogGroupCustomCounters_result_success obj} then Nothing else Just $ default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_success = getLogGroupCustomCounters_result_success obj}
    , if obj == default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_notsupported = getLogGroupCustomCounters_result_notsupported obj} then Nothing else Just $ default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_notsupported = getLogGroupCustomCounters_result_notsupported obj}
    , if obj == default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_invalid_request = getLogGroupCustomCounters_result_invalid_request obj} then Nothing else Just $ default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_invalid_request = getLogGroupCustomCounters_result_invalid_request obj}
    ]
-- | Translate a 'GetLogGroupCustomCounters_result' to a 'Types.ThriftVal'
from_GetLogGroupCustomCounters_result :: GetLogGroupCustomCounters_result -> Types.ThriftVal
from_GetLogGroupCustomCounters_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v352 -> (1, ("notsupported",Exceptions_Types.from_NotSupported _v352))) <$> getLogGroupCustomCounters_result_notsupported record, (\_v352 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v352))) <$> getLogGroupCustomCounters_result_invalid_request record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v352 -> Just (0, ("success",Logtree_Types.from_LogGroupCustomCountersResponse _v352))) $ getLogGroupCustomCounters_result_success record
    , (\_v352 -> (1, ("notsupported",Exceptions_Types.from_NotSupported _v352))) <$> getLogGroupCustomCounters_result_notsupported record
    , (\_v352 -> (2, ("invalid_request",Exceptions_Types.from_InvalidRequest _v352))) <$> getLogGroupCustomCounters_result_invalid_request record
    ]
    )
-- | Write a 'GetLogGroupCustomCounters_result' with the given 'Thrift.Protocol'
write_GetLogGroupCustomCounters_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupCustomCounters_result -> IO ()
write_GetLogGroupCustomCounters_result oprot record = Thrift.writeVal oprot $ from_GetLogGroupCustomCounters_result record
-- | Serialize a 'GetLogGroupCustomCounters_result' in pure code
encode_GetLogGroupCustomCounters_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetLogGroupCustomCounters_result -> BS.ByteString
encode_GetLogGroupCustomCounters_result oprot record = Thrift.serializeVal oprot $ from_GetLogGroupCustomCounters_result record
-- | Translate a 'Types.ThriftVal' to a 'GetLogGroupCustomCounters_result'
to_GetLogGroupCustomCounters_result :: Types.ThriftVal -> GetLogGroupCustomCounters_result
to_GetLogGroupCustomCounters_result (Types.TStruct fields) = GetLogGroupCustomCounters_result{
  getLogGroupCustomCounters_result_success = maybe (getLogGroupCustomCounters_result_success default_GetLogGroupCustomCounters_result) (\(_,_val354) -> (case _val354 of {Types.TStruct _val355 -> (Logtree_Types.to_LogGroupCustomCountersResponse (Types.TStruct _val355)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  getLogGroupCustomCounters_result_notsupported = maybe (Nothing) (\(_,_val354) -> Just (case _val354 of {Types.TStruct _val356 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val356)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  getLogGroupCustomCounters_result_invalid_request = maybe (Nothing) (\(_,_val354) -> Just (case _val354 of {Types.TStruct _val357 -> (Exceptions_Types.to_InvalidRequest (Types.TStruct _val357)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetLogGroupCustomCounters_result _ = error "not a struct"
-- | Read a 'GetLogGroupCustomCounters_result' struct with the given 'Thrift.Protocol'
read_GetLogGroupCustomCounters_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetLogGroupCustomCounters_result
read_GetLogGroupCustomCounters_result iprot = to_GetLogGroupCustomCounters_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetLogGroupCustomCounters_result)
-- | Deserialize a 'GetLogGroupCustomCounters_result' in pure code
decode_GetLogGroupCustomCounters_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetLogGroupCustomCounters_result
decode_GetLogGroupCustomCounters_result iprot bs = to_GetLogGroupCustomCounters_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetLogGroupCustomCounters_result) bs
-- | 'TypeMap' for the 'GetLogGroupCustomCounters_result' struct
typemap_GetLogGroupCustomCounters_result :: Types.TypeMap
typemap_GetLogGroupCustomCounters_result = Map.fromList [("success",(0,(Types.T_STRUCT Logtree_Types.typemap_LogGroupCustomCountersResponse))),("notsupported",(1,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported))),("invalid_request",(2,(Types.T_STRUCT Exceptions_Types.typemap_InvalidRequest)))]
-- | Default values for the 'GetLogGroupCustomCounters_result' struct
default_GetLogGroupCustomCounters_result :: GetLogGroupCustomCounters_result
default_GetLogGroupCustomCounters_result = GetLogGroupCustomCounters_result{
  getLogGroupCustomCounters_result_success = Logtree_Types.default_LogGroupCustomCountersResponse,
  getLogGroupCustomCounters_result_notsupported = Nothing,
  getLogGroupCustomCounters_result_invalid_request = Nothing}
-- | Definition of the ExecuteAdminCommand_args struct
data ExecuteAdminCommand_args = ExecuteAdminCommand_args
  { executeAdminCommand_args_request :: Admin_commands_Types.AdminCommandRequest
    -- ^ request field of the ExecuteAdminCommand_args struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ExecuteAdminCommand_args where
  encode = encode_ExecuteAdminCommand_args
  decode = decode_ExecuteAdminCommand_args
instance Hashable.Hashable ExecuteAdminCommand_args where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` executeAdminCommand_args_request record  
instance DeepSeq.NFData ExecuteAdminCommand_args where
  rnf _record358 =
    DeepSeq.rnf (executeAdminCommand_args_request _record358) `seq`
    ()
instance Arbitrary.Arbitrary ExecuteAdminCommand_args where 
  arbitrary = Monad.liftM ExecuteAdminCommand_args (Arbitrary.arbitrary)
  shrink obj | obj == default_ExecuteAdminCommand_args = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ExecuteAdminCommand_args{executeAdminCommand_args_request = executeAdminCommand_args_request obj} then Nothing else Just $ default_ExecuteAdminCommand_args{executeAdminCommand_args_request = executeAdminCommand_args_request obj}
    ]
-- | Translate a 'ExecuteAdminCommand_args' to a 'Types.ThriftVal'
from_ExecuteAdminCommand_args :: ExecuteAdminCommand_args -> Types.ThriftVal
from_ExecuteAdminCommand_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v361 -> Just (1, ("request",Admin_commands_Types.from_AdminCommandRequest _v361))) $ executeAdminCommand_args_request record
  ]
-- | Write a 'ExecuteAdminCommand_args' with the given 'Thrift.Protocol'
write_ExecuteAdminCommand_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ExecuteAdminCommand_args -> IO ()
write_ExecuteAdminCommand_args oprot record = Thrift.writeVal oprot $ from_ExecuteAdminCommand_args record
-- | Serialize a 'ExecuteAdminCommand_args' in pure code
encode_ExecuteAdminCommand_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ExecuteAdminCommand_args -> BS.ByteString
encode_ExecuteAdminCommand_args oprot record = Thrift.serializeVal oprot $ from_ExecuteAdminCommand_args record
-- | Translate a 'Types.ThriftVal' to a 'ExecuteAdminCommand_args'
to_ExecuteAdminCommand_args :: Types.ThriftVal -> ExecuteAdminCommand_args
to_ExecuteAdminCommand_args (Types.TStruct fields) = ExecuteAdminCommand_args{
  executeAdminCommand_args_request = maybe (executeAdminCommand_args_request default_ExecuteAdminCommand_args) (\(_,_val363) -> (case _val363 of {Types.TStruct _val364 -> (Admin_commands_Types.to_AdminCommandRequest (Types.TStruct _val364)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_ExecuteAdminCommand_args _ = error "not a struct"
-- | Read a 'ExecuteAdminCommand_args' struct with the given 'Thrift.Protocol'
read_ExecuteAdminCommand_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ExecuteAdminCommand_args
read_ExecuteAdminCommand_args iprot = to_ExecuteAdminCommand_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ExecuteAdminCommand_args)
-- | Deserialize a 'ExecuteAdminCommand_args' in pure code
decode_ExecuteAdminCommand_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ExecuteAdminCommand_args
decode_ExecuteAdminCommand_args iprot bs = to_ExecuteAdminCommand_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ExecuteAdminCommand_args) bs
-- | 'TypeMap' for the 'ExecuteAdminCommand_args' struct
typemap_ExecuteAdminCommand_args :: Types.TypeMap
typemap_ExecuteAdminCommand_args = Map.fromList [("request",(1,(Types.T_STRUCT Admin_commands_Types.typemap_AdminCommandRequest)))]
-- | Default values for the 'ExecuteAdminCommand_args' struct
default_ExecuteAdminCommand_args :: ExecuteAdminCommand_args
default_ExecuteAdminCommand_args = ExecuteAdminCommand_args{
  executeAdminCommand_args_request = Admin_commands_Types.default_AdminCommandRequest}
-- | Definition of the ExecuteAdminCommand_result struct
data ExecuteAdminCommand_result = ExecuteAdminCommand_result
  { executeAdminCommand_result_success :: Admin_commands_Types.AdminCommandResponse
    -- ^ success field of the ExecuteAdminCommand_result struct
  , executeAdminCommand_result_notsupported :: Maybe Exceptions_Types.NotSupported
    -- ^ notsupported field of the ExecuteAdminCommand_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ExecuteAdminCommand_result where
  encode = encode_ExecuteAdminCommand_result
  decode = decode_ExecuteAdminCommand_result
instance Hashable.Hashable ExecuteAdminCommand_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` executeAdminCommand_result_success record   `Hashable.hashWithSalt` executeAdminCommand_result_notsupported record  
instance DeepSeq.NFData ExecuteAdminCommand_result where
  rnf _record365 =
    DeepSeq.rnf (executeAdminCommand_result_success _record365) `seq`
    DeepSeq.rnf (executeAdminCommand_result_notsupported _record365) `seq`
    ()
instance Arbitrary.Arbitrary ExecuteAdminCommand_result where 
  arbitrary = Monad.liftM ExecuteAdminCommand_result (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_ExecuteAdminCommand_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ExecuteAdminCommand_result{executeAdminCommand_result_success = executeAdminCommand_result_success obj} then Nothing else Just $ default_ExecuteAdminCommand_result{executeAdminCommand_result_success = executeAdminCommand_result_success obj}
    , if obj == default_ExecuteAdminCommand_result{executeAdminCommand_result_notsupported = executeAdminCommand_result_notsupported obj} then Nothing else Just $ default_ExecuteAdminCommand_result{executeAdminCommand_result_notsupported = executeAdminCommand_result_notsupported obj}
    ]
-- | Translate a 'ExecuteAdminCommand_result' to a 'Types.ThriftVal'
from_ExecuteAdminCommand_result :: ExecuteAdminCommand_result -> Types.ThriftVal
from_ExecuteAdminCommand_result record = Types.TStruct $ Map.fromList 
  (let exns = Maybe.catMaybes [ (\_v368 -> (1, ("notsupported",Exceptions_Types.from_NotSupported _v368))) <$> executeAdminCommand_result_notsupported record]
  in if not (null exns) then exns else Maybe.catMaybes
    [ (\_v368 -> Just (0, ("success",Admin_commands_Types.from_AdminCommandResponse _v368))) $ executeAdminCommand_result_success record
    , (\_v368 -> (1, ("notsupported",Exceptions_Types.from_NotSupported _v368))) <$> executeAdminCommand_result_notsupported record
    ]
    )
-- | Write a 'ExecuteAdminCommand_result' with the given 'Thrift.Protocol'
write_ExecuteAdminCommand_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ExecuteAdminCommand_result -> IO ()
write_ExecuteAdminCommand_result oprot record = Thrift.writeVal oprot $ from_ExecuteAdminCommand_result record
-- | Serialize a 'ExecuteAdminCommand_result' in pure code
encode_ExecuteAdminCommand_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ExecuteAdminCommand_result -> BS.ByteString
encode_ExecuteAdminCommand_result oprot record = Thrift.serializeVal oprot $ from_ExecuteAdminCommand_result record
-- | Translate a 'Types.ThriftVal' to a 'ExecuteAdminCommand_result'
to_ExecuteAdminCommand_result :: Types.ThriftVal -> ExecuteAdminCommand_result
to_ExecuteAdminCommand_result (Types.TStruct fields) = ExecuteAdminCommand_result{
  executeAdminCommand_result_success = maybe (executeAdminCommand_result_success default_ExecuteAdminCommand_result) (\(_,_val370) -> (case _val370 of {Types.TStruct _val371 -> (Admin_commands_Types.to_AdminCommandResponse (Types.TStruct _val371)); _ -> error "wrong type"})) (Map.lookup (0) fields),
  executeAdminCommand_result_notsupported = maybe (Nothing) (\(_,_val370) -> Just (case _val370 of {Types.TStruct _val372 -> (Exceptions_Types.to_NotSupported (Types.TStruct _val372)); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_ExecuteAdminCommand_result _ = error "not a struct"
-- | Read a 'ExecuteAdminCommand_result' struct with the given 'Thrift.Protocol'
read_ExecuteAdminCommand_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ExecuteAdminCommand_result
read_ExecuteAdminCommand_result iprot = to_ExecuteAdminCommand_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ExecuteAdminCommand_result)
-- | Deserialize a 'ExecuteAdminCommand_result' in pure code
decode_ExecuteAdminCommand_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ExecuteAdminCommand_result
decode_ExecuteAdminCommand_result iprot bs = to_ExecuteAdminCommand_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ExecuteAdminCommand_result) bs
-- | 'TypeMap' for the 'ExecuteAdminCommand_result' struct
typemap_ExecuteAdminCommand_result :: Types.TypeMap
typemap_ExecuteAdminCommand_result = Map.fromList [("success",(0,(Types.T_STRUCT Admin_commands_Types.typemap_AdminCommandResponse))),("notsupported",(1,(Types.T_STRUCT Exceptions_Types.typemap_NotSupported)))]
-- | Default values for the 'ExecuteAdminCommand_result' struct
default_ExecuteAdminCommand_result :: ExecuteAdminCommand_result
default_ExecuteAdminCommand_result = ExecuteAdminCommand_result{
  executeAdminCommand_result_success = Admin_commands_Types.default_AdminCommandResponse,
  executeAdminCommand_result_notsupported = Nothing}
-- | Definition of the GetClusterName_args struct
data GetClusterName_args = GetClusterName_args
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetClusterName_args where
  encode = encode_GetClusterName_args
  decode = decode_GetClusterName_args
instance Hashable.Hashable GetClusterName_args where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData GetClusterName_args where
  rnf _record373 =
    ()
instance Arbitrary.Arbitrary GetClusterName_args where 
  arbitrary = QuickCheck.elements [GetClusterName_args]
-- | Translate a 'GetClusterName_args' to a 'Types.ThriftVal'
from_GetClusterName_args :: GetClusterName_args -> Types.ThriftVal
from_GetClusterName_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'GetClusterName_args' with the given 'Thrift.Protocol'
write_GetClusterName_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetClusterName_args -> IO ()
write_GetClusterName_args oprot record = Thrift.writeVal oprot $ from_GetClusterName_args record
-- | Serialize a 'GetClusterName_args' in pure code
encode_GetClusterName_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetClusterName_args -> BS.ByteString
encode_GetClusterName_args oprot record = Thrift.serializeVal oprot $ from_GetClusterName_args record
-- | Translate a 'Types.ThriftVal' to a 'GetClusterName_args'
to_GetClusterName_args :: Types.ThriftVal -> GetClusterName_args
to_GetClusterName_args (Types.TStruct fields) = GetClusterName_args{

  }
to_GetClusterName_args _ = error "not a struct"
-- | Read a 'GetClusterName_args' struct with the given 'Thrift.Protocol'
read_GetClusterName_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetClusterName_args
read_GetClusterName_args iprot = to_GetClusterName_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetClusterName_args)
-- | Deserialize a 'GetClusterName_args' in pure code
decode_GetClusterName_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetClusterName_args
decode_GetClusterName_args iprot bs = to_GetClusterName_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetClusterName_args) bs
-- | 'TypeMap' for the 'GetClusterName_args' struct
typemap_GetClusterName_args :: Types.TypeMap
typemap_GetClusterName_args = Map.fromList []
-- | Default values for the 'GetClusterName_args' struct
default_GetClusterName_args :: GetClusterName_args
default_GetClusterName_args = GetClusterName_args{
}
-- | Definition of the GetClusterName_result struct
data GetClusterName_result = GetClusterName_result
  { getClusterName_result_success :: LT.Text
    -- ^ success field of the GetClusterName_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable GetClusterName_result where
  encode = encode_GetClusterName_result
  decode = decode_GetClusterName_result
instance Hashable.Hashable GetClusterName_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` getClusterName_result_success record  
instance DeepSeq.NFData GetClusterName_result where
  rnf _record379 =
    DeepSeq.rnf (getClusterName_result_success _record379) `seq`
    ()
instance Arbitrary.Arbitrary GetClusterName_result where 
  arbitrary = Monad.liftM GetClusterName_result (Arbitrary.arbitrary)
  shrink obj | obj == default_GetClusterName_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_GetClusterName_result{getClusterName_result_success = getClusterName_result_success obj} then Nothing else Just $ default_GetClusterName_result{getClusterName_result_success = getClusterName_result_success obj}
    ]
-- | Translate a 'GetClusterName_result' to a 'Types.ThriftVal'
from_GetClusterName_result :: GetClusterName_result -> Types.ThriftVal
from_GetClusterName_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v382 -> Just (0, ("success",Types.TString $ Encoding.encodeUtf8 _v382))) $ getClusterName_result_success record
  ]
-- | Write a 'GetClusterName_result' with the given 'Thrift.Protocol'
write_GetClusterName_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetClusterName_result -> IO ()
write_GetClusterName_result oprot record = Thrift.writeVal oprot $ from_GetClusterName_result record
-- | Serialize a 'GetClusterName_result' in pure code
encode_GetClusterName_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> GetClusterName_result -> BS.ByteString
encode_GetClusterName_result oprot record = Thrift.serializeVal oprot $ from_GetClusterName_result record
-- | Translate a 'Types.ThriftVal' to a 'GetClusterName_result'
to_GetClusterName_result :: Types.ThriftVal -> GetClusterName_result
to_GetClusterName_result (Types.TStruct fields) = GetClusterName_result{
  getClusterName_result_success = maybe (getClusterName_result_success default_GetClusterName_result) (\(_,_val384) -> (case _val384 of {Types.TString _val385 -> Encoding.decodeUtf8 _val385; _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetClusterName_result _ = error "not a struct"
-- | Read a 'GetClusterName_result' struct with the given 'Thrift.Protocol'
read_GetClusterName_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO GetClusterName_result
read_GetClusterName_result iprot = to_GetClusterName_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_GetClusterName_result)
-- | Deserialize a 'GetClusterName_result' in pure code
decode_GetClusterName_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> GetClusterName_result
decode_GetClusterName_result iprot bs = to_GetClusterName_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_GetClusterName_result) bs
-- | 'TypeMap' for the 'GetClusterName_result' struct
typemap_GetClusterName_result :: Types.TypeMap
typemap_GetClusterName_result = Map.fromList [("success",(0,Types.T_STRING))]
-- | Default values for the 'GetClusterName_result' struct
default_GetClusterName_result :: GetClusterName_result
default_GetClusterName_result = GetClusterName_result{
  getClusterName_result_success = ""}
-- | Definition of the DumpServerConfigJson_args struct
data DumpServerConfigJson_args = DumpServerConfigJson_args
 deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable DumpServerConfigJson_args where
  encode = encode_DumpServerConfigJson_args
  decode = decode_DumpServerConfigJson_args
instance Hashable.Hashable DumpServerConfigJson_args where
  hashWithSalt salt record = salt  
instance DeepSeq.NFData DumpServerConfigJson_args where
  rnf _record386 =
    ()
instance Arbitrary.Arbitrary DumpServerConfigJson_args where 
  arbitrary = QuickCheck.elements [DumpServerConfigJson_args]
-- | Translate a 'DumpServerConfigJson_args' to a 'Types.ThriftVal'
from_DumpServerConfigJson_args :: DumpServerConfigJson_args -> Types.ThriftVal
from_DumpServerConfigJson_args record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  []
-- | Write a 'DumpServerConfigJson_args' with the given 'Thrift.Protocol'
write_DumpServerConfigJson_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DumpServerConfigJson_args -> IO ()
write_DumpServerConfigJson_args oprot record = Thrift.writeVal oprot $ from_DumpServerConfigJson_args record
-- | Serialize a 'DumpServerConfigJson_args' in pure code
encode_DumpServerConfigJson_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DumpServerConfigJson_args -> BS.ByteString
encode_DumpServerConfigJson_args oprot record = Thrift.serializeVal oprot $ from_DumpServerConfigJson_args record
-- | Translate a 'Types.ThriftVal' to a 'DumpServerConfigJson_args'
to_DumpServerConfigJson_args :: Types.ThriftVal -> DumpServerConfigJson_args
to_DumpServerConfigJson_args (Types.TStruct fields) = DumpServerConfigJson_args{

  }
to_DumpServerConfigJson_args _ = error "not a struct"
-- | Read a 'DumpServerConfigJson_args' struct with the given 'Thrift.Protocol'
read_DumpServerConfigJson_args :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO DumpServerConfigJson_args
read_DumpServerConfigJson_args iprot = to_DumpServerConfigJson_args <$> Thrift.readVal iprot (Types.T_STRUCT typemap_DumpServerConfigJson_args)
-- | Deserialize a 'DumpServerConfigJson_args' in pure code
decode_DumpServerConfigJson_args :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> DumpServerConfigJson_args
decode_DumpServerConfigJson_args iprot bs = to_DumpServerConfigJson_args $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_DumpServerConfigJson_args) bs
-- | 'TypeMap' for the 'DumpServerConfigJson_args' struct
typemap_DumpServerConfigJson_args :: Types.TypeMap
typemap_DumpServerConfigJson_args = Map.fromList []
-- | Default values for the 'DumpServerConfigJson_args' struct
default_DumpServerConfigJson_args :: DumpServerConfigJson_args
default_DumpServerConfigJson_args = DumpServerConfigJson_args{
}
-- | Definition of the DumpServerConfigJson_result struct
data DumpServerConfigJson_result = DumpServerConfigJson_result
  { dumpServerConfigJson_result_success :: LT.Text
    -- ^ success field of the DumpServerConfigJson_result struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable DumpServerConfigJson_result where
  encode = encode_DumpServerConfigJson_result
  decode = decode_DumpServerConfigJson_result
instance Hashable.Hashable DumpServerConfigJson_result where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` dumpServerConfigJson_result_success record  
instance DeepSeq.NFData DumpServerConfigJson_result where
  rnf _record392 =
    DeepSeq.rnf (dumpServerConfigJson_result_success _record392) `seq`
    ()
instance Arbitrary.Arbitrary DumpServerConfigJson_result where 
  arbitrary = Monad.liftM DumpServerConfigJson_result (Arbitrary.arbitrary)
  shrink obj | obj == default_DumpServerConfigJson_result = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_DumpServerConfigJson_result{dumpServerConfigJson_result_success = dumpServerConfigJson_result_success obj} then Nothing else Just $ default_DumpServerConfigJson_result{dumpServerConfigJson_result_success = dumpServerConfigJson_result_success obj}
    ]
-- | Translate a 'DumpServerConfigJson_result' to a 'Types.ThriftVal'
from_DumpServerConfigJson_result :: DumpServerConfigJson_result -> Types.ThriftVal
from_DumpServerConfigJson_result record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v395 -> Just (0, ("success",Types.TString $ Encoding.encodeUtf8 _v395))) $ dumpServerConfigJson_result_success record
  ]
-- | Write a 'DumpServerConfigJson_result' with the given 'Thrift.Protocol'
write_DumpServerConfigJson_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DumpServerConfigJson_result -> IO ()
write_DumpServerConfigJson_result oprot record = Thrift.writeVal oprot $ from_DumpServerConfigJson_result record
-- | Serialize a 'DumpServerConfigJson_result' in pure code
encode_DumpServerConfigJson_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> DumpServerConfigJson_result -> BS.ByteString
encode_DumpServerConfigJson_result oprot record = Thrift.serializeVal oprot $ from_DumpServerConfigJson_result record
-- | Translate a 'Types.ThriftVal' to a 'DumpServerConfigJson_result'
to_DumpServerConfigJson_result :: Types.ThriftVal -> DumpServerConfigJson_result
to_DumpServerConfigJson_result (Types.TStruct fields) = DumpServerConfigJson_result{
  dumpServerConfigJson_result_success = maybe (dumpServerConfigJson_result_success default_DumpServerConfigJson_result) (\(_,_val397) -> (case _val397 of {Types.TString _val398 -> Encoding.decodeUtf8 _val398; _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_DumpServerConfigJson_result _ = error "not a struct"
-- | Read a 'DumpServerConfigJson_result' struct with the given 'Thrift.Protocol'
read_DumpServerConfigJson_result :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO DumpServerConfigJson_result
read_DumpServerConfigJson_result iprot = to_DumpServerConfigJson_result <$> Thrift.readVal iprot (Types.T_STRUCT typemap_DumpServerConfigJson_result)
-- | Deserialize a 'DumpServerConfigJson_result' in pure code
decode_DumpServerConfigJson_result :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> DumpServerConfigJson_result
decode_DumpServerConfigJson_result iprot bs = to_DumpServerConfigJson_result $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_DumpServerConfigJson_result) bs
-- | 'TypeMap' for the 'DumpServerConfigJson_result' struct
typemap_DumpServerConfigJson_result :: Types.TypeMap
typemap_DumpServerConfigJson_result = Map.fromList [("success",(0,Types.T_STRING))]
-- | Default values for the 'DumpServerConfigJson_result' struct
default_DumpServerConfigJson_result :: DumpServerConfigJson_result
default_DumpServerConfigJson_result = DumpServerConfigJson_result{
  dumpServerConfigJson_result_success = ""}
process_getNodesConfig (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetNodesConfig_args iprot
  (Exception.catch
    (Exception.catch
      (do
        val <- Iface.getNodesConfig handler (getNodesConfig_args_filter args)
        let res = default_GetNodesConfig_result{getNodesConfig_result_success = val}
        Thrift.writeMessage oprot ("getNodesConfig", Types.M_REPLY, seqid) $
          write_GetNodesConfig_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot))
      (\e  -> do
        let res = default_GetNodesConfig_result{getNodesConfig_result_notready = Just e}
        Thrift.writeMessage oprot ("getNodesConfig", Types.M_REPLY, seqid) $
          write_GetNodesConfig_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("getNodesConfig", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getNodesState (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetNodesState_args iprot
  (Exception.catch
    (Exception.catch
      (do
        val <- Iface.getNodesState handler (getNodesState_args_request args)
        let res = default_GetNodesState_result{getNodesState_result_success = val}
        Thrift.writeMessage oprot ("getNodesState", Types.M_REPLY, seqid) $
          write_GetNodesState_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot))
      (\e  -> do
        let res = default_GetNodesState_result{getNodesState_result_notready = Just e}
        Thrift.writeMessage oprot ("getNodesState", Types.M_REPLY, seqid) $
          write_GetNodesState_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("getNodesState", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_addNodes (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_AddNodes_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.addNodes handler (addNodes_args_request args)
              let res = default_AddNodes_result{addNodes_result_success = val}
              Thrift.writeMessage oprot ("addNodes", Types.M_REPLY, seqid) $
                write_AddNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_AddNodes_result{addNodes_result_notready = Just e}
              Thrift.writeMessage oprot ("addNodes", Types.M_REPLY, seqid) $
                write_AddNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_AddNodes_result{addNodes_result_failed_op = Just e}
            Thrift.writeMessage oprot ("addNodes", Types.M_REPLY, seqid) $
              write_AddNodes_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_AddNodes_result{addNodes_result_ncm_error = Just e}
          Thrift.writeMessage oprot ("addNodes", Types.M_REPLY, seqid) $
            write_AddNodes_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_AddNodes_result{addNodes_result_not_supported = Just e}
        Thrift.writeMessage oprot ("addNodes", Types.M_REPLY, seqid) $
          write_AddNodes_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("addNodes", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_updateNodes (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_UpdateNodes_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.updateNodes handler (updateNodes_args_request args)
              let res = default_UpdateNodes_result{updateNodes_result_success = val}
              Thrift.writeMessage oprot ("updateNodes", Types.M_REPLY, seqid) $
                write_UpdateNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_UpdateNodes_result{updateNodes_result_notready = Just e}
              Thrift.writeMessage oprot ("updateNodes", Types.M_REPLY, seqid) $
                write_UpdateNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_UpdateNodes_result{updateNodes_result_failed_op = Just e}
            Thrift.writeMessage oprot ("updateNodes", Types.M_REPLY, seqid) $
              write_UpdateNodes_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_UpdateNodes_result{updateNodes_result_ncm_error = Just e}
          Thrift.writeMessage oprot ("updateNodes", Types.M_REPLY, seqid) $
            write_UpdateNodes_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_UpdateNodes_result{updateNodes_result_not_supported = Just e}
        Thrift.writeMessage oprot ("updateNodes", Types.M_REPLY, seqid) $
          write_UpdateNodes_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("updateNodes", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_removeNodes (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_RemoveNodes_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.removeNodes handler (removeNodes_args_request args)
              let res = default_RemoveNodes_result{removeNodes_result_success = val}
              Thrift.writeMessage oprot ("removeNodes", Types.M_REPLY, seqid) $
                write_RemoveNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_RemoveNodes_result{removeNodes_result_notready = Just e}
              Thrift.writeMessage oprot ("removeNodes", Types.M_REPLY, seqid) $
                write_RemoveNodes_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_RemoveNodes_result{removeNodes_result_failed_op = Just e}
            Thrift.writeMessage oprot ("removeNodes", Types.M_REPLY, seqid) $
              write_RemoveNodes_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_RemoveNodes_result{removeNodes_result_ncm_error = Just e}
          Thrift.writeMessage oprot ("removeNodes", Types.M_REPLY, seqid) $
            write_RemoveNodes_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_RemoveNodes_result{removeNodes_result_not_supported = Just e}
        Thrift.writeMessage oprot ("removeNodes", Types.M_REPLY, seqid) $
          write_RemoveNodes_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("removeNodes", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_markShardsAsProvisioned (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_MarkShardsAsProvisioned_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.markShardsAsProvisioned handler (markShardsAsProvisioned_args_request args)
              let res = default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_success = val}
              Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_REPLY, seqid) $
                write_MarkShardsAsProvisioned_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_notready = Just e}
              Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_REPLY, seqid) $
                write_MarkShardsAsProvisioned_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_invalid_request = Just e}
            Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_REPLY, seqid) $
              write_MarkShardsAsProvisioned_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_ncm_error = Just e}
          Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_REPLY, seqid) $
            write_MarkShardsAsProvisioned_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_MarkShardsAsProvisioned_result{markShardsAsProvisioned_result_not_supported = Just e}
        Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_REPLY, seqid) $
          write_MarkShardsAsProvisioned_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("markShardsAsProvisioned", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_bumpNodeGeneration (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_BumpNodeGeneration_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.bumpNodeGeneration handler (bumpNodeGeneration_args_request args)
              let res = default_BumpNodeGeneration_result{bumpNodeGeneration_result_success = val}
              Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_REPLY, seqid) $
                write_BumpNodeGeneration_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_BumpNodeGeneration_result{bumpNodeGeneration_result_notready = Just e}
              Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_REPLY, seqid) $
                write_BumpNodeGeneration_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_BumpNodeGeneration_result{bumpNodeGeneration_result_invalid_request = Just e}
            Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_REPLY, seqid) $
              write_BumpNodeGeneration_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_BumpNodeGeneration_result{bumpNodeGeneration_result_ncm_error = Just e}
          Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_REPLY, seqid) $
            write_BumpNodeGeneration_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_BumpNodeGeneration_result{bumpNodeGeneration_result_not_supported = Just e}
        Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_REPLY, seqid) $
          write_BumpNodeGeneration_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("bumpNodeGeneration", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_bootstrapCluster (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_BootstrapCluster_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (do
          val <- Iface.bootstrapCluster handler (bootstrapCluster_args_request args)
          let res = default_BootstrapCluster_result{bootstrapCluster_result_success = val}
          Thrift.writeMessage oprot ("bootstrapCluster", Types.M_REPLY, seqid) $
            write_BootstrapCluster_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot))
        (\e  -> do
          let res = default_BootstrapCluster_result{bootstrapCluster_result_error = Just e}
          Thrift.writeMessage oprot ("bootstrapCluster", Types.M_REPLY, seqid) $
            write_BootstrapCluster_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_BootstrapCluster_result{bootstrapCluster_result_ncm_error = Just e}
        Thrift.writeMessage oprot ("bootstrapCluster", Types.M_REPLY, seqid) $
          write_BootstrapCluster_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("bootstrapCluster", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getMaintenances (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetMaintenances_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.getMaintenances handler (getMaintenances_args_filter args)
              let res = default_GetMaintenances_result{getMaintenances_result_success = val}
              Thrift.writeMessage oprot ("getMaintenances", Types.M_REPLY, seqid) $
                write_GetMaintenances_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_GetMaintenances_result{getMaintenances_result_notready = Just e}
              Thrift.writeMessage oprot ("getMaintenances", Types.M_REPLY, seqid) $
                write_GetMaintenances_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_GetMaintenances_result{getMaintenances_result_invalid_request = Just e}
            Thrift.writeMessage oprot ("getMaintenances", Types.M_REPLY, seqid) $
              write_GetMaintenances_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_GetMaintenances_result{getMaintenances_result_error = Just e}
          Thrift.writeMessage oprot ("getMaintenances", Types.M_REPLY, seqid) $
            write_GetMaintenances_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_GetMaintenances_result{getMaintenances_result_not_supported = Just e}
        Thrift.writeMessage oprot ("getMaintenances", Types.M_REPLY, seqid) $
          write_GetMaintenances_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("getMaintenances", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_applyMaintenance (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_ApplyMaintenance_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (Exception.catch
              (do
                val <- Iface.applyMaintenance handler (applyMaintenance_args_request args)
                let res = default_ApplyMaintenance_result{applyMaintenance_result_success = val}
                Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
                  write_ApplyMaintenance_result oprot res
                Thrift.tFlush (Thrift.getTransport oprot))
              (\e  -> do
                let res = default_ApplyMaintenance_result{applyMaintenance_result_notready = Just e}
                Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
                  write_ApplyMaintenance_result oprot res
                Thrift.tFlush (Thrift.getTransport oprot)))
            (\e  -> do
              let res = default_ApplyMaintenance_result{applyMaintenance_result_invalid_request = Just e}
              Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
                write_ApplyMaintenance_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_ApplyMaintenance_result{applyMaintenance_result_clash = Just e}
            Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
              write_ApplyMaintenance_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_ApplyMaintenance_result{applyMaintenance_result_operation_error = Just e}
          Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
            write_ApplyMaintenance_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_ApplyMaintenance_result{applyMaintenance_result_not_supported = Just e}
        Thrift.writeMessage oprot ("applyMaintenance", Types.M_REPLY, seqid) $
          write_ApplyMaintenance_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("applyMaintenance", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_removeMaintenances (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_RemoveMaintenances_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (Exception.catch
              (do
                val <- Iface.removeMaintenances handler (removeMaintenances_args_filter args)
                let res = default_RemoveMaintenances_result{removeMaintenances_result_success = val}
                Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
                  write_RemoveMaintenances_result oprot res
                Thrift.tFlush (Thrift.getTransport oprot))
              (\e  -> do
                let res = default_RemoveMaintenances_result{removeMaintenances_result_notready = Just e}
                Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
                  write_RemoveMaintenances_result oprot res
                Thrift.tFlush (Thrift.getTransport oprot)))
            (\e  -> do
              let res = default_RemoveMaintenances_result{removeMaintenances_result_invalid_request = Just e}
              Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
                write_RemoveMaintenances_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_RemoveMaintenances_result{removeMaintenances_result_operation_error = Just e}
            Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
              write_RemoveMaintenances_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_RemoveMaintenances_result{removeMaintenances_result_not_supported = Just e}
          Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
            write_RemoveMaintenances_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_RemoveMaintenances_result{removeMaintenances_result_not_found = Just e}
        Thrift.writeMessage oprot ("removeMaintenances", Types.M_REPLY, seqid) $
          write_RemoveMaintenances_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("removeMaintenances", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_markAllShardsUnrecoverable (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_MarkAllShardsUnrecoverable_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.markAllShardsUnrecoverable handler (markAllShardsUnrecoverable_args_request args)
              let res = default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_success = val}
              Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_REPLY, seqid) $
                write_MarkAllShardsUnrecoverable_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_notready = Just e}
              Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_REPLY, seqid) $
                write_MarkAllShardsUnrecoverable_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_invalid_request = Just e}
            Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_REPLY, seqid) $
              write_MarkAllShardsUnrecoverable_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_operation_error = Just e}
          Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_REPLY, seqid) $
            write_MarkAllShardsUnrecoverable_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_MarkAllShardsUnrecoverable_result{markAllShardsUnrecoverable_result_not_supported = Just e}
        Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_REPLY, seqid) $
          write_MarkAllShardsUnrecoverable_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("markAllShardsUnrecoverable", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_checkImpact (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_CheckImpact_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (Exception.catch
            (do
              val <- Iface.checkImpact handler (checkImpact_args_request args)
              let res = default_CheckImpact_result{checkImpact_result_success = val}
              Thrift.writeMessage oprot ("checkImpact", Types.M_REPLY, seqid) $
                write_CheckImpact_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot))
            (\e  -> do
              let res = default_CheckImpact_result{checkImpact_result_notready = Just e}
              Thrift.writeMessage oprot ("checkImpact", Types.M_REPLY, seqid) $
                write_CheckImpact_result oprot res
              Thrift.tFlush (Thrift.getTransport oprot)))
          (\e  -> do
            let res = default_CheckImpact_result{checkImpact_result_error = Just e}
            Thrift.writeMessage oprot ("checkImpact", Types.M_REPLY, seqid) $
              write_CheckImpact_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_CheckImpact_result{checkImpact_result_invalid_request = Just e}
          Thrift.writeMessage oprot ("checkImpact", Types.M_REPLY, seqid) $
            write_CheckImpact_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_CheckImpact_result{checkImpact_result_notsupported = Just e}
        Thrift.writeMessage oprot ("checkImpact", Types.M_REPLY, seqid) $
          write_CheckImpact_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("checkImpact", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getLogTreeInfo (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetLogTreeInfo_args iprot
  (Exception.catch
    (do
      val <- Iface.getLogTreeInfo handler
      let res = default_GetLogTreeInfo_result{getLogTreeInfo_result_success = val}
      Thrift.writeMessage oprot ("getLogTreeInfo", Types.M_REPLY, seqid) $
        write_GetLogTreeInfo_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("getLogTreeInfo", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getReplicationInfo (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetReplicationInfo_args iprot
  (Exception.catch
    (do
      val <- Iface.getReplicationInfo handler
      let res = default_GetReplicationInfo_result{getReplicationInfo_result_success = val}
      Thrift.writeMessage oprot ("getReplicationInfo", Types.M_REPLY, seqid) $
        write_GetReplicationInfo_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("getReplicationInfo", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getSettings (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetSettings_args iprot
  (Exception.catch
    (do
      val <- Iface.getSettings handler (getSettings_args_request args)
      let res = default_GetSettings_result{getSettings_result_success = val}
      Thrift.writeMessage oprot ("getSettings", Types.M_REPLY, seqid) $
        write_GetSettings_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("getSettings", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_applySettingOverride (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_ApplySettingOverride_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (do
          Iface.applySettingOverride handler (applySettingOverride_args_request args)
          let res = default_ApplySettingOverride_result
          Thrift.writeMessage oprot ("applySettingOverride", Types.M_REPLY, seqid) $
            write_ApplySettingOverride_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot))
        (\e  -> do
          let res = default_ApplySettingOverride_result{applySettingOverride_result_invalid_request = Just e}
          Thrift.writeMessage oprot ("applySettingOverride", Types.M_REPLY, seqid) $
            write_ApplySettingOverride_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_ApplySettingOverride_result{applySettingOverride_result_operation_error = Just e}
        Thrift.writeMessage oprot ("applySettingOverride", Types.M_REPLY, seqid) $
          write_ApplySettingOverride_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("applySettingOverride", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_removeSettingOverride (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_RemoveSettingOverride_args iprot
  (Exception.catch
    (do
      Iface.removeSettingOverride handler (removeSettingOverride_args_request args)
      let res = default_RemoveSettingOverride_result
      Thrift.writeMessage oprot ("removeSettingOverride", Types.M_REPLY, seqid) $
        write_RemoveSettingOverride_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("removeSettingOverride", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_takeLogTreeSnapshot (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_TakeLogTreeSnapshot_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (do
            Iface.takeLogTreeSnapshot handler (takeLogTreeSnapshot_args_min_version args)
            let res = default_TakeLogTreeSnapshot_result
            Thrift.writeMessage oprot ("takeLogTreeSnapshot", Types.M_REPLY, seqid) $
              write_TakeLogTreeSnapshot_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot))
          (\e  -> do
            let res = default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_stale = Just e}
            Thrift.writeMessage oprot ("takeLogTreeSnapshot", Types.M_REPLY, seqid) $
              write_TakeLogTreeSnapshot_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notready = Just e}
          Thrift.writeMessage oprot ("takeLogTreeSnapshot", Types.M_REPLY, seqid) $
            write_TakeLogTreeSnapshot_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_TakeLogTreeSnapshot_result{takeLogTreeSnapshot_result_notsupported = Just e}
        Thrift.writeMessage oprot ("takeLogTreeSnapshot", Types.M_REPLY, seqid) $
          write_TakeLogTreeSnapshot_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("takeLogTreeSnapshot", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_takeMaintenanceLogSnapshot (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_TakeMaintenanceLogSnapshot_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (Exception.catch
          (do
            Iface.takeMaintenanceLogSnapshot handler (takeMaintenanceLogSnapshot_args_min_version args)
            let res = default_TakeMaintenanceLogSnapshot_result
            Thrift.writeMessage oprot ("takeMaintenanceLogSnapshot", Types.M_REPLY, seqid) $
              write_TakeMaintenanceLogSnapshot_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot))
          (\e  -> do
            let res = default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_stale = Just e}
            Thrift.writeMessage oprot ("takeMaintenanceLogSnapshot", Types.M_REPLY, seqid) $
              write_TakeMaintenanceLogSnapshot_result oprot res
            Thrift.tFlush (Thrift.getTransport oprot)))
        (\e  -> do
          let res = default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notready = Just e}
          Thrift.writeMessage oprot ("takeMaintenanceLogSnapshot", Types.M_REPLY, seqid) $
            write_TakeMaintenanceLogSnapshot_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_TakeMaintenanceLogSnapshot_result{takeMaintenanceLogSnapshot_result_notsupported = Just e}
        Thrift.writeMessage oprot ("takeMaintenanceLogSnapshot", Types.M_REPLY, seqid) $
          write_TakeMaintenanceLogSnapshot_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("takeMaintenanceLogSnapshot", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getLogGroupThroughput (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetLogGroupThroughput_args iprot
  (Exception.catch
    (do
      val <- Iface.getLogGroupThroughput handler (getLogGroupThroughput_args_request args)
      let res = default_GetLogGroupThroughput_result{getLogGroupThroughput_result_success = val}
      Thrift.writeMessage oprot ("getLogGroupThroughput", Types.M_REPLY, seqid) $
        write_GetLogGroupThroughput_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("getLogGroupThroughput", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getLogGroupCustomCounters (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetLogGroupCustomCounters_args iprot
  (Exception.catch
    (Exception.catch
      (Exception.catch
        (do
          val <- Iface.getLogGroupCustomCounters handler (getLogGroupCustomCounters_args_request args)
          let res = default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_success = val}
          Thrift.writeMessage oprot ("getLogGroupCustomCounters", Types.M_REPLY, seqid) $
            write_GetLogGroupCustomCounters_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot))
        (\e  -> do
          let res = default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_notsupported = Just e}
          Thrift.writeMessage oprot ("getLogGroupCustomCounters", Types.M_REPLY, seqid) $
            write_GetLogGroupCustomCounters_result oprot res
          Thrift.tFlush (Thrift.getTransport oprot)))
      (\e  -> do
        let res = default_GetLogGroupCustomCounters_result{getLogGroupCustomCounters_result_invalid_request = Just e}
        Thrift.writeMessage oprot ("getLogGroupCustomCounters", Types.M_REPLY, seqid) $
          write_GetLogGroupCustomCounters_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("getLogGroupCustomCounters", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_executeAdminCommand (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_ExecuteAdminCommand_args iprot
  (Exception.catch
    (Exception.catch
      (do
        val <- Iface.executeAdminCommand handler (executeAdminCommand_args_request args)
        let res = default_ExecuteAdminCommand_result{executeAdminCommand_result_success = val}
        Thrift.writeMessage oprot ("executeAdminCommand", Types.M_REPLY, seqid) $
          write_ExecuteAdminCommand_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot))
      (\e  -> do
        let res = default_ExecuteAdminCommand_result{executeAdminCommand_result_notsupported = Just e}
        Thrift.writeMessage oprot ("executeAdminCommand", Types.M_REPLY, seqid) $
          write_ExecuteAdminCommand_result oprot res
        Thrift.tFlush (Thrift.getTransport oprot)))
    ((\_ -> do
      Thrift.writeMessage oprot ("executeAdminCommand", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_getClusterName (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_GetClusterName_args iprot
  (Exception.catch
    (do
      val <- Iface.getClusterName handler
      let res = default_GetClusterName_result{getClusterName_result_success = val}
      Thrift.writeMessage oprot ("getClusterName", Types.M_REPLY, seqid) $
        write_GetClusterName_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("getClusterName", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
process_dumpServerConfigJson (seqid, iprot, oprot, handler) = do
  args <- AdminAPI.read_DumpServerConfigJson_args iprot
  (Exception.catch
    (do
      val <- Iface.dumpServerConfigJson handler
      let res = default_DumpServerConfigJson_result{dumpServerConfigJson_result_success = val}
      Thrift.writeMessage oprot ("dumpServerConfigJson", Types.M_REPLY, seqid) $
        write_DumpServerConfigJson_result oprot res
      Thrift.tFlush (Thrift.getTransport oprot))
    ((\_ -> do
      Thrift.writeMessage oprot ("dumpServerConfigJson", Types.M_EXCEPTION, seqid) $
        Thrift.writeAppExn oprot (Thrift.AppExn Thrift.AE_UNKNOWN "")
      Thrift.tFlush (Thrift.getTransport oprot)) :: Exception.SomeException -> IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getNodesConfig" -> process_getNodesConfig (seqid,iprot,oprot,handler)
  "getNodesState" -> process_getNodesState (seqid,iprot,oprot,handler)
  "addNodes" -> process_addNodes (seqid,iprot,oprot,handler)
  "updateNodes" -> process_updateNodes (seqid,iprot,oprot,handler)
  "removeNodes" -> process_removeNodes (seqid,iprot,oprot,handler)
  "markShardsAsProvisioned" -> process_markShardsAsProvisioned (seqid,iprot,oprot,handler)
  "bumpNodeGeneration" -> process_bumpNodeGeneration (seqid,iprot,oprot,handler)
  "bootstrapCluster" -> process_bootstrapCluster (seqid,iprot,oprot,handler)
  "getMaintenances" -> process_getMaintenances (seqid,iprot,oprot,handler)
  "applyMaintenance" -> process_applyMaintenance (seqid,iprot,oprot,handler)
  "removeMaintenances" -> process_removeMaintenances (seqid,iprot,oprot,handler)
  "markAllShardsUnrecoverable" -> process_markAllShardsUnrecoverable (seqid,iprot,oprot,handler)
  "checkImpact" -> process_checkImpact (seqid,iprot,oprot,handler)
  "getLogTreeInfo" -> process_getLogTreeInfo (seqid,iprot,oprot,handler)
  "getReplicationInfo" -> process_getReplicationInfo (seqid,iprot,oprot,handler)
  "getSettings" -> process_getSettings (seqid,iprot,oprot,handler)
  "applySettingOverride" -> process_applySettingOverride (seqid,iprot,oprot,handler)
  "removeSettingOverride" -> process_removeSettingOverride (seqid,iprot,oprot,handler)
  "takeLogTreeSnapshot" -> process_takeLogTreeSnapshot (seqid,iprot,oprot,handler)
  "takeMaintenanceLogSnapshot" -> process_takeMaintenanceLogSnapshot (seqid,iprot,oprot,handler)
  "getLogGroupThroughput" -> process_getLogGroupThroughput (seqid,iprot,oprot,handler)
  "getLogGroupCustomCounters" -> process_getLogGroupCustomCounters (seqid,iprot,oprot,handler)
  "executeAdminCommand" -> process_executeAdminCommand (seqid,iprot,oprot,handler)
  "getClusterName" -> process_getClusterName (seqid,iprot,oprot,handler)
  "dumpServerConfigJson" -> process_dumpServerConfigJson (seqid,iprot,oprot,handler)
  _ -> Facebook.FB303.FacebookService.proc_ handler (iprot,oprot) (name,typ,seqid)
process handler (iprot, oprot) =
  Thrift.readMessage iprot (proc_ handler (iprot,oprot)) >> return True

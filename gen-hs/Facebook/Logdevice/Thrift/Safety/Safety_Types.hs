{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Facebook.Logdevice.Thrift.Safety.Safety_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Facebook.Logdevice.Thrift.Common.Common_Types as Common_Types
import qualified Facebook.Logdevice.Thrift.Nodes.Nodes_Types as Nodes_Types


data OperationImpact = INVALID|REBUILDING_STALL|WRITE_AVAILABILITY_LOSS|READ_AVAILABILITY_LOSS|SEQUENCING_CAPACITY_LOSS|STORAGE_CAPACITY_LOSS  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum OperationImpact where
  fromEnum t = case t of
    INVALID -> 0
    REBUILDING_STALL -> 1
    WRITE_AVAILABILITY_LOSS -> 2
    READ_AVAILABILITY_LOSS -> 3
    SEQUENCING_CAPACITY_LOSS -> 4
    STORAGE_CAPACITY_LOSS -> 5
  toEnum t = case t of
    0 -> INVALID
    1 -> REBUILDING_STALL
    2 -> WRITE_AVAILABILITY_LOSS
    3 -> READ_AVAILABILITY_LOSS
    4 -> SEQUENCING_CAPACITY_LOSS
    5 -> STORAGE_CAPACITY_LOSS
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    INVALID -> REBUILDING_STALL
    REBUILDING_STALL -> WRITE_AVAILABILITY_LOSS
    WRITE_AVAILABILITY_LOSS -> READ_AVAILABILITY_LOSS
    READ_AVAILABILITY_LOSS -> SEQUENCING_CAPACITY_LOSS
    SEQUENCING_CAPACITY_LOSS -> STORAGE_CAPACITY_LOSS
    STORAGE_CAPACITY_LOSS -> Exception.throw Thrift.ThriftException
  pred t = case t of
    INVALID -> Exception.throw Thrift.ThriftException
    REBUILDING_STALL -> INVALID
    WRITE_AVAILABILITY_LOSS -> REBUILDING_STALL
    READ_AVAILABILITY_LOSS -> WRITE_AVAILABILITY_LOSS
    SEQUENCING_CAPACITY_LOSS -> READ_AVAILABILITY_LOSS
    STORAGE_CAPACITY_LOSS -> SEQUENCING_CAPACITY_LOSS
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable OperationImpact where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData OperationImpact where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary OperationImpact where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
type StorageSetMetadata = Vector.Vector Safety_Types.ShardMetadata

-- | Definition of the ShardMetadata struct
data ShardMetadata = ShardMetadata
  { shardMetadata_data_health :: Nodes_Types.ShardDataHealth
    -- ^ data_health field of the ShardMetadata struct
  , shardMetadata_is_alive :: Bool
    -- ^ is_alive field of the ShardMetadata struct
  , shardMetadata_storage_state :: Nodes_Types.ShardStorageState
    -- ^ storage_state field of the ShardMetadata struct
  , shardMetadata_location :: Maybe LT.Text
    -- ^ location field of the ShardMetadata struct
  , shardMetadata_location_per_scope :: (Map.HashMap Common_Types.LocationScope LT.Text)
    -- ^ location_per_scope field of the ShardMetadata struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ShardMetadata where
  encode = encode_ShardMetadata
  decode = decode_ShardMetadata
instance Hashable.Hashable ShardMetadata where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` shardMetadata_data_health record   `Hashable.hashWithSalt` shardMetadata_is_alive record   `Hashable.hashWithSalt` shardMetadata_storage_state record   `Hashable.hashWithSalt` shardMetadata_location record   `Hashable.hashWithSalt` shardMetadata_location_per_scope record  
instance DeepSeq.NFData ShardMetadata where
  rnf _record0 =
    DeepSeq.rnf (shardMetadata_data_health _record0) `seq`
    DeepSeq.rnf (shardMetadata_is_alive _record0) `seq`
    DeepSeq.rnf (shardMetadata_storage_state _record0) `seq`
    DeepSeq.rnf (shardMetadata_location _record0) `seq`
    DeepSeq.rnf (shardMetadata_location_per_scope _record0) `seq`
    ()
instance Arbitrary.Arbitrary ShardMetadata where 
  arbitrary = Monad.liftM ShardMetadata (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ShardMetadata = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ShardMetadata{shardMetadata_data_health = shardMetadata_data_health obj} then Nothing else Just $ default_ShardMetadata{shardMetadata_data_health = shardMetadata_data_health obj}
    , if obj == default_ShardMetadata{shardMetadata_is_alive = shardMetadata_is_alive obj} then Nothing else Just $ default_ShardMetadata{shardMetadata_is_alive = shardMetadata_is_alive obj}
    , if obj == default_ShardMetadata{shardMetadata_storage_state = shardMetadata_storage_state obj} then Nothing else Just $ default_ShardMetadata{shardMetadata_storage_state = shardMetadata_storage_state obj}
    , if obj == default_ShardMetadata{shardMetadata_location = shardMetadata_location obj} then Nothing else Just $ default_ShardMetadata{shardMetadata_location = shardMetadata_location obj}
    , if obj == default_ShardMetadata{shardMetadata_location_per_scope = shardMetadata_location_per_scope obj} then Nothing else Just $ default_ShardMetadata{shardMetadata_location_per_scope = shardMetadata_location_per_scope obj}
    ]
-- | Translate a 'ShardMetadata' to a 'Types.ThriftVal'
from_ShardMetadata :: ShardMetadata -> Types.ThriftVal
from_ShardMetadata record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("data_health",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ shardMetadata_data_health record
  , (\_v3 -> Just (2, ("is_alive",Types.TBool _v3))) $ shardMetadata_is_alive record
  , (\_v3 -> Just (3, ("storage_state",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ shardMetadata_storage_state record
  , (\_v3 -> (4, ("location",Types.TString $ Encoding.encodeUtf8 _v3))) <$> shardMetadata_location record
  , (\_v3 -> Just (5, ("location_per_scope",Types.TMap Types.T_I32 Types.T_STRING $ map (\(_k4,_v5) -> (Types.TI32 $ fromIntegral $ fromEnum _k4, Types.TString $ Encoding.encodeUtf8 _v5)) $ Map.toList _v3))) $ shardMetadata_location_per_scope record
  ]
-- | Write a 'ShardMetadata' with the given 'Thrift.Protocol'
write_ShardMetadata :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardMetadata -> IO ()
write_ShardMetadata oprot record = Thrift.writeVal oprot $ from_ShardMetadata record
-- | Serialize a 'ShardMetadata' in pure code
encode_ShardMetadata :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ShardMetadata -> BS.ByteString
encode_ShardMetadata oprot record = Thrift.serializeVal oprot $ from_ShardMetadata record
-- | Translate a 'Types.ThriftVal' to a 'ShardMetadata'
to_ShardMetadata :: Types.ThriftVal -> ShardMetadata
to_ShardMetadata (Types.TStruct fields) = ShardMetadata{
  shardMetadata_data_health = maybe (shardMetadata_data_health default_ShardMetadata) (\(_,_val7) -> (case _val7 of {Types.TI32 _val8 -> toEnum $ fromIntegral _val8; _ -> error "wrong type"})) (Map.lookup (1) fields),
  shardMetadata_is_alive = maybe (shardMetadata_is_alive default_ShardMetadata) (\(_,_val7) -> (case _val7 of {Types.TBool _val9 -> _val9; _ -> error "wrong type"})) (Map.lookup (2) fields),
  shardMetadata_storage_state = maybe (shardMetadata_storage_state default_ShardMetadata) (\(_,_val7) -> (case _val7 of {Types.TI32 _val10 -> toEnum $ fromIntegral _val10; _ -> error "wrong type"})) (Map.lookup (3) fields),
  shardMetadata_location = maybe (Nothing) (\(_,_val7) -> Just (case _val7 of {Types.TString _val11 -> Encoding.decodeUtf8 _val11; _ -> error "wrong type"})) (Map.lookup (4) fields),
  shardMetadata_location_per_scope = maybe (shardMetadata_location_per_scope default_ShardMetadata) (\(_,_val7) -> (case _val7 of {Types.TMap _ _ _val12 -> (Map.fromList $ map (\(_k14,_v13) -> ((case _k14 of {Types.TI32 _val15 -> toEnum $ fromIntegral _val15; _ -> error "wrong type"}),(case _v13 of {Types.TString _val16 -> Encoding.decodeUtf8 _val16; _ -> error "wrong type"}))) _val12); _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_ShardMetadata _ = error "not a struct"
-- | Read a 'ShardMetadata' struct with the given 'Thrift.Protocol'
read_ShardMetadata :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ShardMetadata
read_ShardMetadata iprot = to_ShardMetadata <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ShardMetadata)
-- | Deserialize a 'ShardMetadata' in pure code
decode_ShardMetadata :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ShardMetadata
decode_ShardMetadata iprot bs = to_ShardMetadata $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ShardMetadata) bs
-- | 'TypeMap' for the 'ShardMetadata' struct
typemap_ShardMetadata :: Types.TypeMap
typemap_ShardMetadata = Map.fromList [("data_health",(1,Types.T_I32)),("is_alive",(2,Types.T_BOOL)),("storage_state",(3,Types.T_I32)),("location",(4,Types.T_STRING)),("location_per_scope",(5,(Types.T_MAP Types.T_I32 Types.T_STRING)))]
-- | Default values for the 'ShardMetadata' struct
default_ShardMetadata :: ShardMetadata
default_ShardMetadata = ShardMetadata{
  shardMetadata_data_health = (toEnum 0),
  shardMetadata_is_alive = False,
  shardMetadata_storage_state = (toEnum 0),
  shardMetadata_location = Nothing,
  shardMetadata_location_per_scope = Map.empty}
-- | Definition of the ImpactOnEpoch struct
data ImpactOnEpoch = ImpactOnEpoch
  { impactOnEpoch_log_id :: Int.Int64
    -- ^ log_id field of the ImpactOnEpoch struct
  , impactOnEpoch_epoch :: Int.Int64
    -- ^ epoch field of the ImpactOnEpoch struct
  , impactOnEpoch_storage_set :: (Vector.Vector Common_Types.ShardID)
    -- ^ storage_set field of the ImpactOnEpoch struct
  , impactOnEpoch_replication :: (Map.HashMap Common_Types.LocationScope Int.Int32)
    -- ^ replication field of the ImpactOnEpoch struct
  , impactOnEpoch_impact :: (Vector.Vector Safety_Types.OperationImpact)
    -- ^ impact field of the ImpactOnEpoch struct
  , impactOnEpoch_storage_set_metadata :: Maybe (Vector.Vector Safety_Types.ShardMetadata)
    -- ^ storage_set_metadata field of the ImpactOnEpoch struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ImpactOnEpoch where
  encode = encode_ImpactOnEpoch
  decode = decode_ImpactOnEpoch
instance Hashable.Hashable ImpactOnEpoch where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` impactOnEpoch_log_id record   `Hashable.hashWithSalt` impactOnEpoch_epoch record   `Hashable.hashWithSalt` impactOnEpoch_storage_set record   `Hashable.hashWithSalt` impactOnEpoch_replication record   `Hashable.hashWithSalt` impactOnEpoch_impact record   `Hashable.hashWithSalt` impactOnEpoch_storage_set_metadata record  
instance DeepSeq.NFData ImpactOnEpoch where
  rnf _record17 =
    DeepSeq.rnf (impactOnEpoch_log_id _record17) `seq`
    DeepSeq.rnf (impactOnEpoch_epoch _record17) `seq`
    DeepSeq.rnf (impactOnEpoch_storage_set _record17) `seq`
    DeepSeq.rnf (impactOnEpoch_replication _record17) `seq`
    DeepSeq.rnf (impactOnEpoch_impact _record17) `seq`
    DeepSeq.rnf (impactOnEpoch_storage_set_metadata _record17) `seq`
    ()
instance Arbitrary.Arbitrary ImpactOnEpoch where 
  arbitrary = Monad.liftM ImpactOnEpoch (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_ImpactOnEpoch = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ImpactOnEpoch{impactOnEpoch_log_id = impactOnEpoch_log_id obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_log_id = impactOnEpoch_log_id obj}
    , if obj == default_ImpactOnEpoch{impactOnEpoch_epoch = impactOnEpoch_epoch obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_epoch = impactOnEpoch_epoch obj}
    , if obj == default_ImpactOnEpoch{impactOnEpoch_storage_set = impactOnEpoch_storage_set obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_storage_set = impactOnEpoch_storage_set obj}
    , if obj == default_ImpactOnEpoch{impactOnEpoch_replication = impactOnEpoch_replication obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_replication = impactOnEpoch_replication obj}
    , if obj == default_ImpactOnEpoch{impactOnEpoch_impact = impactOnEpoch_impact obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_impact = impactOnEpoch_impact obj}
    , if obj == default_ImpactOnEpoch{impactOnEpoch_storage_set_metadata = impactOnEpoch_storage_set_metadata obj} then Nothing else Just $ default_ImpactOnEpoch{impactOnEpoch_storage_set_metadata = impactOnEpoch_storage_set_metadata obj}
    ]
-- | Translate a 'ImpactOnEpoch' to a 'Types.ThriftVal'
from_ImpactOnEpoch :: ImpactOnEpoch -> Types.ThriftVal
from_ImpactOnEpoch record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v20 -> Just (1, ("log_id",Types.TI64 _v20))) $ impactOnEpoch_log_id record
  , (\_v20 -> Just (2, ("epoch",Types.TI64 _v20))) $ impactOnEpoch_epoch record
  , (\_v20 -> Just (3, ("storage_set",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v22 -> Common_Types.from_ShardID _v22) $ Vector.toList _v20))) $ impactOnEpoch_storage_set record
  , (\_v20 -> Just (4, ("replication",Types.TMap Types.T_I32 Types.T_I32 $ map (\(_k23,_v24) -> (Types.TI32 $ fromIntegral $ fromEnum _k23, Types.TI32 _v24)) $ Map.toList _v20))) $ impactOnEpoch_replication record
  , (\_v20 -> Just (5, ("impact",Types.TList Types.T_I32 $ map (\_v26 -> Types.TI32 $ fromIntegral $ fromEnum _v26) $ Vector.toList _v20))) $ impactOnEpoch_impact record
  , (\_v20 -> (6, ("storage_set_metadata",Types.TList (Types.T_STRUCT Safety_Types.typemap_ShardMetadata) $ map (\_v28 -> Safety_Types.from_ShardMetadata _v28) $ Vector.toList _v20))) <$> impactOnEpoch_storage_set_metadata record
  ]
-- | Write a 'ImpactOnEpoch' with the given 'Thrift.Protocol'
write_ImpactOnEpoch :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ImpactOnEpoch -> IO ()
write_ImpactOnEpoch oprot record = Thrift.writeVal oprot $ from_ImpactOnEpoch record
-- | Serialize a 'ImpactOnEpoch' in pure code
encode_ImpactOnEpoch :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ImpactOnEpoch -> BS.ByteString
encode_ImpactOnEpoch oprot record = Thrift.serializeVal oprot $ from_ImpactOnEpoch record
-- | Translate a 'Types.ThriftVal' to a 'ImpactOnEpoch'
to_ImpactOnEpoch :: Types.ThriftVal -> ImpactOnEpoch
to_ImpactOnEpoch (Types.TStruct fields) = ImpactOnEpoch{
  impactOnEpoch_log_id = maybe (impactOnEpoch_log_id default_ImpactOnEpoch) (\(_,_val30) -> (case _val30 of {Types.TI64 _val31 -> _val31; _ -> error "wrong type"})) (Map.lookup (1) fields),
  impactOnEpoch_epoch = maybe (impactOnEpoch_epoch default_ImpactOnEpoch) (\(_,_val30) -> (case _val30 of {Types.TI64 _val32 -> _val32; _ -> error "wrong type"})) (Map.lookup (2) fields),
  impactOnEpoch_storage_set = maybe (impactOnEpoch_storage_set default_ImpactOnEpoch) (\(_,_val30) -> (case _val30 of {Types.TList _ _val33 -> (Vector.fromList $ map (\_v34 -> (case _v34 of {Types.TStruct _val35 -> (Common_Types.to_ShardID (Types.TStruct _val35)); _ -> error "wrong type"})) _val33); _ -> error "wrong type"})) (Map.lookup (3) fields),
  impactOnEpoch_replication = maybe (impactOnEpoch_replication default_ImpactOnEpoch) (\(_,_val30) -> (case _val30 of {Types.TMap _ _ _val36 -> (Map.fromList $ map (\(_k38,_v37) -> ((case _k38 of {Types.TI32 _val39 -> toEnum $ fromIntegral _val39; _ -> error "wrong type"}),(case _v37 of {Types.TI32 _val40 -> _val40; _ -> error "wrong type"}))) _val36); _ -> error "wrong type"})) (Map.lookup (4) fields),
  impactOnEpoch_impact = maybe (impactOnEpoch_impact default_ImpactOnEpoch) (\(_,_val30) -> (case _val30 of {Types.TList _ _val41 -> (Vector.fromList $ map (\_v42 -> (case _v42 of {Types.TI32 _val43 -> toEnum $ fromIntegral _val43; _ -> error "wrong type"})) _val41); _ -> error "wrong type"})) (Map.lookup (5) fields),
  impactOnEpoch_storage_set_metadata = maybe (Nothing) (\(_,_val30) -> Just (case _val30 of {Types.TList _ _val44 -> (Vector.fromList $ map (\_v45 -> (case _v45 of {Types.TStruct _val46 -> (Safety_Types.to_ShardMetadata (Types.TStruct _val46)); _ -> error "wrong type"})) _val44); _ -> error "wrong type"})) (Map.lookup (6) fields)
  }
to_ImpactOnEpoch _ = error "not a struct"
-- | Read a 'ImpactOnEpoch' struct with the given 'Thrift.Protocol'
read_ImpactOnEpoch :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ImpactOnEpoch
read_ImpactOnEpoch iprot = to_ImpactOnEpoch <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ImpactOnEpoch)
-- | Deserialize a 'ImpactOnEpoch' in pure code
decode_ImpactOnEpoch :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ImpactOnEpoch
decode_ImpactOnEpoch iprot bs = to_ImpactOnEpoch $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ImpactOnEpoch) bs
-- | 'TypeMap' for the 'ImpactOnEpoch' struct
typemap_ImpactOnEpoch :: Types.TypeMap
typemap_ImpactOnEpoch = Map.fromList [("log_id",(1,Types.T_I64)),("epoch",(2,Types.T_I64)),("storage_set",(3,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID)))),("replication",(4,(Types.T_MAP Types.T_I32 Types.T_I32))),("impact",(5,(Types.T_LIST Types.T_I32))),("storage_set_metadata",(6,(Types.T_LIST (Types.T_STRUCT Safety_Types.typemap_ShardMetadata))))]
-- | Default values for the 'ImpactOnEpoch' struct
default_ImpactOnEpoch :: ImpactOnEpoch
default_ImpactOnEpoch = ImpactOnEpoch{
  impactOnEpoch_log_id = 0,
  impactOnEpoch_epoch = 0,
  impactOnEpoch_storage_set = Vector.empty,
  impactOnEpoch_replication = Map.empty,
  impactOnEpoch_impact = Vector.empty,
  impactOnEpoch_storage_set_metadata = Nothing}
-- | Definition of the CheckImpactRequest struct
data CheckImpactRequest = CheckImpactRequest
  { checkImpactRequest_shards :: (Vector.Vector Common_Types.ShardID)
    -- ^ shards field of the CheckImpactRequest struct
  , checkImpactRequest_target_storage_state :: Maybe Nodes_Types.ShardStorageState
    -- ^ target_storage_state field of the CheckImpactRequest struct
  , checkImpactRequest_disable_sequencers :: Maybe Bool
    -- ^ disable_sequencers field of the CheckImpactRequest struct
  , checkImpactRequest_safety_margin :: Maybe (Map.HashMap Common_Types.LocationScope Int.Int32)
    -- ^ safety_margin field of the CheckImpactRequest struct
  , checkImpactRequest_log_ids_to_check :: Maybe (Vector.Vector Int.Int64)
    -- ^ log_ids_to_check field of the CheckImpactRequest struct
  , checkImpactRequest_abort_on_negative_impact :: Maybe Bool
    -- ^ abort_on_negative_impact field of the CheckImpactRequest struct
  , checkImpactRequest_return_sample_size :: Maybe Int.Int32
    -- ^ return_sample_size field of the CheckImpactRequest struct
  , checkImpactRequest_check_metadata_logs :: Maybe Bool
    -- ^ check_metadata_logs field of the CheckImpactRequest struct
  , checkImpactRequest_check_internal_logs :: Maybe Bool
    -- ^ check_internal_logs field of the CheckImpactRequest struct
  , checkImpactRequest_check_capacity :: Maybe Bool
    -- ^ check_capacity field of the CheckImpactRequest struct
  , checkImpactRequest_max_unavailable_storage_capacity_pct :: Int.Int32
    -- ^ max_unavailable_storage_capacity_pct field of the CheckImpactRequest struct
  , checkImpactRequest_max_unavailable_sequencing_capacity_pct :: Int.Int32
    -- ^ max_unavailable_sequencing_capacity_pct field of the CheckImpactRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable CheckImpactRequest where
  encode = encode_CheckImpactRequest
  decode = decode_CheckImpactRequest
instance Hashable.Hashable CheckImpactRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` checkImpactRequest_shards record   `Hashable.hashWithSalt` checkImpactRequest_target_storage_state record   `Hashable.hashWithSalt` checkImpactRequest_disable_sequencers record   `Hashable.hashWithSalt` checkImpactRequest_safety_margin record   `Hashable.hashWithSalt` checkImpactRequest_log_ids_to_check record   `Hashable.hashWithSalt` checkImpactRequest_abort_on_negative_impact record   `Hashable.hashWithSalt` checkImpactRequest_return_sample_size record   `Hashable.hashWithSalt` checkImpactRequest_check_metadata_logs record   `Hashable.hashWithSalt` checkImpactRequest_check_internal_logs record   `Hashable.hashWithSalt` checkImpactRequest_check_capacity record   `Hashable.hashWithSalt` checkImpactRequest_max_unavailable_storage_capacity_pct record   `Hashable.hashWithSalt` checkImpactRequest_max_unavailable_sequencing_capacity_pct record  
instance DeepSeq.NFData CheckImpactRequest where
  rnf _record47 =
    DeepSeq.rnf (checkImpactRequest_shards _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_target_storage_state _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_disable_sequencers _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_safety_margin _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_log_ids_to_check _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_abort_on_negative_impact _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_return_sample_size _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_check_metadata_logs _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_check_internal_logs _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_check_capacity _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_max_unavailable_storage_capacity_pct _record47) `seq`
    DeepSeq.rnf (checkImpactRequest_max_unavailable_sequencing_capacity_pct _record47) `seq`
    ()
instance Arbitrary.Arbitrary CheckImpactRequest where 
  arbitrary = Monad.liftM CheckImpactRequest (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_CheckImpactRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_CheckImpactRequest{checkImpactRequest_shards = checkImpactRequest_shards obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_shards = checkImpactRequest_shards obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_target_storage_state = checkImpactRequest_target_storage_state obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_target_storage_state = checkImpactRequest_target_storage_state obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_disable_sequencers = checkImpactRequest_disable_sequencers obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_disable_sequencers = checkImpactRequest_disable_sequencers obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_safety_margin = checkImpactRequest_safety_margin obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_safety_margin = checkImpactRequest_safety_margin obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_log_ids_to_check = checkImpactRequest_log_ids_to_check obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_log_ids_to_check = checkImpactRequest_log_ids_to_check obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_abort_on_negative_impact = checkImpactRequest_abort_on_negative_impact obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_abort_on_negative_impact = checkImpactRequest_abort_on_negative_impact obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_return_sample_size = checkImpactRequest_return_sample_size obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_return_sample_size = checkImpactRequest_return_sample_size obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_check_metadata_logs = checkImpactRequest_check_metadata_logs obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_check_metadata_logs = checkImpactRequest_check_metadata_logs obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_check_internal_logs = checkImpactRequest_check_internal_logs obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_check_internal_logs = checkImpactRequest_check_internal_logs obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_check_capacity = checkImpactRequest_check_capacity obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_check_capacity = checkImpactRequest_check_capacity obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_max_unavailable_storage_capacity_pct = checkImpactRequest_max_unavailable_storage_capacity_pct obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_max_unavailable_storage_capacity_pct = checkImpactRequest_max_unavailable_storage_capacity_pct obj}
    , if obj == default_CheckImpactRequest{checkImpactRequest_max_unavailable_sequencing_capacity_pct = checkImpactRequest_max_unavailable_sequencing_capacity_pct obj} then Nothing else Just $ default_CheckImpactRequest{checkImpactRequest_max_unavailable_sequencing_capacity_pct = checkImpactRequest_max_unavailable_sequencing_capacity_pct obj}
    ]
-- | Translate a 'CheckImpactRequest' to a 'Types.ThriftVal'
from_CheckImpactRequest :: CheckImpactRequest -> Types.ThriftVal
from_CheckImpactRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v50 -> Just (1, ("shards",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v52 -> Common_Types.from_ShardID _v52) $ Vector.toList _v50))) $ checkImpactRequest_shards record
  , (\_v50 -> (2, ("target_storage_state",Types.TI32 $ fromIntegral $ fromEnum _v50))) <$> checkImpactRequest_target_storage_state record
  , (\_v50 -> (3, ("disable_sequencers",Types.TBool _v50))) <$> checkImpactRequest_disable_sequencers record
  , (\_v50 -> (4, ("safety_margin",Types.TMap Types.T_I32 Types.T_I32 $ map (\(_k53,_v54) -> (Types.TI32 $ fromIntegral $ fromEnum _k53, Types.TI32 _v54)) $ Map.toList _v50))) <$> checkImpactRequest_safety_margin record
  , (\_v50 -> (5, ("log_ids_to_check",Types.TList Types.T_I64 $ map (\_v56 -> Types.TI64 _v56) $ Vector.toList _v50))) <$> checkImpactRequest_log_ids_to_check record
  , (\_v50 -> (6, ("abort_on_negative_impact",Types.TBool _v50))) <$> checkImpactRequest_abort_on_negative_impact record
  , (\_v50 -> (7, ("return_sample_size",Types.TI32 _v50))) <$> checkImpactRequest_return_sample_size record
  , (\_v50 -> (8, ("check_metadata_logs",Types.TBool _v50))) <$> checkImpactRequest_check_metadata_logs record
  , (\_v50 -> (9, ("check_internal_logs",Types.TBool _v50))) <$> checkImpactRequest_check_internal_logs record
  , (\_v50 -> (10, ("check_capacity",Types.TBool _v50))) <$> checkImpactRequest_check_capacity record
  , (\_v50 -> Just (11, ("max_unavailable_storage_capacity_pct",Types.TI32 _v50))) $ checkImpactRequest_max_unavailable_storage_capacity_pct record
  , (\_v50 -> Just (12, ("max_unavailable_sequencing_capacity_pct",Types.TI32 _v50))) $ checkImpactRequest_max_unavailable_sequencing_capacity_pct record
  ]
-- | Write a 'CheckImpactRequest' with the given 'Thrift.Protocol'
write_CheckImpactRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpactRequest -> IO ()
write_CheckImpactRequest oprot record = Thrift.writeVal oprot $ from_CheckImpactRequest record
-- | Serialize a 'CheckImpactRequest' in pure code
encode_CheckImpactRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpactRequest -> BS.ByteString
encode_CheckImpactRequest oprot record = Thrift.serializeVal oprot $ from_CheckImpactRequest record
-- | Translate a 'Types.ThriftVal' to a 'CheckImpactRequest'
to_CheckImpactRequest :: Types.ThriftVal -> CheckImpactRequest
to_CheckImpactRequest (Types.TStruct fields) = CheckImpactRequest{
  checkImpactRequest_shards = maybe (checkImpactRequest_shards default_CheckImpactRequest) (\(_,_val58) -> (case _val58 of {Types.TList _ _val59 -> (Vector.fromList $ map (\_v60 -> (case _v60 of {Types.TStruct _val61 -> (Common_Types.to_ShardID (Types.TStruct _val61)); _ -> error "wrong type"})) _val59); _ -> error "wrong type"})) (Map.lookup (1) fields),
  checkImpactRequest_target_storage_state = maybe (Nothing) (\(_,_val58) -> Just (case _val58 of {Types.TI32 _val62 -> toEnum $ fromIntegral _val62; _ -> error "wrong type"})) (Map.lookup (2) fields),
  checkImpactRequest_disable_sequencers = maybe (Nothing) (\(_,_val58) -> Just (case _val58 of {Types.TBool _val63 -> _val63; _ -> error "wrong type"})) (Map.lookup (3) fields),
  checkImpactRequest_safety_margin = maybe (Nothing) (\(_,_val58) -> Just (case _val58 of {Types.TMap _ _ _val64 -> (Map.fromList $ map (\(_k66,_v65) -> ((case _k66 of {Types.TI32 _val67 -> toEnum $ fromIntegral _val67; _ -> error "wrong type"}),(case _v65 of {Types.TI32 _val68 -> _val68; _ -> error "wrong type"}))) _val64); _ -> error "wrong type"})) (Map.lookup (4) fields),
  checkImpactRequest_log_ids_to_check = maybe (Nothing) (\(_,_val58) -> Just (case _val58 of {Types.TList _ _val69 -> (Vector.fromList $ map (\_v70 -> (case _v70 of {Types.TI64 _val71 -> _val71; _ -> error "wrong type"})) _val69); _ -> error "wrong type"})) (Map.lookup (5) fields),
  checkImpactRequest_abort_on_negative_impact = maybe (checkImpactRequest_abort_on_negative_impact default_CheckImpactRequest) (\(_,_val58) -> Just (case _val58 of {Types.TBool _val72 -> _val72; _ -> error "wrong type"})) (Map.lookup (6) fields),
  checkImpactRequest_return_sample_size = maybe (checkImpactRequest_return_sample_size default_CheckImpactRequest) (\(_,_val58) -> Just (case _val58 of {Types.TI32 _val73 -> _val73; _ -> error "wrong type"})) (Map.lookup (7) fields),
  checkImpactRequest_check_metadata_logs = maybe (checkImpactRequest_check_metadata_logs default_CheckImpactRequest) (\(_,_val58) -> Just (case _val58 of {Types.TBool _val74 -> _val74; _ -> error "wrong type"})) (Map.lookup (8) fields),
  checkImpactRequest_check_internal_logs = maybe (checkImpactRequest_check_internal_logs default_CheckImpactRequest) (\(_,_val58) -> Just (case _val58 of {Types.TBool _val75 -> _val75; _ -> error "wrong type"})) (Map.lookup (9) fields),
  checkImpactRequest_check_capacity = maybe (checkImpactRequest_check_capacity default_CheckImpactRequest) (\(_,_val58) -> Just (case _val58 of {Types.TBool _val76 -> _val76; _ -> error "wrong type"})) (Map.lookup (10) fields),
  checkImpactRequest_max_unavailable_storage_capacity_pct = maybe (checkImpactRequest_max_unavailable_storage_capacity_pct default_CheckImpactRequest) (\(_,_val58) -> (case _val58 of {Types.TI32 _val77 -> _val77; _ -> error "wrong type"})) (Map.lookup (11) fields),
  checkImpactRequest_max_unavailable_sequencing_capacity_pct = maybe (checkImpactRequest_max_unavailable_sequencing_capacity_pct default_CheckImpactRequest) (\(_,_val58) -> (case _val58 of {Types.TI32 _val78 -> _val78; _ -> error "wrong type"})) (Map.lookup (12) fields)
  }
to_CheckImpactRequest _ = error "not a struct"
-- | Read a 'CheckImpactRequest' struct with the given 'Thrift.Protocol'
read_CheckImpactRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO CheckImpactRequest
read_CheckImpactRequest iprot = to_CheckImpactRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_CheckImpactRequest)
-- | Deserialize a 'CheckImpactRequest' in pure code
decode_CheckImpactRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> CheckImpactRequest
decode_CheckImpactRequest iprot bs = to_CheckImpactRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_CheckImpactRequest) bs
-- | 'TypeMap' for the 'CheckImpactRequest' struct
typemap_CheckImpactRequest :: Types.TypeMap
typemap_CheckImpactRequest = Map.fromList [("shards",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID)))),("target_storage_state",(2,Types.T_I32)),("disable_sequencers",(3,Types.T_BOOL)),("safety_margin",(4,(Types.T_MAP Types.T_I32 Types.T_I32))),("log_ids_to_check",(5,(Types.T_LIST Types.T_I64))),("abort_on_negative_impact",(6,Types.T_BOOL)),("return_sample_size",(7,Types.T_I32)),("check_metadata_logs",(8,Types.T_BOOL)),("check_internal_logs",(9,Types.T_BOOL)),("check_capacity",(10,Types.T_BOOL)),("max_unavailable_storage_capacity_pct",(11,Types.T_I32)),("max_unavailable_sequencing_capacity_pct",(12,Types.T_I32))]
-- | Default values for the 'CheckImpactRequest' struct
default_CheckImpactRequest :: CheckImpactRequest
default_CheckImpactRequest = CheckImpactRequest{
  checkImpactRequest_shards = Vector.empty,
  checkImpactRequest_target_storage_state = Nothing,
  checkImpactRequest_disable_sequencers = Nothing,
  checkImpactRequest_safety_margin = Nothing,
  checkImpactRequest_log_ids_to_check = Nothing,
  checkImpactRequest_abort_on_negative_impact = Just True,
  checkImpactRequest_return_sample_size = Just 50,
  checkImpactRequest_check_metadata_logs = Just True,
  checkImpactRequest_check_internal_logs = Just True,
  checkImpactRequest_check_capacity = Just True,
  checkImpactRequest_max_unavailable_storage_capacity_pct = 25,
  checkImpactRequest_max_unavailable_sequencing_capacity_pct = 25}
-- | Definition of the CheckImpactResponse struct
data CheckImpactResponse = CheckImpactResponse
  { checkImpactResponse_impact :: (Vector.Vector Safety_Types.OperationImpact)
    -- ^ impact field of the CheckImpactResponse struct
  , checkImpactResponse_internal_logs_affected :: Maybe Bool
    -- ^ internal_logs_affected field of the CheckImpactResponse struct
  , checkImpactResponse_logs_affected :: Maybe (Vector.Vector Safety_Types.ImpactOnEpoch)
    -- ^ logs_affected field of the CheckImpactResponse struct
  , checkImpactResponse_total_duration :: Maybe Int.Int32
    -- ^ total_duration field of the CheckImpactResponse struct
  , checkImpactResponse_total_logs_checked :: Maybe Int.Int32
    -- ^ total_logs_checked field of the CheckImpactResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable CheckImpactResponse where
  encode = encode_CheckImpactResponse
  decode = decode_CheckImpactResponse
instance Hashable.Hashable CheckImpactResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` checkImpactResponse_impact record   `Hashable.hashWithSalt` checkImpactResponse_internal_logs_affected record   `Hashable.hashWithSalt` checkImpactResponse_logs_affected record   `Hashable.hashWithSalt` checkImpactResponse_total_duration record   `Hashable.hashWithSalt` checkImpactResponse_total_logs_checked record  
instance DeepSeq.NFData CheckImpactResponse where
  rnf _record79 =
    DeepSeq.rnf (checkImpactResponse_impact _record79) `seq`
    DeepSeq.rnf (checkImpactResponse_internal_logs_affected _record79) `seq`
    DeepSeq.rnf (checkImpactResponse_logs_affected _record79) `seq`
    DeepSeq.rnf (checkImpactResponse_total_duration _record79) `seq`
    DeepSeq.rnf (checkImpactResponse_total_logs_checked _record79) `seq`
    ()
instance Arbitrary.Arbitrary CheckImpactResponse where 
  arbitrary = Monad.liftM CheckImpactResponse (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_CheckImpactResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_CheckImpactResponse{checkImpactResponse_impact = checkImpactResponse_impact obj} then Nothing else Just $ default_CheckImpactResponse{checkImpactResponse_impact = checkImpactResponse_impact obj}
    , if obj == default_CheckImpactResponse{checkImpactResponse_internal_logs_affected = checkImpactResponse_internal_logs_affected obj} then Nothing else Just $ default_CheckImpactResponse{checkImpactResponse_internal_logs_affected = checkImpactResponse_internal_logs_affected obj}
    , if obj == default_CheckImpactResponse{checkImpactResponse_logs_affected = checkImpactResponse_logs_affected obj} then Nothing else Just $ default_CheckImpactResponse{checkImpactResponse_logs_affected = checkImpactResponse_logs_affected obj}
    , if obj == default_CheckImpactResponse{checkImpactResponse_total_duration = checkImpactResponse_total_duration obj} then Nothing else Just $ default_CheckImpactResponse{checkImpactResponse_total_duration = checkImpactResponse_total_duration obj}
    , if obj == default_CheckImpactResponse{checkImpactResponse_total_logs_checked = checkImpactResponse_total_logs_checked obj} then Nothing else Just $ default_CheckImpactResponse{checkImpactResponse_total_logs_checked = checkImpactResponse_total_logs_checked obj}
    ]
-- | Translate a 'CheckImpactResponse' to a 'Types.ThriftVal'
from_CheckImpactResponse :: CheckImpactResponse -> Types.ThriftVal
from_CheckImpactResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v82 -> Just (1, ("impact",Types.TList Types.T_I32 $ map (\_v84 -> Types.TI32 $ fromIntegral $ fromEnum _v84) $ Vector.toList _v82))) $ checkImpactResponse_impact record
  , (\_v82 -> (2, ("internal_logs_affected",Types.TBool _v82))) <$> checkImpactResponse_internal_logs_affected record
  , (\_v82 -> (3, ("logs_affected",Types.TList (Types.T_STRUCT Safety_Types.typemap_ImpactOnEpoch) $ map (\_v86 -> Safety_Types.from_ImpactOnEpoch _v86) $ Vector.toList _v82))) <$> checkImpactResponse_logs_affected record
  , (\_v82 -> (4, ("total_duration",Types.TI32 _v82))) <$> checkImpactResponse_total_duration record
  , (\_v82 -> (5, ("total_logs_checked",Types.TI32 _v82))) <$> checkImpactResponse_total_logs_checked record
  ]
-- | Write a 'CheckImpactResponse' with the given 'Thrift.Protocol'
write_CheckImpactResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpactResponse -> IO ()
write_CheckImpactResponse oprot record = Thrift.writeVal oprot $ from_CheckImpactResponse record
-- | Serialize a 'CheckImpactResponse' in pure code
encode_CheckImpactResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> CheckImpactResponse -> BS.ByteString
encode_CheckImpactResponse oprot record = Thrift.serializeVal oprot $ from_CheckImpactResponse record
-- | Translate a 'Types.ThriftVal' to a 'CheckImpactResponse'
to_CheckImpactResponse :: Types.ThriftVal -> CheckImpactResponse
to_CheckImpactResponse (Types.TStruct fields) = CheckImpactResponse{
  checkImpactResponse_impact = maybe (checkImpactResponse_impact default_CheckImpactResponse) (\(_,_val88) -> (case _val88 of {Types.TList _ _val89 -> (Vector.fromList $ map (\_v90 -> (case _v90 of {Types.TI32 _val91 -> toEnum $ fromIntegral _val91; _ -> error "wrong type"})) _val89); _ -> error "wrong type"})) (Map.lookup (1) fields),
  checkImpactResponse_internal_logs_affected = maybe (Nothing) (\(_,_val88) -> Just (case _val88 of {Types.TBool _val92 -> _val92; _ -> error "wrong type"})) (Map.lookup (2) fields),
  checkImpactResponse_logs_affected = maybe (Nothing) (\(_,_val88) -> Just (case _val88 of {Types.TList _ _val93 -> (Vector.fromList $ map (\_v94 -> (case _v94 of {Types.TStruct _val95 -> (Safety_Types.to_ImpactOnEpoch (Types.TStruct _val95)); _ -> error "wrong type"})) _val93); _ -> error "wrong type"})) (Map.lookup (3) fields),
  checkImpactResponse_total_duration = maybe (Nothing) (\(_,_val88) -> Just (case _val88 of {Types.TI32 _val96 -> _val96; _ -> error "wrong type"})) (Map.lookup (4) fields),
  checkImpactResponse_total_logs_checked = maybe (Nothing) (\(_,_val88) -> Just (case _val88 of {Types.TI32 _val97 -> _val97; _ -> error "wrong type"})) (Map.lookup (5) fields)
  }
to_CheckImpactResponse _ = error "not a struct"
-- | Read a 'CheckImpactResponse' struct with the given 'Thrift.Protocol'
read_CheckImpactResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO CheckImpactResponse
read_CheckImpactResponse iprot = to_CheckImpactResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_CheckImpactResponse)
-- | Deserialize a 'CheckImpactResponse' in pure code
decode_CheckImpactResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> CheckImpactResponse
decode_CheckImpactResponse iprot bs = to_CheckImpactResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_CheckImpactResponse) bs
-- | 'TypeMap' for the 'CheckImpactResponse' struct
typemap_CheckImpactResponse :: Types.TypeMap
typemap_CheckImpactResponse = Map.fromList [("impact",(1,(Types.T_LIST Types.T_I32))),("internal_logs_affected",(2,Types.T_BOOL)),("logs_affected",(3,(Types.T_LIST (Types.T_STRUCT Safety_Types.typemap_ImpactOnEpoch)))),("total_duration",(4,Types.T_I32)),("total_logs_checked",(5,Types.T_I32))]
-- | Default values for the 'CheckImpactResponse' struct
default_CheckImpactResponse :: CheckImpactResponse
default_CheckImpactResponse = CheckImpactResponse{
  checkImpactResponse_impact = Vector.empty,
  checkImpactResponse_internal_logs_affected = Nothing,
  checkImpactResponse_logs_affected = Nothing,
  checkImpactResponse_total_duration = Nothing,
  checkImpactResponse_total_logs_checked = Nothing}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module HStream.Store.Thrift.Settings.Settings_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries


data SettingSource = CLI|CONFIG|ADMIN_OVERRIDE  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum SettingSource where
  fromEnum t = case t of
    CLI -> 0
    CONFIG -> 1
    ADMIN_OVERRIDE -> 2
  toEnum t = case t of
    0 -> CLI
    1 -> CONFIG
    2 -> ADMIN_OVERRIDE
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    CLI -> CONFIG
    CONFIG -> ADMIN_OVERRIDE
    ADMIN_OVERRIDE -> Exception.throw Thrift.ThriftException
  pred t = case t of
    CLI -> Exception.throw Thrift.ThriftException
    CONFIG -> CLI
    ADMIN_OVERRIDE -> CONFIG
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable SettingSource where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData SettingSource where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary SettingSource where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
-- | Definition of the Setting struct
data Setting = Setting
  { setting_currentValue :: LT.Text
    -- ^ currentValue field of the Setting struct
  , setting_defaultValue :: LT.Text
    -- ^ defaultValue field of the Setting struct
  , setting_sources :: (Map.HashMap Settings_Types.SettingSource LT.Text)
    -- ^ sources field of the Setting struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable Setting where
  encode = encode_Setting
  decode = decode_Setting
instance Hashable.Hashable Setting where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` setting_currentValue record   `Hashable.hashWithSalt` setting_defaultValue record   `Hashable.hashWithSalt` setting_sources record
instance DeepSeq.NFData Setting where
  rnf _record0 =
    DeepSeq.rnf (setting_currentValue _record0) `seq`
    DeepSeq.rnf (setting_defaultValue _record0) `seq`
    DeepSeq.rnf (setting_sources _record0) `seq`
    ()
instance Arbitrary.Arbitrary Setting where
  arbitrary = Monad.liftM Setting (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_Setting = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_Setting{setting_currentValue = setting_currentValue obj} then Nothing else Just $ default_Setting{setting_currentValue = setting_currentValue obj}
    , if obj == default_Setting{setting_defaultValue = setting_defaultValue obj} then Nothing else Just $ default_Setting{setting_defaultValue = setting_defaultValue obj}
    , if obj == default_Setting{setting_sources = setting_sources obj} then Nothing else Just $ default_Setting{setting_sources = setting_sources obj}
    ]
-- | Translate a 'Setting' to a 'Types.ThriftVal'
from_Setting :: Setting -> Types.ThriftVal
from_Setting record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("currentValue",Types.TString $ Encoding.encodeUtf8 _v3))) $ setting_currentValue record
  , (\_v3 -> Just (2, ("defaultValue",Types.TString $ Encoding.encodeUtf8 _v3))) $ setting_defaultValue record
  , (\_v3 -> Just (3, ("sources",Types.TMap Types.T_I32 Types.T_STRING $ map (\(_k4,_v5) -> (Types.TI32 $ fromIntegral $ fromEnum _k4, Types.TString $ Encoding.encodeUtf8 _v5)) $ Map.toList _v3))) $ setting_sources record
  ]
-- | Write a 'Setting' with the given 'Thrift.Protocol'
write_Setting :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Setting -> IO ()
write_Setting oprot record = Thrift.writeVal oprot $ from_Setting record
-- | Serialize a 'Setting' in pure code
encode_Setting :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Setting -> BS.ByteString
encode_Setting oprot record = Thrift.serializeVal oprot $ from_Setting record
-- | Translate a 'Types.ThriftVal' to a 'Setting'
to_Setting :: Types.ThriftVal -> Setting
to_Setting (Types.TStruct fields) = Setting{
  setting_currentValue = maybe (setting_currentValue default_Setting) (\(_,_val7) -> (case _val7 of {Types.TString _val8 -> Encoding.decodeUtf8 _val8; _ -> error "wrong type"})) (Map.lookup (1) fields),
  setting_defaultValue = maybe (setting_defaultValue default_Setting) (\(_,_val7) -> (case _val7 of {Types.TString _val9 -> Encoding.decodeUtf8 _val9; _ -> error "wrong type"})) (Map.lookup (2) fields),
  setting_sources = maybe (setting_sources default_Setting) (\(_,_val7) -> (case _val7 of {Types.TMap _ _ _val10 -> (Map.fromList $ map (\(_k12,_v11) -> ((case _k12 of {Types.TI32 _val13 -> toEnum $ fromIntegral _val13; _ -> error "wrong type"}),(case _v11 of {Types.TString _val14 -> Encoding.decodeUtf8 _val14; _ -> error "wrong type"}))) _val10); _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_Setting _ = error "not a struct"
-- | Read a 'Setting' struct with the given 'Thrift.Protocol'
read_Setting :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO Setting
read_Setting iprot = to_Setting <$> Thrift.readVal iprot (Types.T_STRUCT typemap_Setting)
-- | Deserialize a 'Setting' in pure code
decode_Setting :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> Setting
decode_Setting iprot bs = to_Setting $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_Setting) bs
-- | 'TypeMap' for the 'Setting' struct
typemap_Setting :: Types.TypeMap
typemap_Setting = Map.fromList [("currentValue",(1,Types.T_STRING)),("defaultValue",(2,Types.T_STRING)),("sources",(3,(Types.T_MAP Types.T_I32 Types.T_STRING)))]
-- | Default values for the 'Setting' struct
default_Setting :: Setting
default_Setting = Setting{
  setting_currentValue = "",
  setting_defaultValue = "",
  setting_sources = Map.empty}
-- | Definition of the SettingsResponse struct
data SettingsResponse = SettingsResponse
  { settingsResponse_settings :: (Map.HashMap LT.Text Settings_Types.Setting)
    -- ^ settings field of the SettingsResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SettingsResponse where
  encode = encode_SettingsResponse
  decode = decode_SettingsResponse
instance Hashable.Hashable SettingsResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` settingsResponse_settings record
instance DeepSeq.NFData SettingsResponse where
  rnf _record15 =
    DeepSeq.rnf (settingsResponse_settings _record15) `seq`
    ()
instance Arbitrary.Arbitrary SettingsResponse where
  arbitrary = Monad.liftM SettingsResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_SettingsResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SettingsResponse{settingsResponse_settings = settingsResponse_settings obj} then Nothing else Just $ default_SettingsResponse{settingsResponse_settings = settingsResponse_settings obj}
    ]
-- | Translate a 'SettingsResponse' to a 'Types.ThriftVal'
from_SettingsResponse :: SettingsResponse -> Types.ThriftVal
from_SettingsResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v18 -> Just (1, ("settings",Types.TMap Types.T_STRING (Types.T_STRUCT Settings_Types.typemap_Setting) $ map (\(_k19,_v20) -> (Types.TString $ Encoding.encodeUtf8 _k19, Settings_Types.from_Setting _v20)) $ Map.toList _v18))) $ settingsResponse_settings record
  ]
-- | Write a 'SettingsResponse' with the given 'Thrift.Protocol'
write_SettingsResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SettingsResponse -> IO ()
write_SettingsResponse oprot record = Thrift.writeVal oprot $ from_SettingsResponse record
-- | Serialize a 'SettingsResponse' in pure code
encode_SettingsResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SettingsResponse -> BS.ByteString
encode_SettingsResponse oprot record = Thrift.serializeVal oprot $ from_SettingsResponse record
-- | Translate a 'Types.ThriftVal' to a 'SettingsResponse'
to_SettingsResponse :: Types.ThriftVal -> SettingsResponse
to_SettingsResponse (Types.TStruct fields) = SettingsResponse{
  settingsResponse_settings = maybe (settingsResponse_settings default_SettingsResponse) (\(_,_val22) -> (case _val22 of {Types.TMap _ _ _val23 -> (Map.fromList $ map (\(_k25,_v24) -> ((case _k25 of {Types.TString _val26 -> Encoding.decodeUtf8 _val26; _ -> error "wrong type"}),(case _v24 of {Types.TStruct _val27 -> (Settings_Types.to_Setting (Types.TStruct _val27)); _ -> error "wrong type"}))) _val23); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_SettingsResponse _ = error "not a struct"
-- | Read a 'SettingsResponse' struct with the given 'Thrift.Protocol'
read_SettingsResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SettingsResponse
read_SettingsResponse iprot = to_SettingsResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SettingsResponse)
-- | Deserialize a 'SettingsResponse' in pure code
decode_SettingsResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SettingsResponse
decode_SettingsResponse iprot bs = to_SettingsResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SettingsResponse) bs
-- | 'TypeMap' for the 'SettingsResponse' struct
typemap_SettingsResponse :: Types.TypeMap
typemap_SettingsResponse = Map.fromList [("settings",(1,(Types.T_MAP Types.T_STRING (Types.T_STRUCT Settings_Types.typemap_Setting))))]
-- | Default values for the 'SettingsResponse' struct
default_SettingsResponse :: SettingsResponse
default_SettingsResponse = SettingsResponse{
  settingsResponse_settings = Map.empty}
-- | Definition of the SettingsRequest struct
data SettingsRequest = SettingsRequest
  { settingsRequest_settings :: Maybe (Set.HashSet LT.Text)
    -- ^ settings field of the SettingsRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable SettingsRequest where
  encode = encode_SettingsRequest
  decode = decode_SettingsRequest
instance Hashable.Hashable SettingsRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` settingsRequest_settings record
instance DeepSeq.NFData SettingsRequest where
  rnf _record28 =
    DeepSeq.rnf (settingsRequest_settings _record28) `seq`
    ()
instance Arbitrary.Arbitrary SettingsRequest where
  arbitrary = Monad.liftM SettingsRequest (Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_SettingsRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_SettingsRequest{settingsRequest_settings = settingsRequest_settings obj} then Nothing else Just $ default_SettingsRequest{settingsRequest_settings = settingsRequest_settings obj}
    ]
-- | Translate a 'SettingsRequest' to a 'Types.ThriftVal'
from_SettingsRequest :: SettingsRequest -> Types.ThriftVal
from_SettingsRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v31 -> (1, ("settings",Types.TSet Types.T_STRING $ map (\_v33 -> Types.TString $ Encoding.encodeUtf8 _v33) $ Set.toList _v31))) <$> settingsRequest_settings record
  ]
-- | Write a 'SettingsRequest' with the given 'Thrift.Protocol'
write_SettingsRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SettingsRequest -> IO ()
write_SettingsRequest oprot record = Thrift.writeVal oprot $ from_SettingsRequest record
-- | Serialize a 'SettingsRequest' in pure code
encode_SettingsRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> SettingsRequest -> BS.ByteString
encode_SettingsRequest oprot record = Thrift.serializeVal oprot $ from_SettingsRequest record
-- | Translate a 'Types.ThriftVal' to a 'SettingsRequest'
to_SettingsRequest :: Types.ThriftVal -> SettingsRequest
to_SettingsRequest (Types.TStruct fields) = SettingsRequest{
  settingsRequest_settings = maybe (Nothing) (\(_,_val35) -> Just (case _val35 of {Types.TSet _ _val36 -> (Set.fromList $ map (\_v37 -> (case _v37 of {Types.TString _val38 -> Encoding.decodeUtf8 _val38; _ -> error "wrong type"})) _val36); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_SettingsRequest _ = error "not a struct"
-- | Read a 'SettingsRequest' struct with the given 'Thrift.Protocol'
read_SettingsRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO SettingsRequest
read_SettingsRequest iprot = to_SettingsRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_SettingsRequest)
-- | Deserialize a 'SettingsRequest' in pure code
decode_SettingsRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> SettingsRequest
decode_SettingsRequest iprot bs = to_SettingsRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_SettingsRequest) bs
-- | 'TypeMap' for the 'SettingsRequest' struct
typemap_SettingsRequest :: Types.TypeMap
typemap_SettingsRequest = Map.fromList [("settings",(1,(Types.T_SET Types.T_STRING)))]
-- | Default values for the 'SettingsRequest' struct
default_SettingsRequest :: SettingsRequest
default_SettingsRequest = SettingsRequest{
  settingsRequest_settings = Nothing}
-- | Definition of the ApplySettingOverrideRequest struct
data ApplySettingOverrideRequest = ApplySettingOverrideRequest
  { applySettingOverrideRequest_name :: LT.Text
    -- ^ name field of the ApplySettingOverrideRequest struct
  , applySettingOverrideRequest_value :: LT.Text
    -- ^ value field of the ApplySettingOverrideRequest struct
  , applySettingOverrideRequest_ttl_seconds :: Int.Int32
    -- ^ ttl_seconds field of the ApplySettingOverrideRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ApplySettingOverrideRequest where
  encode = encode_ApplySettingOverrideRequest
  decode = decode_ApplySettingOverrideRequest
instance Hashable.Hashable ApplySettingOverrideRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` applySettingOverrideRequest_name record   `Hashable.hashWithSalt` applySettingOverrideRequest_value record   `Hashable.hashWithSalt` applySettingOverrideRequest_ttl_seconds record
instance DeepSeq.NFData ApplySettingOverrideRequest where
  rnf _record39 =
    DeepSeq.rnf (applySettingOverrideRequest_name _record39) `seq`
    DeepSeq.rnf (applySettingOverrideRequest_value _record39) `seq`
    DeepSeq.rnf (applySettingOverrideRequest_ttl_seconds _record39) `seq`
    ()
instance Arbitrary.Arbitrary ApplySettingOverrideRequest where
  arbitrary = Monad.liftM ApplySettingOverrideRequest (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ApplySettingOverrideRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ApplySettingOverrideRequest{applySettingOverrideRequest_name = applySettingOverrideRequest_name obj} then Nothing else Just $ default_ApplySettingOverrideRequest{applySettingOverrideRequest_name = applySettingOverrideRequest_name obj}
    , if obj == default_ApplySettingOverrideRequest{applySettingOverrideRequest_value = applySettingOverrideRequest_value obj} then Nothing else Just $ default_ApplySettingOverrideRequest{applySettingOverrideRequest_value = applySettingOverrideRequest_value obj}
    , if obj == default_ApplySettingOverrideRequest{applySettingOverrideRequest_ttl_seconds = applySettingOverrideRequest_ttl_seconds obj} then Nothing else Just $ default_ApplySettingOverrideRequest{applySettingOverrideRequest_ttl_seconds = applySettingOverrideRequest_ttl_seconds obj}
    ]
-- | Translate a 'ApplySettingOverrideRequest' to a 'Types.ThriftVal'
from_ApplySettingOverrideRequest :: ApplySettingOverrideRequest -> Types.ThriftVal
from_ApplySettingOverrideRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v42 -> Just (1, ("name",Types.TString $ Encoding.encodeUtf8 _v42))) $ applySettingOverrideRequest_name record
  , (\_v42 -> Just (2, ("value",Types.TString $ Encoding.encodeUtf8 _v42))) $ applySettingOverrideRequest_value record
  , (\_v42 -> Just (3, ("ttl_seconds",Types.TI32 _v42))) $ applySettingOverrideRequest_ttl_seconds record
  ]
-- | Write a 'ApplySettingOverrideRequest' with the given 'Thrift.Protocol'
write_ApplySettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverrideRequest -> IO ()
write_ApplySettingOverrideRequest oprot record = Thrift.writeVal oprot $ from_ApplySettingOverrideRequest record
-- | Serialize a 'ApplySettingOverrideRequest' in pure code
encode_ApplySettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ApplySettingOverrideRequest -> BS.ByteString
encode_ApplySettingOverrideRequest oprot record = Thrift.serializeVal oprot $ from_ApplySettingOverrideRequest record
-- | Translate a 'Types.ThriftVal' to a 'ApplySettingOverrideRequest'
to_ApplySettingOverrideRequest :: Types.ThriftVal -> ApplySettingOverrideRequest
to_ApplySettingOverrideRequest (Types.TStruct fields) = ApplySettingOverrideRequest{
  applySettingOverrideRequest_name = maybe (applySettingOverrideRequest_name default_ApplySettingOverrideRequest) (\(_,_val44) -> (case _val44 of {Types.TString _val45 -> Encoding.decodeUtf8 _val45; _ -> error "wrong type"})) (Map.lookup (1) fields),
  applySettingOverrideRequest_value = maybe (applySettingOverrideRequest_value default_ApplySettingOverrideRequest) (\(_,_val44) -> (case _val44 of {Types.TString _val46 -> Encoding.decodeUtf8 _val46; _ -> error "wrong type"})) (Map.lookup (2) fields),
  applySettingOverrideRequest_ttl_seconds = maybe (applySettingOverrideRequest_ttl_seconds default_ApplySettingOverrideRequest) (\(_,_val44) -> (case _val44 of {Types.TI32 _val47 -> _val47; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_ApplySettingOverrideRequest _ = error "not a struct"
-- | Read a 'ApplySettingOverrideRequest' struct with the given 'Thrift.Protocol'
read_ApplySettingOverrideRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ApplySettingOverrideRequest
read_ApplySettingOverrideRequest iprot = to_ApplySettingOverrideRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ApplySettingOverrideRequest)
-- | Deserialize a 'ApplySettingOverrideRequest' in pure code
decode_ApplySettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ApplySettingOverrideRequest
decode_ApplySettingOverrideRequest iprot bs = to_ApplySettingOverrideRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ApplySettingOverrideRequest) bs
-- | 'TypeMap' for the 'ApplySettingOverrideRequest' struct
typemap_ApplySettingOverrideRequest :: Types.TypeMap
typemap_ApplySettingOverrideRequest = Map.fromList [("name",(1,Types.T_STRING)),("value",(2,Types.T_STRING)),("ttl_seconds",(3,Types.T_I32))]
-- | Default values for the 'ApplySettingOverrideRequest' struct
default_ApplySettingOverrideRequest :: ApplySettingOverrideRequest
default_ApplySettingOverrideRequest = ApplySettingOverrideRequest{
  applySettingOverrideRequest_name = "",
  applySettingOverrideRequest_value = "",
  applySettingOverrideRequest_ttl_seconds = 0}
-- | Definition of the RemoveSettingOverrideRequest struct
data RemoveSettingOverrideRequest = RemoveSettingOverrideRequest
  { removeSettingOverrideRequest_name :: LT.Text
    -- ^ name field of the RemoveSettingOverrideRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveSettingOverrideRequest where
  encode = encode_RemoveSettingOverrideRequest
  decode = decode_RemoveSettingOverrideRequest
instance Hashable.Hashable RemoveSettingOverrideRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeSettingOverrideRequest_name record
instance DeepSeq.NFData RemoveSettingOverrideRequest where
  rnf _record48 =
    DeepSeq.rnf (removeSettingOverrideRequest_name _record48) `seq`
    ()
instance Arbitrary.Arbitrary RemoveSettingOverrideRequest where
  arbitrary = Monad.liftM RemoveSettingOverrideRequest (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveSettingOverrideRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveSettingOverrideRequest{removeSettingOverrideRequest_name = removeSettingOverrideRequest_name obj} then Nothing else Just $ default_RemoveSettingOverrideRequest{removeSettingOverrideRequest_name = removeSettingOverrideRequest_name obj}
    ]
-- | Translate a 'RemoveSettingOverrideRequest' to a 'Types.ThriftVal'
from_RemoveSettingOverrideRequest :: RemoveSettingOverrideRequest -> Types.ThriftVal
from_RemoveSettingOverrideRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v51 -> Just (1, ("name",Types.TString $ Encoding.encodeUtf8 _v51))) $ removeSettingOverrideRequest_name record
  ]
-- | Write a 'RemoveSettingOverrideRequest' with the given 'Thrift.Protocol'
write_RemoveSettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverrideRequest -> IO ()
write_RemoveSettingOverrideRequest oprot record = Thrift.writeVal oprot $ from_RemoveSettingOverrideRequest record
-- | Serialize a 'RemoveSettingOverrideRequest' in pure code
encode_RemoveSettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveSettingOverrideRequest -> BS.ByteString
encode_RemoveSettingOverrideRequest oprot record = Thrift.serializeVal oprot $ from_RemoveSettingOverrideRequest record
-- | Translate a 'Types.ThriftVal' to a 'RemoveSettingOverrideRequest'
to_RemoveSettingOverrideRequest :: Types.ThriftVal -> RemoveSettingOverrideRequest
to_RemoveSettingOverrideRequest (Types.TStruct fields) = RemoveSettingOverrideRequest{
  removeSettingOverrideRequest_name = maybe (removeSettingOverrideRequest_name default_RemoveSettingOverrideRequest) (\(_,_val53) -> (case _val53 of {Types.TString _val54 -> Encoding.decodeUtf8 _val54; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSettingOverrideRequest _ = error "not a struct"
-- | Read a 'RemoveSettingOverrideRequest' struct with the given 'Thrift.Protocol'
read_RemoveSettingOverrideRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveSettingOverrideRequest
read_RemoveSettingOverrideRequest iprot = to_RemoveSettingOverrideRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveSettingOverrideRequest)
-- | Deserialize a 'RemoveSettingOverrideRequest' in pure code
decode_RemoveSettingOverrideRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveSettingOverrideRequest
decode_RemoveSettingOverrideRequest iprot bs = to_RemoveSettingOverrideRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveSettingOverrideRequest) bs
-- | 'TypeMap' for the 'RemoveSettingOverrideRequest' struct
typemap_RemoveSettingOverrideRequest :: Types.TypeMap
typemap_RemoveSettingOverrideRequest = Map.fromList [("name",(1,Types.T_STRING))]
-- | Default values for the 'RemoveSettingOverrideRequest' struct
default_RemoveSettingOverrideRequest :: RemoveSettingOverrideRequest
default_RemoveSettingOverrideRequest = RemoveSettingOverrideRequest{
  removeSettingOverrideRequest_name = ""}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module HStream.Store.Thrift.Maintenance.Maintenance_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified HStream.Store.Thrift.Common.Common_Types as Common_Types
import qualified HStream.Store.Thrift.Nodes.Nodes_Types as Nodes_Types
import qualified HStream.Store.Thrift.Safety.Safety_Types as Safety_Types


data MaintenanceProgress = UNKNOWN|BLOCKED_UNTIL_SAFE|IN_PROGRESS|COMPLETED  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum MaintenanceProgress where
  fromEnum t = case t of
    UNKNOWN -> 0
    BLOCKED_UNTIL_SAFE -> 1
    IN_PROGRESS -> 2
    COMPLETED -> 3
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> BLOCKED_UNTIL_SAFE
    2 -> IN_PROGRESS
    3 -> COMPLETED
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    UNKNOWN -> BLOCKED_UNTIL_SAFE
    BLOCKED_UNTIL_SAFE -> IN_PROGRESS
    IN_PROGRESS -> COMPLETED
    COMPLETED -> Exception.throw Thrift.ThriftException
  pred t = case t of
    UNKNOWN -> Exception.throw Thrift.ThriftException
    BLOCKED_UNTIL_SAFE -> UNKNOWN
    IN_PROGRESS -> BLOCKED_UNTIL_SAFE
    COMPLETED -> IN_PROGRESS
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable MaintenanceProgress where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData MaintenanceProgress where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary MaintenanceProgress where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
data MaintenancePriority = IMMINENT|HIGH|MEDIUM|LOW  deriving (Show,Eq, Typeable.Typeable, Ord, Bounded)
instance Enum MaintenancePriority where
  fromEnum t = case t of
    IMMINENT -> 1
    HIGH -> 2
    MEDIUM -> 3
    LOW -> 4
  toEnum t = case t of
    1 -> IMMINENT
    2 -> HIGH
    3 -> MEDIUM
    4 -> LOW
    _ -> Exception.throw Thrift.ThriftException
  succ t = case t of
    IMMINENT -> HIGH
    HIGH -> MEDIUM
    MEDIUM -> LOW
    LOW -> Exception.throw Thrift.ThriftException
  pred t = case t of
    IMMINENT -> Exception.throw Thrift.ThriftException
    HIGH -> IMMINENT
    MEDIUM -> HIGH
    LOW -> MEDIUM
  enumFrom x = enumFromTo x maxBound
  enumFromTo x y = takeUpToInc y $ iterate succ x
    where
    takeUpToInc _ [] = []
    takeUpToInc m (x:_) | m == x = [x]
    takeUpToInc m (x:xs) | otherwise = x : takeUpToInc m xs
  enumFromThen _ _ = Exception.throw Thrift.ThriftException
  enumFromThenTo _ _ _ = Exception.throw Thrift.ThriftException
instance Hashable.Hashable MaintenancePriority where
  hashWithSalt salt = Hashable.hashWithSalt salt . fromEnum
instance DeepSeq.NFData MaintenancePriority where
  rnf x = x `seq` ()
instance Arbitrary.Arbitrary MaintenancePriority where
  arbitrary = QuickCheck.elements (enumFromTo minBound maxBound)
-- | Definition of the MaintenanceDefinition struct
data MaintenanceDefinition = MaintenanceDefinition
  { maintenanceDefinition_shards :: (Vector.Vector Common_Types.ShardID)
    -- ^ shards field of the MaintenanceDefinition struct
  , maintenanceDefinition_shard_target_state :: Nodes_Types.ShardOperationalState
    -- ^ shard_target_state field of the MaintenanceDefinition struct
  , maintenanceDefinition_sequencer_nodes :: (Vector.Vector Common_Types.NodeID)
    -- ^ sequencer_nodes field of the MaintenanceDefinition struct
  , maintenanceDefinition_sequencer_target_state :: Nodes_Types.SequencingState
    -- ^ sequencer_target_state field of the MaintenanceDefinition struct
  , maintenanceDefinition_user :: LT.Text
    -- ^ user field of the MaintenanceDefinition struct
  , maintenanceDefinition_reason :: LT.Text
    -- ^ reason field of the MaintenanceDefinition struct
  , maintenanceDefinition_extras :: (Map.HashMap LT.Text LT.Text)
    -- ^ extras field of the MaintenanceDefinition struct
  , maintenanceDefinition_skip_safety_checks :: Bool
    -- ^ skip_safety_checks field of the MaintenanceDefinition struct
  , maintenanceDefinition_force_restore_rebuilding :: Bool
    -- ^ force_restore_rebuilding field of the MaintenanceDefinition struct
  , maintenanceDefinition_group :: Bool
    -- ^ group field of the MaintenanceDefinition struct
  , maintenanceDefinition_ttl_seconds :: Int.Int32
    -- ^ ttl_seconds field of the MaintenanceDefinition struct
  , maintenanceDefinition_allow_passive_drains :: Bool
    -- ^ allow_passive_drains field of the MaintenanceDefinition struct
  , maintenanceDefinition_group_id :: Maybe LT.Text
    -- ^ group_id field of the MaintenanceDefinition struct
  , maintenanceDefinition_last_check_impact_result :: Maybe Safety_Types.CheckImpactResponse
    -- ^ last_check_impact_result field of the MaintenanceDefinition struct
  , maintenanceDefinition_expires_on :: Maybe Int.Int64
    -- ^ expires_on field of the MaintenanceDefinition struct
  , maintenanceDefinition_created_on :: Maybe Int.Int64
    -- ^ created_on field of the MaintenanceDefinition struct
  , maintenanceDefinition_progress :: Maintenance_Types.MaintenanceProgress
    -- ^ progress field of the MaintenanceDefinition struct
  , maintenanceDefinition_priority :: Maybe Maintenance_Types.MaintenancePriority
    -- ^ priority field of the MaintenanceDefinition struct
  , maintenanceDefinition_skip_capacity_checks :: Bool
    -- ^ skip_capacity_checks field of the MaintenanceDefinition struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MaintenanceDefinition where
  encode = encode_MaintenanceDefinition
  decode = decode_MaintenanceDefinition
instance Hashable.Hashable MaintenanceDefinition where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` maintenanceDefinition_shards record   `Hashable.hashWithSalt` maintenanceDefinition_shard_target_state record   `Hashable.hashWithSalt` maintenanceDefinition_sequencer_nodes record   `Hashable.hashWithSalt` maintenanceDefinition_sequencer_target_state record   `Hashable.hashWithSalt` maintenanceDefinition_user record   `Hashable.hashWithSalt` maintenanceDefinition_reason record   `Hashable.hashWithSalt` maintenanceDefinition_extras record   `Hashable.hashWithSalt` maintenanceDefinition_skip_safety_checks record   `Hashable.hashWithSalt` maintenanceDefinition_force_restore_rebuilding record   `Hashable.hashWithSalt` maintenanceDefinition_group record   `Hashable.hashWithSalt` maintenanceDefinition_ttl_seconds record   `Hashable.hashWithSalt` maintenanceDefinition_allow_passive_drains record   `Hashable.hashWithSalt` maintenanceDefinition_group_id record   `Hashable.hashWithSalt` maintenanceDefinition_last_check_impact_result record   `Hashable.hashWithSalt` maintenanceDefinition_expires_on record   `Hashable.hashWithSalt` maintenanceDefinition_created_on record   `Hashable.hashWithSalt` maintenanceDefinition_progress record   `Hashable.hashWithSalt` maintenanceDefinition_priority record   `Hashable.hashWithSalt` maintenanceDefinition_skip_capacity_checks record
instance DeepSeq.NFData MaintenanceDefinition where
  rnf _record0 =
    DeepSeq.rnf (maintenanceDefinition_shards _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_shard_target_state _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_sequencer_nodes _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_sequencer_target_state _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_user _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_reason _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_extras _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_skip_safety_checks _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_force_restore_rebuilding _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_group _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_ttl_seconds _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_allow_passive_drains _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_group_id _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_last_check_impact_result _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_expires_on _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_created_on _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_progress _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_priority _record0) `seq`
    DeepSeq.rnf (maintenanceDefinition_skip_capacity_checks _record0) `seq`
    ()
instance Arbitrary.Arbitrary MaintenanceDefinition where
  arbitrary = Monad.liftM MaintenanceDefinition (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_MaintenanceDefinition = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MaintenanceDefinition{maintenanceDefinition_shards = maintenanceDefinition_shards obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_shards = maintenanceDefinition_shards obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_shard_target_state = maintenanceDefinition_shard_target_state obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_shard_target_state = maintenanceDefinition_shard_target_state obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_sequencer_nodes = maintenanceDefinition_sequencer_nodes obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_sequencer_nodes = maintenanceDefinition_sequencer_nodes obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_sequencer_target_state = maintenanceDefinition_sequencer_target_state obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_sequencer_target_state = maintenanceDefinition_sequencer_target_state obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_user = maintenanceDefinition_user obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_user = maintenanceDefinition_user obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_reason = maintenanceDefinition_reason obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_reason = maintenanceDefinition_reason obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_extras = maintenanceDefinition_extras obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_extras = maintenanceDefinition_extras obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_skip_safety_checks = maintenanceDefinition_skip_safety_checks obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_skip_safety_checks = maintenanceDefinition_skip_safety_checks obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_force_restore_rebuilding = maintenanceDefinition_force_restore_rebuilding obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_force_restore_rebuilding = maintenanceDefinition_force_restore_rebuilding obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_group = maintenanceDefinition_group obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_group = maintenanceDefinition_group obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_ttl_seconds = maintenanceDefinition_ttl_seconds obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_ttl_seconds = maintenanceDefinition_ttl_seconds obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_allow_passive_drains = maintenanceDefinition_allow_passive_drains obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_allow_passive_drains = maintenanceDefinition_allow_passive_drains obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_group_id = maintenanceDefinition_group_id obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_group_id = maintenanceDefinition_group_id obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_last_check_impact_result = maintenanceDefinition_last_check_impact_result obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_last_check_impact_result = maintenanceDefinition_last_check_impact_result obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_expires_on = maintenanceDefinition_expires_on obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_expires_on = maintenanceDefinition_expires_on obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_created_on = maintenanceDefinition_created_on obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_created_on = maintenanceDefinition_created_on obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_progress = maintenanceDefinition_progress obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_progress = maintenanceDefinition_progress obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_priority = maintenanceDefinition_priority obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_priority = maintenanceDefinition_priority obj}
    , if obj == default_MaintenanceDefinition{maintenanceDefinition_skip_capacity_checks = maintenanceDefinition_skip_capacity_checks obj} then Nothing else Just $ default_MaintenanceDefinition{maintenanceDefinition_skip_capacity_checks = maintenanceDefinition_skip_capacity_checks obj}
    ]
-- | Translate a 'MaintenanceDefinition' to a 'Types.ThriftVal'
from_MaintenanceDefinition :: MaintenanceDefinition -> Types.ThriftVal
from_MaintenanceDefinition record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("shards",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v5 -> Common_Types.from_ShardID _v5) $ Vector.toList _v3))) $ maintenanceDefinition_shards record
  , (\_v3 -> Just (2, ("shard_target_state",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ maintenanceDefinition_shard_target_state record
  , (\_v3 -> Just (3, ("sequencer_nodes",Types.TList (Types.T_STRUCT Common_Types.typemap_NodeID) $ map (\_v7 -> Common_Types.from_NodeID _v7) $ Vector.toList _v3))) $ maintenanceDefinition_sequencer_nodes record
  , (\_v3 -> Just (4, ("sequencer_target_state",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ maintenanceDefinition_sequencer_target_state record
  , (\_v3 -> Just (5, ("user",Types.TString $ Encoding.encodeUtf8 _v3))) $ maintenanceDefinition_user record
  , (\_v3 -> Just (6, ("reason",Types.TString $ Encoding.encodeUtf8 _v3))) $ maintenanceDefinition_reason record
  , (\_v3 -> Just (7, ("extras",Types.TMap Types.T_STRING Types.T_STRING $ map (\(_k8,_v9) -> (Types.TString $ Encoding.encodeUtf8 _k8, Types.TString $ Encoding.encodeUtf8 _v9)) $ Map.toList _v3))) $ maintenanceDefinition_extras record
  , (\_v3 -> Just (8, ("skip_safety_checks",Types.TBool _v3))) $ maintenanceDefinition_skip_safety_checks record
  , (\_v3 -> Just (9, ("force_restore_rebuilding",Types.TBool _v3))) $ maintenanceDefinition_force_restore_rebuilding record
  , (\_v3 -> Just (10, ("group",Types.TBool _v3))) $ maintenanceDefinition_group record
  , (\_v3 -> Just (11, ("ttl_seconds",Types.TI32 _v3))) $ maintenanceDefinition_ttl_seconds record
  , (\_v3 -> Just (12, ("allow_passive_drains",Types.TBool _v3))) $ maintenanceDefinition_allow_passive_drains record
  , (\_v3 -> (13, ("group_id",Types.TString $ Encoding.encodeUtf8 _v3))) <$> maintenanceDefinition_group_id record
  , (\_v3 -> (14, ("last_check_impact_result",Safety_Types.from_CheckImpactResponse _v3))) <$> maintenanceDefinition_last_check_impact_result record
  , (\_v3 -> (15, ("expires_on",Types.TI64 _v3))) <$> maintenanceDefinition_expires_on record
  , (\_v3 -> (16, ("created_on",Types.TI64 _v3))) <$> maintenanceDefinition_created_on record
  , (\_v3 -> Just (17, ("progress",Types.TI32 $ fromIntegral $ fromEnum _v3))) $ maintenanceDefinition_progress record
  , (\_v3 -> (18, ("priority",Types.TI32 $ fromIntegral $ fromEnum _v3))) <$> maintenanceDefinition_priority record
  , (\_v3 -> Just (19, ("skip_capacity_checks",Types.TBool _v3))) $ maintenanceDefinition_skip_capacity_checks record
  ]
-- | Write a 'MaintenanceDefinition' with the given 'Thrift.Protocol'
write_MaintenanceDefinition :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenanceDefinition -> IO ()
write_MaintenanceDefinition oprot record = Thrift.writeVal oprot $ from_MaintenanceDefinition record
-- | Serialize a 'MaintenanceDefinition' in pure code
encode_MaintenanceDefinition :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenanceDefinition -> BS.ByteString
encode_MaintenanceDefinition oprot record = Thrift.serializeVal oprot $ from_MaintenanceDefinition record
-- | Translate a 'Types.ThriftVal' to a 'MaintenanceDefinition'
to_MaintenanceDefinition :: Types.ThriftVal -> MaintenanceDefinition
to_MaintenanceDefinition (Types.TStruct fields) = MaintenanceDefinition{
  maintenanceDefinition_shards = maybe (maintenanceDefinition_shards default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TList _ _val12 -> (Vector.fromList $ map (\_v13 -> (case _v13 of {Types.TStruct _val14 -> (Common_Types.to_ShardID (Types.TStruct _val14)); _ -> error "wrong type"})) _val12); _ -> error "wrong type"})) (Map.lookup (1) fields),
  maintenanceDefinition_shard_target_state = maybe (maintenanceDefinition_shard_target_state default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TI32 _val15 -> toEnum $ fromIntegral _val15; _ -> error "wrong type"})) (Map.lookup (2) fields),
  maintenanceDefinition_sequencer_nodes = maybe (maintenanceDefinition_sequencer_nodes default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TList _ _val16 -> (Vector.fromList $ map (\_v17 -> (case _v17 of {Types.TStruct _val18 -> (Common_Types.to_NodeID (Types.TStruct _val18)); _ -> error "wrong type"})) _val16); _ -> error "wrong type"})) (Map.lookup (3) fields),
  maintenanceDefinition_sequencer_target_state = maybe (maintenanceDefinition_sequencer_target_state default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TI32 _val19 -> toEnum $ fromIntegral _val19; _ -> error "wrong type"})) (Map.lookup (4) fields),
  maintenanceDefinition_user = maybe (maintenanceDefinition_user default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TString _val20 -> Encoding.decodeUtf8 _val20; _ -> error "wrong type"})) (Map.lookup (5) fields),
  maintenanceDefinition_reason = maybe (maintenanceDefinition_reason default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TString _val21 -> Encoding.decodeUtf8 _val21; _ -> error "wrong type"})) (Map.lookup (6) fields),
  maintenanceDefinition_extras = maybe (maintenanceDefinition_extras default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TMap _ _ _val22 -> (Map.fromList $ map (\(_k24,_v23) -> ((case _k24 of {Types.TString _val25 -> Encoding.decodeUtf8 _val25; _ -> error "wrong type"}),(case _v23 of {Types.TString _val26 -> Encoding.decodeUtf8 _val26; _ -> error "wrong type"}))) _val22); _ -> error "wrong type"})) (Map.lookup (7) fields),
  maintenanceDefinition_skip_safety_checks = maybe (maintenanceDefinition_skip_safety_checks default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TBool _val27 -> _val27; _ -> error "wrong type"})) (Map.lookup (8) fields),
  maintenanceDefinition_force_restore_rebuilding = maybe (maintenanceDefinition_force_restore_rebuilding default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TBool _val28 -> _val28; _ -> error "wrong type"})) (Map.lookup (9) fields),
  maintenanceDefinition_group = maybe (maintenanceDefinition_group default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TBool _val29 -> _val29; _ -> error "wrong type"})) (Map.lookup (10) fields),
  maintenanceDefinition_ttl_seconds = maybe (maintenanceDefinition_ttl_seconds default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TI32 _val30 -> _val30; _ -> error "wrong type"})) (Map.lookup (11) fields),
  maintenanceDefinition_allow_passive_drains = maybe (maintenanceDefinition_allow_passive_drains default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TBool _val31 -> _val31; _ -> error "wrong type"})) (Map.lookup (12) fields),
  maintenanceDefinition_group_id = maybe (Nothing) (\(_,_val11) -> Just (case _val11 of {Types.TString _val32 -> Encoding.decodeUtf8 _val32; _ -> error "wrong type"})) (Map.lookup (13) fields),
  maintenanceDefinition_last_check_impact_result = maybe (Nothing) (\(_,_val11) -> Just (case _val11 of {Types.TStruct _val33 -> (Safety_Types.to_CheckImpactResponse (Types.TStruct _val33)); _ -> error "wrong type"})) (Map.lookup (14) fields),
  maintenanceDefinition_expires_on = maybe (Nothing) (\(_,_val11) -> Just (case _val11 of {Types.TI64 _val34 -> _val34; _ -> error "wrong type"})) (Map.lookup (15) fields),
  maintenanceDefinition_created_on = maybe (Nothing) (\(_,_val11) -> Just (case _val11 of {Types.TI64 _val35 -> _val35; _ -> error "wrong type"})) (Map.lookup (16) fields),
  maintenanceDefinition_progress = maybe (maintenanceDefinition_progress default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TI32 _val36 -> toEnum $ fromIntegral _val36; _ -> error "wrong type"})) (Map.lookup (17) fields),
  maintenanceDefinition_priority = maybe (Nothing) (\(_,_val11) -> Just (case _val11 of {Types.TI32 _val37 -> toEnum $ fromIntegral _val37; _ -> error "wrong type"})) (Map.lookup (18) fields),
  maintenanceDefinition_skip_capacity_checks = maybe (maintenanceDefinition_skip_capacity_checks default_MaintenanceDefinition) (\(_,_val11) -> (case _val11 of {Types.TBool _val38 -> _val38; _ -> error "wrong type"})) (Map.lookup (19) fields)
  }
to_MaintenanceDefinition _ = error "not a struct"
-- | Read a 'MaintenanceDefinition' struct with the given 'Thrift.Protocol'
read_MaintenanceDefinition :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MaintenanceDefinition
read_MaintenanceDefinition iprot = to_MaintenanceDefinition <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MaintenanceDefinition)
-- | Deserialize a 'MaintenanceDefinition' in pure code
decode_MaintenanceDefinition :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MaintenanceDefinition
decode_MaintenanceDefinition iprot bs = to_MaintenanceDefinition $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MaintenanceDefinition) bs
-- | 'TypeMap' for the 'MaintenanceDefinition' struct
typemap_MaintenanceDefinition :: Types.TypeMap
typemap_MaintenanceDefinition = Map.fromList [("shards",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID)))),("shard_target_state",(2,Types.T_I32)),("sequencer_nodes",(3,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_NodeID)))),("sequencer_target_state",(4,Types.T_I32)),("user",(5,Types.T_STRING)),("reason",(6,Types.T_STRING)),("extras",(7,(Types.T_MAP Types.T_STRING Types.T_STRING))),("skip_safety_checks",(8,Types.T_BOOL)),("force_restore_rebuilding",(9,Types.T_BOOL)),("group",(10,Types.T_BOOL)),("ttl_seconds",(11,Types.T_I32)),("allow_passive_drains",(12,Types.T_BOOL)),("group_id",(13,Types.T_STRING)),("last_check_impact_result",(14,(Types.T_STRUCT Safety_Types.typemap_CheckImpactResponse))),("expires_on",(15,Types.T_I64)),("created_on",(16,Types.T_I64)),("progress",(17,Types.T_I32)),("priority",(18,Types.T_I32)),("skip_capacity_checks",(19,Types.T_BOOL))]
-- | Default values for the 'MaintenanceDefinition' struct
default_MaintenanceDefinition :: MaintenanceDefinition
default_MaintenanceDefinition = MaintenanceDefinition{
  maintenanceDefinition_shards = Vector.empty,
  maintenanceDefinition_shard_target_state = (toEnum 0),
  maintenanceDefinition_sequencer_nodes = Vector.empty,
  maintenanceDefinition_sequencer_target_state = (toEnum 0),
  maintenanceDefinition_user = "",
  maintenanceDefinition_reason = "",
  maintenanceDefinition_extras = Map.empty,
  maintenanceDefinition_skip_safety_checks = False,
  maintenanceDefinition_force_restore_rebuilding = False,
  maintenanceDefinition_group = True,
  maintenanceDefinition_ttl_seconds = 0,
  maintenanceDefinition_allow_passive_drains = False,
  maintenanceDefinition_group_id = Nothing,
  maintenanceDefinition_last_check_impact_result = Nothing,
  maintenanceDefinition_expires_on = Nothing,
  maintenanceDefinition_created_on = Nothing,
  maintenanceDefinition_progress = (toEnum 0),
  maintenanceDefinition_priority = Nothing,
  maintenanceDefinition_skip_capacity_checks = False}
-- | Definition of the ClusterMaintenanceState struct
data ClusterMaintenanceState = ClusterMaintenanceState
  { clusterMaintenanceState_maintenances :: (Vector.Vector Maintenance_Types.MaintenanceDefinition)
    -- ^ maintenances field of the ClusterMaintenanceState struct
  , clusterMaintenanceState_version :: Int.Int64
    -- ^ version field of the ClusterMaintenanceState struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable ClusterMaintenanceState where
  encode = encode_ClusterMaintenanceState
  decode = decode_ClusterMaintenanceState
instance Hashable.Hashable ClusterMaintenanceState where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` clusterMaintenanceState_maintenances record   `Hashable.hashWithSalt` clusterMaintenanceState_version record
instance DeepSeq.NFData ClusterMaintenanceState where
  rnf _record39 =
    DeepSeq.rnf (clusterMaintenanceState_maintenances _record39) `seq`
    DeepSeq.rnf (clusterMaintenanceState_version _record39) `seq`
    ()
instance Arbitrary.Arbitrary ClusterMaintenanceState where
  arbitrary = Monad.liftM ClusterMaintenanceState (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_ClusterMaintenanceState = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_ClusterMaintenanceState{clusterMaintenanceState_maintenances = clusterMaintenanceState_maintenances obj} then Nothing else Just $ default_ClusterMaintenanceState{clusterMaintenanceState_maintenances = clusterMaintenanceState_maintenances obj}
    , if obj == default_ClusterMaintenanceState{clusterMaintenanceState_version = clusterMaintenanceState_version obj} then Nothing else Just $ default_ClusterMaintenanceState{clusterMaintenanceState_version = clusterMaintenanceState_version obj}
    ]
-- | Translate a 'ClusterMaintenanceState' to a 'Types.ThriftVal'
from_ClusterMaintenanceState :: ClusterMaintenanceState -> Types.ThriftVal
from_ClusterMaintenanceState record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v42 -> Just (1, ("maintenances",Types.TList (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition) $ map (\_v44 -> Maintenance_Types.from_MaintenanceDefinition _v44) $ Vector.toList _v42))) $ clusterMaintenanceState_maintenances record
  , (\_v42 -> Just (2, ("version",Types.TI64 _v42))) $ clusterMaintenanceState_version record
  ]
-- | Write a 'ClusterMaintenanceState' with the given 'Thrift.Protocol'
write_ClusterMaintenanceState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMaintenanceState -> IO ()
write_ClusterMaintenanceState oprot record = Thrift.writeVal oprot $ from_ClusterMaintenanceState record
-- | Serialize a 'ClusterMaintenanceState' in pure code
encode_ClusterMaintenanceState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> ClusterMaintenanceState -> BS.ByteString
encode_ClusterMaintenanceState oprot record = Thrift.serializeVal oprot $ from_ClusterMaintenanceState record
-- | Translate a 'Types.ThriftVal' to a 'ClusterMaintenanceState'
to_ClusterMaintenanceState :: Types.ThriftVal -> ClusterMaintenanceState
to_ClusterMaintenanceState (Types.TStruct fields) = ClusterMaintenanceState{
  clusterMaintenanceState_maintenances = maybe (clusterMaintenanceState_maintenances default_ClusterMaintenanceState) (\(_,_val46) -> (case _val46 of {Types.TList _ _val47 -> (Vector.fromList $ map (\_v48 -> (case _v48 of {Types.TStruct _val49 -> (Maintenance_Types.to_MaintenanceDefinition (Types.TStruct _val49)); _ -> error "wrong type"})) _val47); _ -> error "wrong type"})) (Map.lookup (1) fields),
  clusterMaintenanceState_version = maybe (clusterMaintenanceState_version default_ClusterMaintenanceState) (\(_,_val46) -> (case _val46 of {Types.TI64 _val50 -> _val50; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_ClusterMaintenanceState _ = error "not a struct"
-- | Read a 'ClusterMaintenanceState' struct with the given 'Thrift.Protocol'
read_ClusterMaintenanceState :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO ClusterMaintenanceState
read_ClusterMaintenanceState iprot = to_ClusterMaintenanceState <$> Thrift.readVal iprot (Types.T_STRUCT typemap_ClusterMaintenanceState)
-- | Deserialize a 'ClusterMaintenanceState' in pure code
decode_ClusterMaintenanceState :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> ClusterMaintenanceState
decode_ClusterMaintenanceState iprot bs = to_ClusterMaintenanceState $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_ClusterMaintenanceState) bs
-- | 'TypeMap' for the 'ClusterMaintenanceState' struct
typemap_ClusterMaintenanceState :: Types.TypeMap
typemap_ClusterMaintenanceState = Map.fromList [("maintenances",(1,(Types.T_LIST (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition)))),("version",(2,Types.T_I64))]
-- | Default values for the 'ClusterMaintenanceState' struct
default_ClusterMaintenanceState :: ClusterMaintenanceState
default_ClusterMaintenanceState = ClusterMaintenanceState{
  clusterMaintenanceState_maintenances = Vector.empty,
  clusterMaintenanceState_version = 0}
-- | Definition of the MaintenanceDefinitionResponse struct
data MaintenanceDefinitionResponse = MaintenanceDefinitionResponse
  { maintenanceDefinitionResponse_maintenances :: (Vector.Vector Maintenance_Types.MaintenanceDefinition)
    -- ^ maintenances field of the MaintenanceDefinitionResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MaintenanceDefinitionResponse where
  encode = encode_MaintenanceDefinitionResponse
  decode = decode_MaintenanceDefinitionResponse
instance Hashable.Hashable MaintenanceDefinitionResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` maintenanceDefinitionResponse_maintenances record
instance DeepSeq.NFData MaintenanceDefinitionResponse where
  rnf _record51 =
    DeepSeq.rnf (maintenanceDefinitionResponse_maintenances _record51) `seq`
    ()
instance Arbitrary.Arbitrary MaintenanceDefinitionResponse where
  arbitrary = Monad.liftM MaintenanceDefinitionResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_MaintenanceDefinitionResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MaintenanceDefinitionResponse{maintenanceDefinitionResponse_maintenances = maintenanceDefinitionResponse_maintenances obj} then Nothing else Just $ default_MaintenanceDefinitionResponse{maintenanceDefinitionResponse_maintenances = maintenanceDefinitionResponse_maintenances obj}
    ]
-- | Translate a 'MaintenanceDefinitionResponse' to a 'Types.ThriftVal'
from_MaintenanceDefinitionResponse :: MaintenanceDefinitionResponse -> Types.ThriftVal
from_MaintenanceDefinitionResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v54 -> Just (1, ("maintenances",Types.TList (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition) $ map (\_v56 -> Maintenance_Types.from_MaintenanceDefinition _v56) $ Vector.toList _v54))) $ maintenanceDefinitionResponse_maintenances record
  ]
-- | Write a 'MaintenanceDefinitionResponse' with the given 'Thrift.Protocol'
write_MaintenanceDefinitionResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenanceDefinitionResponse -> IO ()
write_MaintenanceDefinitionResponse oprot record = Thrift.writeVal oprot $ from_MaintenanceDefinitionResponse record
-- | Serialize a 'MaintenanceDefinitionResponse' in pure code
encode_MaintenanceDefinitionResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenanceDefinitionResponse -> BS.ByteString
encode_MaintenanceDefinitionResponse oprot record = Thrift.serializeVal oprot $ from_MaintenanceDefinitionResponse record
-- | Translate a 'Types.ThriftVal' to a 'MaintenanceDefinitionResponse'
to_MaintenanceDefinitionResponse :: Types.ThriftVal -> MaintenanceDefinitionResponse
to_MaintenanceDefinitionResponse (Types.TStruct fields) = MaintenanceDefinitionResponse{
  maintenanceDefinitionResponse_maintenances = maybe (maintenanceDefinitionResponse_maintenances default_MaintenanceDefinitionResponse) (\(_,_val58) -> (case _val58 of {Types.TList _ _val59 -> (Vector.fromList $ map (\_v60 -> (case _v60 of {Types.TStruct _val61 -> (Maintenance_Types.to_MaintenanceDefinition (Types.TStruct _val61)); _ -> error "wrong type"})) _val59); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_MaintenanceDefinitionResponse _ = error "not a struct"
-- | Read a 'MaintenanceDefinitionResponse' struct with the given 'Thrift.Protocol'
read_MaintenanceDefinitionResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MaintenanceDefinitionResponse
read_MaintenanceDefinitionResponse iprot = to_MaintenanceDefinitionResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MaintenanceDefinitionResponse)
-- | Deserialize a 'MaintenanceDefinitionResponse' in pure code
decode_MaintenanceDefinitionResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MaintenanceDefinitionResponse
decode_MaintenanceDefinitionResponse iprot bs = to_MaintenanceDefinitionResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MaintenanceDefinitionResponse) bs
-- | 'TypeMap' for the 'MaintenanceDefinitionResponse' struct
typemap_MaintenanceDefinitionResponse :: Types.TypeMap
typemap_MaintenanceDefinitionResponse = Map.fromList [("maintenances",(1,(Types.T_LIST (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition))))]
-- | Default values for the 'MaintenanceDefinitionResponse' struct
default_MaintenanceDefinitionResponse :: MaintenanceDefinitionResponse
default_MaintenanceDefinitionResponse = MaintenanceDefinitionResponse{
  maintenanceDefinitionResponse_maintenances = Vector.empty}
-- | Definition of the MaintenancesFilter struct
data MaintenancesFilter = MaintenancesFilter
  { maintenancesFilter_group_ids :: (Vector.Vector LT.Text)
    -- ^ group_ids field of the MaintenancesFilter struct
  , maintenancesFilter_user :: Maybe LT.Text
    -- ^ user field of the MaintenancesFilter struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MaintenancesFilter where
  encode = encode_MaintenancesFilter
  decode = decode_MaintenancesFilter
instance Hashable.Hashable MaintenancesFilter where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` maintenancesFilter_group_ids record   `Hashable.hashWithSalt` maintenancesFilter_user record
instance DeepSeq.NFData MaintenancesFilter where
  rnf _record62 =
    DeepSeq.rnf (maintenancesFilter_group_ids _record62) `seq`
    DeepSeq.rnf (maintenancesFilter_user _record62) `seq`
    ()
instance Arbitrary.Arbitrary MaintenancesFilter where
  arbitrary = Monad.liftM MaintenancesFilter (Arbitrary.arbitrary)
          `Monad.ap`(Monad.liftM Just Arbitrary.arbitrary)
  shrink obj | obj == default_MaintenancesFilter = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MaintenancesFilter{maintenancesFilter_group_ids = maintenancesFilter_group_ids obj} then Nothing else Just $ default_MaintenancesFilter{maintenancesFilter_group_ids = maintenancesFilter_group_ids obj}
    , if obj == default_MaintenancesFilter{maintenancesFilter_user = maintenancesFilter_user obj} then Nothing else Just $ default_MaintenancesFilter{maintenancesFilter_user = maintenancesFilter_user obj}
    ]
-- | Translate a 'MaintenancesFilter' to a 'Types.ThriftVal'
from_MaintenancesFilter :: MaintenancesFilter -> Types.ThriftVal
from_MaintenancesFilter record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v65 -> Just (1, ("group_ids",Types.TList Types.T_STRING $ map (\_v67 -> Types.TString $ Encoding.encodeUtf8 _v67) $ Vector.toList _v65))) $ maintenancesFilter_group_ids record
  , (\_v65 -> (2, ("user",Types.TString $ Encoding.encodeUtf8 _v65))) <$> maintenancesFilter_user record
  ]
-- | Write a 'MaintenancesFilter' with the given 'Thrift.Protocol'
write_MaintenancesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenancesFilter -> IO ()
write_MaintenancesFilter oprot record = Thrift.writeVal oprot $ from_MaintenancesFilter record
-- | Serialize a 'MaintenancesFilter' in pure code
encode_MaintenancesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MaintenancesFilter -> BS.ByteString
encode_MaintenancesFilter oprot record = Thrift.serializeVal oprot $ from_MaintenancesFilter record
-- | Translate a 'Types.ThriftVal' to a 'MaintenancesFilter'
to_MaintenancesFilter :: Types.ThriftVal -> MaintenancesFilter
to_MaintenancesFilter (Types.TStruct fields) = MaintenancesFilter{
  maintenancesFilter_group_ids = maybe (maintenancesFilter_group_ids default_MaintenancesFilter) (\(_,_val69) -> (case _val69 of {Types.TList _ _val70 -> (Vector.fromList $ map (\_v71 -> (case _v71 of {Types.TString _val72 -> Encoding.decodeUtf8 _val72; _ -> error "wrong type"})) _val70); _ -> error "wrong type"})) (Map.lookup (1) fields),
  maintenancesFilter_user = maybe (Nothing) (\(_,_val69) -> Just (case _val69 of {Types.TString _val73 -> Encoding.decodeUtf8 _val73; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_MaintenancesFilter _ = error "not a struct"
-- | Read a 'MaintenancesFilter' struct with the given 'Thrift.Protocol'
read_MaintenancesFilter :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MaintenancesFilter
read_MaintenancesFilter iprot = to_MaintenancesFilter <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MaintenancesFilter)
-- | Deserialize a 'MaintenancesFilter' in pure code
decode_MaintenancesFilter :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MaintenancesFilter
decode_MaintenancesFilter iprot bs = to_MaintenancesFilter $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MaintenancesFilter) bs
-- | 'TypeMap' for the 'MaintenancesFilter' struct
typemap_MaintenancesFilter :: Types.TypeMap
typemap_MaintenancesFilter = Map.fromList [("group_ids",(1,(Types.T_LIST Types.T_STRING))),("user",(2,Types.T_STRING))]
-- | Default values for the 'MaintenancesFilter' struct
default_MaintenancesFilter :: MaintenancesFilter
default_MaintenancesFilter = MaintenancesFilter{
  maintenancesFilter_group_ids = Vector.empty,
  maintenancesFilter_user = Nothing}
-- | Definition of the RemoveMaintenancesRequest struct
data RemoveMaintenancesRequest = RemoveMaintenancesRequest
  { removeMaintenancesRequest_filter :: Maintenance_Types.MaintenancesFilter
    -- ^ filter field of the RemoveMaintenancesRequest struct
  , removeMaintenancesRequest_user :: LT.Text
    -- ^ user field of the RemoveMaintenancesRequest struct
  , removeMaintenancesRequest_reason :: LT.Text
    -- ^ reason field of the RemoveMaintenancesRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveMaintenancesRequest where
  encode = encode_RemoveMaintenancesRequest
  decode = decode_RemoveMaintenancesRequest
instance Hashable.Hashable RemoveMaintenancesRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeMaintenancesRequest_filter record   `Hashable.hashWithSalt` removeMaintenancesRequest_user record   `Hashable.hashWithSalt` removeMaintenancesRequest_reason record
instance DeepSeq.NFData RemoveMaintenancesRequest where
  rnf _record74 =
    DeepSeq.rnf (removeMaintenancesRequest_filter _record74) `seq`
    DeepSeq.rnf (removeMaintenancesRequest_user _record74) `seq`
    DeepSeq.rnf (removeMaintenancesRequest_reason _record74) `seq`
    ()
instance Arbitrary.Arbitrary RemoveMaintenancesRequest where
  arbitrary = Monad.liftM RemoveMaintenancesRequest (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveMaintenancesRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveMaintenancesRequest{removeMaintenancesRequest_filter = removeMaintenancesRequest_filter obj} then Nothing else Just $ default_RemoveMaintenancesRequest{removeMaintenancesRequest_filter = removeMaintenancesRequest_filter obj}
    , if obj == default_RemoveMaintenancesRequest{removeMaintenancesRequest_user = removeMaintenancesRequest_user obj} then Nothing else Just $ default_RemoveMaintenancesRequest{removeMaintenancesRequest_user = removeMaintenancesRequest_user obj}
    , if obj == default_RemoveMaintenancesRequest{removeMaintenancesRequest_reason = removeMaintenancesRequest_reason obj} then Nothing else Just $ default_RemoveMaintenancesRequest{removeMaintenancesRequest_reason = removeMaintenancesRequest_reason obj}
    ]
-- | Translate a 'RemoveMaintenancesRequest' to a 'Types.ThriftVal'
from_RemoveMaintenancesRequest :: RemoveMaintenancesRequest -> Types.ThriftVal
from_RemoveMaintenancesRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v77 -> Just (1, ("filter",Maintenance_Types.from_MaintenancesFilter _v77))) $ removeMaintenancesRequest_filter record
  , (\_v77 -> Just (2, ("user",Types.TString $ Encoding.encodeUtf8 _v77))) $ removeMaintenancesRequest_user record
  , (\_v77 -> Just (3, ("reason",Types.TString $ Encoding.encodeUtf8 _v77))) $ removeMaintenancesRequest_reason record
  ]
-- | Write a 'RemoveMaintenancesRequest' with the given 'Thrift.Protocol'
write_RemoveMaintenancesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenancesRequest -> IO ()
write_RemoveMaintenancesRequest oprot record = Thrift.writeVal oprot $ from_RemoveMaintenancesRequest record
-- | Serialize a 'RemoveMaintenancesRequest' in pure code
encode_RemoveMaintenancesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenancesRequest -> BS.ByteString
encode_RemoveMaintenancesRequest oprot record = Thrift.serializeVal oprot $ from_RemoveMaintenancesRequest record
-- | Translate a 'Types.ThriftVal' to a 'RemoveMaintenancesRequest'
to_RemoveMaintenancesRequest :: Types.ThriftVal -> RemoveMaintenancesRequest
to_RemoveMaintenancesRequest (Types.TStruct fields) = RemoveMaintenancesRequest{
  removeMaintenancesRequest_filter = maybe (removeMaintenancesRequest_filter default_RemoveMaintenancesRequest) (\(_,_val79) -> (case _val79 of {Types.TStruct _val80 -> (Maintenance_Types.to_MaintenancesFilter (Types.TStruct _val80)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  removeMaintenancesRequest_user = maybe (removeMaintenancesRequest_user default_RemoveMaintenancesRequest) (\(_,_val79) -> (case _val79 of {Types.TString _val81 -> Encoding.decodeUtf8 _val81; _ -> error "wrong type"})) (Map.lookup (2) fields),
  removeMaintenancesRequest_reason = maybe (removeMaintenancesRequest_reason default_RemoveMaintenancesRequest) (\(_,_val79) -> (case _val79 of {Types.TString _val82 -> Encoding.decodeUtf8 _val82; _ -> error "wrong type"})) (Map.lookup (3) fields)
  }
to_RemoveMaintenancesRequest _ = error "not a struct"
-- | Read a 'RemoveMaintenancesRequest' struct with the given 'Thrift.Protocol'
read_RemoveMaintenancesRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveMaintenancesRequest
read_RemoveMaintenancesRequest iprot = to_RemoveMaintenancesRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveMaintenancesRequest)
-- | Deserialize a 'RemoveMaintenancesRequest' in pure code
decode_RemoveMaintenancesRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveMaintenancesRequest
decode_RemoveMaintenancesRequest iprot bs = to_RemoveMaintenancesRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveMaintenancesRequest) bs
-- | 'TypeMap' for the 'RemoveMaintenancesRequest' struct
typemap_RemoveMaintenancesRequest :: Types.TypeMap
typemap_RemoveMaintenancesRequest = Map.fromList [("filter",(1,(Types.T_STRUCT Maintenance_Types.typemap_MaintenancesFilter))),("user",(2,Types.T_STRING)),("reason",(3,Types.T_STRING))]
-- | Default values for the 'RemoveMaintenancesRequest' struct
default_RemoveMaintenancesRequest :: RemoveMaintenancesRequest
default_RemoveMaintenancesRequest = RemoveMaintenancesRequest{
  removeMaintenancesRequest_filter = Maintenance_Types.default_MaintenancesFilter,
  removeMaintenancesRequest_user = "",
  removeMaintenancesRequest_reason = ""}
-- | Definition of the RemoveMaintenancesResponse struct
data RemoveMaintenancesResponse = RemoveMaintenancesResponse
  { removeMaintenancesResponse_maintenances :: (Vector.Vector Maintenance_Types.MaintenanceDefinition)
    -- ^ maintenances field of the RemoveMaintenancesResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable RemoveMaintenancesResponse where
  encode = encode_RemoveMaintenancesResponse
  decode = decode_RemoveMaintenancesResponse
instance Hashable.Hashable RemoveMaintenancesResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` removeMaintenancesResponse_maintenances record
instance DeepSeq.NFData RemoveMaintenancesResponse where
  rnf _record83 =
    DeepSeq.rnf (removeMaintenancesResponse_maintenances _record83) `seq`
    ()
instance Arbitrary.Arbitrary RemoveMaintenancesResponse where
  arbitrary = Monad.liftM RemoveMaintenancesResponse (Arbitrary.arbitrary)
  shrink obj | obj == default_RemoveMaintenancesResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_RemoveMaintenancesResponse{removeMaintenancesResponse_maintenances = removeMaintenancesResponse_maintenances obj} then Nothing else Just $ default_RemoveMaintenancesResponse{removeMaintenancesResponse_maintenances = removeMaintenancesResponse_maintenances obj}
    ]
-- | Translate a 'RemoveMaintenancesResponse' to a 'Types.ThriftVal'
from_RemoveMaintenancesResponse :: RemoveMaintenancesResponse -> Types.ThriftVal
from_RemoveMaintenancesResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v86 -> Just (1, ("maintenances",Types.TList (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition) $ map (\_v88 -> Maintenance_Types.from_MaintenanceDefinition _v88) $ Vector.toList _v86))) $ removeMaintenancesResponse_maintenances record
  ]
-- | Write a 'RemoveMaintenancesResponse' with the given 'Thrift.Protocol'
write_RemoveMaintenancesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenancesResponse -> IO ()
write_RemoveMaintenancesResponse oprot record = Thrift.writeVal oprot $ from_RemoveMaintenancesResponse record
-- | Serialize a 'RemoveMaintenancesResponse' in pure code
encode_RemoveMaintenancesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> RemoveMaintenancesResponse -> BS.ByteString
encode_RemoveMaintenancesResponse oprot record = Thrift.serializeVal oprot $ from_RemoveMaintenancesResponse record
-- | Translate a 'Types.ThriftVal' to a 'RemoveMaintenancesResponse'
to_RemoveMaintenancesResponse :: Types.ThriftVal -> RemoveMaintenancesResponse
to_RemoveMaintenancesResponse (Types.TStruct fields) = RemoveMaintenancesResponse{
  removeMaintenancesResponse_maintenances = maybe (removeMaintenancesResponse_maintenances default_RemoveMaintenancesResponse) (\(_,_val90) -> (case _val90 of {Types.TList _ _val91 -> (Vector.fromList $ map (\_v92 -> (case _v92 of {Types.TStruct _val93 -> (Maintenance_Types.to_MaintenanceDefinition (Types.TStruct _val93)); _ -> error "wrong type"})) _val91); _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMaintenancesResponse _ = error "not a struct"
-- | Read a 'RemoveMaintenancesResponse' struct with the given 'Thrift.Protocol'
read_RemoveMaintenancesResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO RemoveMaintenancesResponse
read_RemoveMaintenancesResponse iprot = to_RemoveMaintenancesResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_RemoveMaintenancesResponse)
-- | Deserialize a 'RemoveMaintenancesResponse' in pure code
decode_RemoveMaintenancesResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> RemoveMaintenancesResponse
decode_RemoveMaintenancesResponse iprot bs = to_RemoveMaintenancesResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_RemoveMaintenancesResponse) bs
-- | 'TypeMap' for the 'RemoveMaintenancesResponse' struct
typemap_RemoveMaintenancesResponse :: Types.TypeMap
typemap_RemoveMaintenancesResponse = Map.fromList [("maintenances",(1,(Types.T_LIST (Types.T_STRUCT Maintenance_Types.typemap_MaintenanceDefinition))))]
-- | Default values for the 'RemoveMaintenancesResponse' struct
default_RemoveMaintenancesResponse :: RemoveMaintenancesResponse
default_RemoveMaintenancesResponse = RemoveMaintenancesResponse{
  removeMaintenancesResponse_maintenances = Vector.empty}
-- | Definition of the MarkAllShardsUnrecoverableRequest struct
data MarkAllShardsUnrecoverableRequest = MarkAllShardsUnrecoverableRequest
  { markAllShardsUnrecoverableRequest_user :: LT.Text
    -- ^ user field of the MarkAllShardsUnrecoverableRequest struct
  , markAllShardsUnrecoverableRequest_reason :: LT.Text
    -- ^ reason field of the MarkAllShardsUnrecoverableRequest struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkAllShardsUnrecoverableRequest where
  encode = encode_MarkAllShardsUnrecoverableRequest
  decode = decode_MarkAllShardsUnrecoverableRequest
instance Hashable.Hashable MarkAllShardsUnrecoverableRequest where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markAllShardsUnrecoverableRequest_user record   `Hashable.hashWithSalt` markAllShardsUnrecoverableRequest_reason record
instance DeepSeq.NFData MarkAllShardsUnrecoverableRequest where
  rnf _record94 =
    DeepSeq.rnf (markAllShardsUnrecoverableRequest_user _record94) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverableRequest_reason _record94) `seq`
    ()
instance Arbitrary.Arbitrary MarkAllShardsUnrecoverableRequest where
  arbitrary = Monad.liftM MarkAllShardsUnrecoverableRequest (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_MarkAllShardsUnrecoverableRequest = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkAllShardsUnrecoverableRequest{markAllShardsUnrecoverableRequest_user = markAllShardsUnrecoverableRequest_user obj} then Nothing else Just $ default_MarkAllShardsUnrecoverableRequest{markAllShardsUnrecoverableRequest_user = markAllShardsUnrecoverableRequest_user obj}
    , if obj == default_MarkAllShardsUnrecoverableRequest{markAllShardsUnrecoverableRequest_reason = markAllShardsUnrecoverableRequest_reason obj} then Nothing else Just $ default_MarkAllShardsUnrecoverableRequest{markAllShardsUnrecoverableRequest_reason = markAllShardsUnrecoverableRequest_reason obj}
    ]
-- | Translate a 'MarkAllShardsUnrecoverableRequest' to a 'Types.ThriftVal'
from_MarkAllShardsUnrecoverableRequest :: MarkAllShardsUnrecoverableRequest -> Types.ThriftVal
from_MarkAllShardsUnrecoverableRequest record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v97 -> Just (1, ("user",Types.TString $ Encoding.encodeUtf8 _v97))) $ markAllShardsUnrecoverableRequest_user record
  , (\_v97 -> Just (2, ("reason",Types.TString $ Encoding.encodeUtf8 _v97))) $ markAllShardsUnrecoverableRequest_reason record
  ]
-- | Write a 'MarkAllShardsUnrecoverableRequest' with the given 'Thrift.Protocol'
write_MarkAllShardsUnrecoverableRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverableRequest -> IO ()
write_MarkAllShardsUnrecoverableRequest oprot record = Thrift.writeVal oprot $ from_MarkAllShardsUnrecoverableRequest record
-- | Serialize a 'MarkAllShardsUnrecoverableRequest' in pure code
encode_MarkAllShardsUnrecoverableRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverableRequest -> BS.ByteString
encode_MarkAllShardsUnrecoverableRequest oprot record = Thrift.serializeVal oprot $ from_MarkAllShardsUnrecoverableRequest record
-- | Translate a 'Types.ThriftVal' to a 'MarkAllShardsUnrecoverableRequest'
to_MarkAllShardsUnrecoverableRequest :: Types.ThriftVal -> MarkAllShardsUnrecoverableRequest
to_MarkAllShardsUnrecoverableRequest (Types.TStruct fields) = MarkAllShardsUnrecoverableRequest{
  markAllShardsUnrecoverableRequest_user = maybe (markAllShardsUnrecoverableRequest_user default_MarkAllShardsUnrecoverableRequest) (\(_,_val99) -> (case _val99 of {Types.TString _val100 -> Encoding.decodeUtf8 _val100; _ -> error "wrong type"})) (Map.lookup (1) fields),
  markAllShardsUnrecoverableRequest_reason = maybe (markAllShardsUnrecoverableRequest_reason default_MarkAllShardsUnrecoverableRequest) (\(_,_val99) -> (case _val99 of {Types.TString _val101 -> Encoding.decodeUtf8 _val101; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_MarkAllShardsUnrecoverableRequest _ = error "not a struct"
-- | Read a 'MarkAllShardsUnrecoverableRequest' struct with the given 'Thrift.Protocol'
read_MarkAllShardsUnrecoverableRequest :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkAllShardsUnrecoverableRequest
read_MarkAllShardsUnrecoverableRequest iprot = to_MarkAllShardsUnrecoverableRequest <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverableRequest)
-- | Deserialize a 'MarkAllShardsUnrecoverableRequest' in pure code
decode_MarkAllShardsUnrecoverableRequest :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkAllShardsUnrecoverableRequest
decode_MarkAllShardsUnrecoverableRequest iprot bs = to_MarkAllShardsUnrecoverableRequest $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverableRequest) bs
-- | 'TypeMap' for the 'MarkAllShardsUnrecoverableRequest' struct
typemap_MarkAllShardsUnrecoverableRequest :: Types.TypeMap
typemap_MarkAllShardsUnrecoverableRequest = Map.fromList [("user",(1,Types.T_STRING)),("reason",(2,Types.T_STRING))]
-- | Default values for the 'MarkAllShardsUnrecoverableRequest' struct
default_MarkAllShardsUnrecoverableRequest :: MarkAllShardsUnrecoverableRequest
default_MarkAllShardsUnrecoverableRequest = MarkAllShardsUnrecoverableRequest{
  markAllShardsUnrecoverableRequest_user = "",
  markAllShardsUnrecoverableRequest_reason = ""}
-- | Definition of the MarkAllShardsUnrecoverableResponse struct
data MarkAllShardsUnrecoverableResponse = MarkAllShardsUnrecoverableResponse
  { markAllShardsUnrecoverableResponse_shards_succeeded :: (Vector.Vector Common_Types.ShardID)
    -- ^ shards_succeeded field of the MarkAllShardsUnrecoverableResponse struct
  , markAllShardsUnrecoverableResponse_shards_failed :: (Vector.Vector Common_Types.ShardID)
    -- ^ shards_failed field of the MarkAllShardsUnrecoverableResponse struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable MarkAllShardsUnrecoverableResponse where
  encode = encode_MarkAllShardsUnrecoverableResponse
  decode = decode_MarkAllShardsUnrecoverableResponse
instance Hashable.Hashable MarkAllShardsUnrecoverableResponse where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` markAllShardsUnrecoverableResponse_shards_succeeded record   `Hashable.hashWithSalt` markAllShardsUnrecoverableResponse_shards_failed record
instance DeepSeq.NFData MarkAllShardsUnrecoverableResponse where
  rnf _record102 =
    DeepSeq.rnf (markAllShardsUnrecoverableResponse_shards_succeeded _record102) `seq`
    DeepSeq.rnf (markAllShardsUnrecoverableResponse_shards_failed _record102) `seq`
    ()
instance Arbitrary.Arbitrary MarkAllShardsUnrecoverableResponse where
  arbitrary = Monad.liftM MarkAllShardsUnrecoverableResponse (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_MarkAllShardsUnrecoverableResponse = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_MarkAllShardsUnrecoverableResponse{markAllShardsUnrecoverableResponse_shards_succeeded = markAllShardsUnrecoverableResponse_shards_succeeded obj} then Nothing else Just $ default_MarkAllShardsUnrecoverableResponse{markAllShardsUnrecoverableResponse_shards_succeeded = markAllShardsUnrecoverableResponse_shards_succeeded obj}
    , if obj == default_MarkAllShardsUnrecoverableResponse{markAllShardsUnrecoverableResponse_shards_failed = markAllShardsUnrecoverableResponse_shards_failed obj} then Nothing else Just $ default_MarkAllShardsUnrecoverableResponse{markAllShardsUnrecoverableResponse_shards_failed = markAllShardsUnrecoverableResponse_shards_failed obj}
    ]
-- | Translate a 'MarkAllShardsUnrecoverableResponse' to a 'Types.ThriftVal'
from_MarkAllShardsUnrecoverableResponse :: MarkAllShardsUnrecoverableResponse -> Types.ThriftVal
from_MarkAllShardsUnrecoverableResponse record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v105 -> Just (1, ("shards_succeeded",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v107 -> Common_Types.from_ShardID _v107) $ Vector.toList _v105))) $ markAllShardsUnrecoverableResponse_shards_succeeded record
  , (\_v105 -> Just (2, ("shards_failed",Types.TList (Types.T_STRUCT Common_Types.typemap_ShardID) $ map (\_v109 -> Common_Types.from_ShardID _v109) $ Vector.toList _v105))) $ markAllShardsUnrecoverableResponse_shards_failed record
  ]
-- | Write a 'MarkAllShardsUnrecoverableResponse' with the given 'Thrift.Protocol'
write_MarkAllShardsUnrecoverableResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverableResponse -> IO ()
write_MarkAllShardsUnrecoverableResponse oprot record = Thrift.writeVal oprot $ from_MarkAllShardsUnrecoverableResponse record
-- | Serialize a 'MarkAllShardsUnrecoverableResponse' in pure code
encode_MarkAllShardsUnrecoverableResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> MarkAllShardsUnrecoverableResponse -> BS.ByteString
encode_MarkAllShardsUnrecoverableResponse oprot record = Thrift.serializeVal oprot $ from_MarkAllShardsUnrecoverableResponse record
-- | Translate a 'Types.ThriftVal' to a 'MarkAllShardsUnrecoverableResponse'
to_MarkAllShardsUnrecoverableResponse :: Types.ThriftVal -> MarkAllShardsUnrecoverableResponse
to_MarkAllShardsUnrecoverableResponse (Types.TStruct fields) = MarkAllShardsUnrecoverableResponse{
  markAllShardsUnrecoverableResponse_shards_succeeded = maybe (markAllShardsUnrecoverableResponse_shards_succeeded default_MarkAllShardsUnrecoverableResponse) (\(_,_val111) -> (case _val111 of {Types.TList _ _val112 -> (Vector.fromList $ map (\_v113 -> (case _v113 of {Types.TStruct _val114 -> (Common_Types.to_ShardID (Types.TStruct _val114)); _ -> error "wrong type"})) _val112); _ -> error "wrong type"})) (Map.lookup (1) fields),
  markAllShardsUnrecoverableResponse_shards_failed = maybe (markAllShardsUnrecoverableResponse_shards_failed default_MarkAllShardsUnrecoverableResponse) (\(_,_val111) -> (case _val111 of {Types.TList _ _val115 -> (Vector.fromList $ map (\_v116 -> (case _v116 of {Types.TStruct _val117 -> (Common_Types.to_ShardID (Types.TStruct _val117)); _ -> error "wrong type"})) _val115); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_MarkAllShardsUnrecoverableResponse _ = error "not a struct"
-- | Read a 'MarkAllShardsUnrecoverableResponse' struct with the given 'Thrift.Protocol'
read_MarkAllShardsUnrecoverableResponse :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO MarkAllShardsUnrecoverableResponse
read_MarkAllShardsUnrecoverableResponse iprot = to_MarkAllShardsUnrecoverableResponse <$> Thrift.readVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverableResponse)
-- | Deserialize a 'MarkAllShardsUnrecoverableResponse' in pure code
decode_MarkAllShardsUnrecoverableResponse :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> MarkAllShardsUnrecoverableResponse
decode_MarkAllShardsUnrecoverableResponse iprot bs = to_MarkAllShardsUnrecoverableResponse $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_MarkAllShardsUnrecoverableResponse) bs
-- | 'TypeMap' for the 'MarkAllShardsUnrecoverableResponse' struct
typemap_MarkAllShardsUnrecoverableResponse :: Types.TypeMap
typemap_MarkAllShardsUnrecoverableResponse = Map.fromList [("shards_succeeded",(1,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID)))),("shards_failed",(2,(Types.T_LIST (Types.T_STRUCT Common_Types.typemap_ShardID))))]
-- | Default values for the 'MarkAllShardsUnrecoverableResponse' struct
default_MarkAllShardsUnrecoverableResponse :: MarkAllShardsUnrecoverableResponse
default_MarkAllShardsUnrecoverableResponse = MarkAllShardsUnrecoverableResponse{
  markAllShardsUnrecoverableResponse_shards_succeeded = Vector.empty,
  markAllShardsUnrecoverableResponse_shards_failed = Vector.empty}
